/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	readonly "/addon": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		readonly get?: never
		/**
		 * Update an installed app
		 * @description Updates the application installation for the user.
		 *
		 *     This endpoint is intended to be used by Bitbucket Connect apps
		 *     and only supports JWT authentication -- that is how Bitbucket
		 *     identifies the particular installation of the app. Developers
		 *     with applications registered in the "Develop Apps" section
		 *     of Bitbucket need not use this endpoint as updates for those
		 *     applications can be sent out via the UI of that section.
		 *
		 *     Passing an empty body will update the installation using the
		 *     existing descriptor URL.
		 *
		 *     ```
		 *     $ curl -X PUT https://api.bitbucket.org/2.0/addon \
		 *       -H "Authorization: JWT <JWT Token>" \
		 *       --header "Content-Type: application/json" \
		 *       --data '{}'
		 *     ```
		 *
		 *     The new `descriptor` for the installation can be also provided
		 *     in the body directly.
		 *
		 *     ```
		 *     $ curl -X PUT https://api.bitbucket.org/2.0/addon \
		 *       -H "Authorization: JWT <JWT Token>" \
		 *       --header "Content-Type: application/json" \
		 *       --data '{"descriptor": $NEW_DESCRIPTOR}'
		 *     ```
		 *
		 *     In both these modes the URL of the descriptor cannot be changed. To
		 *     change the descriptor location and upgrade an installation
		 *     the request must be made exclusively with a `descriptor_url`.
		 *
		 *      ```
		 *     $ curl -X PUT https://api.bitbucket.org/2.0/addon \
		 *       -H "Authorization: JWT <JWT Token>" \
		 *       --header "Content-Type: application/json" \
		 *       --data '{"descriptor_url": $NEW_URL}'
		 *     ```
		 *
		 *     The `descriptor_url` must exactly match the marketplace registration
		 *     that Atlassian has for the application. Contact your Atlassian
		 *     developer advocate to update this registration. Once the registration
		 *     has been updated you may call this resource for each installation.
		 *
		 *     Note that the scopes of the application cannot be increased
		 *     in the new descriptor nor reduced to none.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Request has succeeded. The installation has been updated to the new descriptor. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Scopes have increased or decreased to none. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description No authorization. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description Improper authentication. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete an app
		 * @description Deletes the application for the user.
		 *
		 *     This endpoint is intended to be used by Bitbucket Connect apps
		 *     and only supports JWT authentication -- that is how Bitbucket
		 *     identifies the particular installation of the app. Developers
		 *     with applications registered in the "Develop Apps" section
		 *     of Bitbucket Marketplace need not use this endpoint as
		 *     updates for those applications can be sent out via the
		 *     UI of that section.
		 *
		 *     ```
		 *     $ curl -X DELETE https://api.bitbucket.org/2.0/addon \
		 *       -H "Authorization: JWT <JWT Token>"
		 *     ```
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Request has succeeded. The application has been deleted for the user. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description No authorization. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description Improper authentication. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/addon/linkers": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List linkers for an app
		 * @description Gets a list of all [linkers](/cloud/bitbucket/modules/linker/)
		 *     for the authenticated application.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/addon/linkers/{linker_key}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
				 *     as defined in an application descriptor. */
				readonly linker_key: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a linker for an app
		 * @description Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key`
		 *     for the authenticated application.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/addon/linkers/{linker_key}/values": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
				 *     as defined in an application descriptor. */
				readonly linker_key: string
			}
			readonly cookie?: never
		}
		/**
		 * List linker values for a linker
		 * @description Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the
		 *     specified linker of the authenticated application.
		 *
		 *     A linker value lets applications supply values to modify its regular expression.
		 *
		 *     The base regular expression must use a Bitbucket-specific match group `(?K)`
		 *     which will be translated to `([\w\-]+)`. A value must match this pattern.
		 *
		 *     [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a linker value
		 * @description Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified
		 *     linker of the authenticated application.
		 *
		 *     A linker value lets applications supply values to modify its regular expression.
		 *
		 *     The base regular expression must use a Bitbucket-specific match group `(?K)`
		 *     which will be translated to `([\w\-]+)`. A value must match this pattern.
		 *
		 *     [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successfully updated the linker values. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Invalid input. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Create a linker value
		 * @description Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified
		 *     linker of authenticated application.
		 *
		 *     A linker value lets applications supply values to modify its regular expression.
		 *
		 *     The base regular expression must use a Bitbucket-specific match group `(?K)`
		 *     which will be translated to `([\w\-]+)`. A value must match this pattern.
		 *
		 *     [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successfully created the linker value. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker already has the value being added. */
				readonly 409: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Delete all linker values
		 * @description Delete all [linker](/cloud/bitbucket/modules/linker/) values for the
		 *     specified linker of the authenticated application.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successfully deleted the linker values. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/addon/linkers/{linker_key}/values/{value_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
				 *     as defined in an application descriptor. */
				readonly linker_key: string
				/** @description The numeric ID of the linker value. */
				readonly value_id: number
			}
			readonly cookie?: never
		}
		/**
		 * Get a linker value
		 * @description Get a single [linker](/cloud/bitbucket/modules/linker/) value
		 *     of the authenticated application.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
					/** @description The numeric ID of the linker value. */
					readonly value_id: number
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker value does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a linker value
		 * @description Delete a single [linker](/cloud/bitbucket/modules/linker/) value
		 *     of the authenticated application.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The unique key of a [linker module](/cloud/bitbucket/modules/linker/)
					 *     as defined in an application descriptor. */
					readonly linker_key: string
					/** @description The numeric ID of the linker value. */
					readonly value_id: number
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successfully deleted the linker value. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Authentication must use app JWT */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The linker value does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/hook_events": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a webhook resource
		 * @description Returns the webhook resource or subject types on which webhooks can
		 *     be registered.
		 *
		 *     Each resource/subject type contains an `events` link that returns the
		 *     paginated list of specific events each individual subject type can
		 *     emit.
		 *
		 *     This endpoint is publicly accessible and does not require
		 *     authentication or scopes.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A mapping of resource/subject types pointing to their individual event types. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["subject_types"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/hook_events/{subject_type}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description A resource or subject type. */
				readonly subject_type: "repository" | "workspace"
			}
			readonly cookie?: never
		}
		/**
		 * List subscribable webhook types
		 * @description Returns a paginated list of all valid webhook events for the
		 *     specified entity.
		 *     **The team and user webhooks are deprecated, and you should use workspace instead.
		 *     For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**
		 *
		 *     This is public data that does not require any scopes or authentication.
		 *
		 *     NOTE: The example response is a truncated response object for the `workspace` `subject_type`.
		 *     We return the same structure for the other `subject_type` objects.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description A resource or subject type. */
					readonly subject_type: "repository" | "workspace"
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of webhook types available to subscribe on. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_hook_events"]
					}
				}
				/** @description If an invalid `{subject_type}` value was specified. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List public repositories
		 * @description Returns a paginated list of all public repositories.
		 *
		 *     This endpoint also supports filtering and sorting of the results. See
		 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Filter the results to include only repositories created on or
					 *     after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)
					 *      timestamp. Example: `YYYY-MM-DDTHH:mm:ss.sssZ` */
					readonly after?: string
					/** @description Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *     `role` parameter must also be specified.
					 *      */
					readonly q?: string
					/** @description Filters the result based on the authenticated user's role on each repository.
					 *
					 *     * **member**: returns repositories to which the user has explicit read access
					 *     * **contributor**: returns repositories to which the user has explicit write access
					 *     * **admin**: returns repositories to which the user has explicit administrator access
					 *     * **owner**: returns all repositories owned by the current user
					 *      */
					readonly role?: "admin" | "contributor" | "member" | "owner"
					/** @description Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description All public repositories. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repositories"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List repositories in a workspace
		 * @description Returns a paginated list of all repositories owned by the specified
		 *     workspace.
		 *
		 *     The result can be narrowed down based on the authenticated user's role.
		 *
		 *     E.g. with `?role=contributor`, only those repositories that the
		 *     authenticated user has write access to are returned (this includes any
		 *     repo the user is an admin on, as that implies write access).
		 *
		 *     This endpoint also supports filtering and sorting of the results. See
		 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly q?: string
					/** @description
					 *     Filters the result based on the authenticated user's role on each repository.
					 *
					 *     * **member**: returns repositories to which the user has explicit read access
					 *     * **contributor**: returns repositories to which the user has explicit write access
					 *     * **admin**: returns repositories to which the user has explicit administrator access
					 *     * **owner**: returns all repositories owned by the current user
					 *      */
					readonly role?: "admin" | "contributor" | "member" | "owner"
					/** @description
					 *     Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *              */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The repositories owned by the specified account. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repositories"]
					}
				}
				/** @description If the specified account does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified account marked as spam. */
				readonly 410: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a repository
		 * @description Returns the object describing this repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The repository object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have access to it. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If no repository exists at this location. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a repository
		 * @description Since this endpoint can be used to both update and to create a
		 *     repository, the request body depends on the intent.
		 *
		 *     #### Creation
		 *
		 *     See the POST documentation for the repository endpoint for an example
		 *     of the request body.
		 *
		 *     #### Update
		 *
		 *     Note: Changing the `name` of the repository will cause the location to
		 *     be changed. This is because the URL of the repo is derived from the
		 *     name (a process called slugification). In such a scenario, it is
		 *     possible for the request to fail if the newly created slug conflicts
		 *     with an existing repository's slug. But if there is no conflict,
		 *     the new location will be returned in the `Location` header of the
		 *     response.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The repository that is to be updated.
			 *
			 *     Note that the elements "owner" and "full_name" are ignored since the
			 *     URL implies them.
			 *      */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["repository"]
				}
			}
			readonly responses: {
				/** @description The existing repository has been updated */
				readonly 200: {
					headers: {
						/** @description The location of the repository. This header is only
						 *     provided when the repository's name is changed. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["repository"]
					}
				}
				/** @description A new repository has been created */
				readonly 201: {
					headers: {
						/** @description The location of the newly created repository */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["repository"]
					}
				}
				/** @description If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Create a repository
		 * @description Creates a new repository.
		 *
		 *     Note: In order to set the project for the newly created repository,
		 *     pass in either the project key or the project UUID as part of the
		 *     request body as shown in the examples below:
		 *
		 *     ```
		 *     $ curl -X POST -H "Content-Type: application/json" -d '{
		 *         "scm": "git",
		 *         "project": {
		 *             "key": "MARS"
		 *         }
		 *     }' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding
		 *     ```
		 *
		 *     or
		 *
		 *     ```
		 *     $ curl -X POST -H "Content-Type: application/json" -d '{
		 *         "scm": "git",
		 *         "project": {
		 *             "key": "{ba516952-992a-4c2d-acbd-17d502922f96}"
		 *         }
		 *     }' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding
		 *     ```
		 *
		 *     The project must be assigned for all repositories. If the project is not provided,
		 *     the repository is automatically assigned to the oldest project in the workspace.
		 *
		 *     Note: In the examples above, the workspace ID `teamsinspace`,
		 *     and/or the repository name `hablanding` can be replaced by UUIDs.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The repository that is to be created. Note that most object elements are optional. Elements "owner" and "full_name" are ignored as the URL implies them. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["repository"]
				}
			}
			readonly responses: {
				/** @description The newly created repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository"]
					}
				}
				/** @description If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Delete a repository
		 * @description Deletes the repository. This is an irreversible operation.
		 *
		 *     This does not affect its forks.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: {
					/** @description If a repository has been moved to a new location, use this parameter to
					 *     show users a friendly message in the Bitbucket UI that the repository
					 *     has moved to a new location. However, a GET to this endpoint will still
					 *     return a 404.
					 *      */
					readonly redirect_to?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates successful deletion. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the caller either does not have admin access to the repository, or the repository is set to read-only. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/branch-restrictions": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List branch restrictions
		 * @description Returns a paginated list of all branch restrictions on the
		 *     repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Branch restrictions of this type */
					readonly kind?: string
					/** @description Branch restrictions applied to branches of this pattern */
					readonly pattern?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of branch restrictions */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_branchrestrictions"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a branch restriction rule
		 * @description Creates a new branch restriction rule for a repository.
		 *
		 *     `kind` describes what will be restricted. Allowed values include:
		 *     `push`, `force`, `delete`, `restrict_merges`, `require_tasks_to_be_completed`,
		 *     `require_approvals_to_merge`, `require_default_reviewer_approvals_to_merge`,
		 *     `require_no_changes_requested`, `require_passing_builds_to_merge`, `require_commits_behind`,
		 *     `reset_pullrequest_approvals_on_change`, `smart_reset_pullrequest_approvals`,
		 *     `reset_pullrequest_changes_requested_on_change`, `require_all_dependencies_merged`,
		 *     `enforce_merge_checks`, and `allow_auto_merge_when_builds_pass`.
		 *
		 *     Different kinds of branch restrictions have different requirements:
		 *
		 *     * `push` and `restrict_merges` require `users` and `groups` to be
		 *       specified. Empty lists are allowed, in which case permission is
		 *       denied for everybody.
		 *
		 *     The restriction applies to all branches that match. There are
		 *     two ways to match a branch. It is configured in `branch_match_kind`:
		 *
		 *     1. `glob`: Matches a branch against the `pattern`. A `'*'` in
		 *        `pattern` will expand to match zero or more characters, and every
		 *        other character matches itself. For example, `'foo*'` will match
		 *        `'foo'` and `'foobar'`, but not `'barfoo'`. `'*'` will match all
		 *        branches.
		 *     2. `branching_model`: Matches a branch against the repository's
		 *        branching model. The `branch_type` controls the type of branch
		 *        to match. Allowed values include: `production`, `development`,
		 *        `bugfix`, `release`, `feature` and `hotfix`.
		 *
		 *     The combination of `kind` and match must be unique. This means that
		 *     two `glob` restrictions in a repository cannot have the same `kind` and
		 *     `pattern`. Additionally, two `branching_model` restrictions in a
		 *     repository cannot have the same `kind` and `branch_type`.
		 *
		 *     `users` and `groups` are lists of users and groups that are except from
		 *     the restriction. They can only be configured in `push` and
		 *     `restrict_merges` restrictions. The `push` restriction stops a user
		 *     pushing to matching branches unless that user is in `users` or is a
		 *     member of a group in `groups`. The `restrict_merges` stops a user
		 *     merging pull requests to matching branches unless that user is in
		 *     `users` or is a member of a group in `groups`. Adding new users or
		 *     groups to an existing restriction should be done via `PUT`.
		 *
		 *     Note that branch restrictions with overlapping matchers is allowed,
		 *     but the resulting behavior may be surprising.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new rule */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["branchrestriction"]
				}
			}
			readonly responses: {
				/** @description A paginated list of branch restrictions */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branchrestriction"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The restriction rule's id */
				readonly id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a branch restriction rule
		 * @description Returns a specific branch restriction rule.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The restriction rule's id */
					readonly id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The branch restriction rule */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branchrestriction"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository or branch restriction id does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a branch restriction rule
		 * @description Updates an existing branch restriction rule.
		 *
		 *     Fields not present in the request body are ignored.
		 *
		 *     See [`POST`](/cloud/bitbucket/rest/api-group-branch-restrictions/#api-repositories-workspace-repo-slug-branch-restrictions-post) for details.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The restriction rule's id */
					readonly id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new version of the existing rule */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["branchrestriction"]
				}
			}
			readonly responses: {
				/** @description The updated branch restriction rule */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branchrestriction"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository or branch restriction id does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a branch restriction rule
		 * @description Deletes an existing branch restriction rule.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The restriction rule's id */
					readonly id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository or branch restriction id does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/branching-model": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the branching model for a repository
		 * @description Return the branching model as applied to the repository. This view is
		 *     read-only. The branching model settings can be changed using the
		 *     [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.
		 *
		 *     The returned object:
		 *
		 *     1. Always has a `development` property. `development.branch` contains
		 *        the actual repository branch object that is considered to be the
		 *        `development` branch. `development.branch` will not be present
		 *        if it does not exist.
		 *     2. Might have a `production` property. `production` will not
		 *        be present when `production` is disabled.
		 *        `production.branch` contains the actual branch object that is
		 *        considered to be the `production` branch. `production.branch` will
		 *        not be present if it does not exist.
		 *     3. Always has a `branch_types` array which contains all enabled branch
		 *        types.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The branching model object */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branching_model"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have read access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/branching-model/settings": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the branching model config for a repository
		 * @description Return the branching model configuration for a repository. The returned
		 *     object:
		 *
		 *     1. Always has a `development` property for the development branch.
		 *     2. Always a `production` property for the production branch. The
		 *        production branch can be disabled.
		 *     3. The `branch_types` contains all the branch types.
		 *
		 *     This is the raw configuration for the branching model. A client
		 *     wishing to see the branching model with its actual current branches may
		 *     find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The branching model configuration */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branching_model_settings"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update the branching model config for a repository
		 * @description Update the branching model configuration for a repository.
		 *
		 *     The `development` branch can be configured to a specific branch or to
		 *     track the main branch. When set to a specific branch it must
		 *     currently exist. Only the passed properties will be updated. The
		 *     properties not passed will be left unchanged. A request without a
		 *     `development` property will leave the development branch unchanged.
		 *
		 *     It is possible for the `development` branch to be invalid. This
		 *     happens when it points at a specific branch that has been
		 *     deleted. This is indicated in the `is_valid` field for the branch. It is
		 *     not possible to update the settings for `development` if that
		 *     would leave the branch in an invalid state. Such a request will be
		 *     rejected.
		 *
		 *     The `production` branch can be a specific branch, the main
		 *     branch or disabled. When set to a specific branch it must currently
		 *     exist. The `enabled` property can be used to enable (`true`) or
		 *     disable (`false`) it. Only the passed properties will be updated. The
		 *     properties not passed will be left unchanged. A request without a
		 *     `production` property will leave the production branch unchanged.
		 *
		 *     It is possible for the `production` branch to be invalid. This
		 *     happens when it points at a specific branch that has been
		 *     deleted. This is indicated in the `is_valid` field for the branch. A
		 *     request that would leave `production` enabled and invalid will be
		 *     rejected. It is possible to update `production` and make it invalid if
		 *     it would also be left disabled.
		 *
		 *     The `branch_types` property contains the branch types to be updated.
		 *     Only the branch types passed will be updated. All updates will be
		 *     rejected if it would leave the branching model in an invalid state.
		 *     For branch types this means that:
		 *
		 *     1. The prefixes for all enabled branch types are valid. For example,
		 *        it is not possible to use '*' inside a Git prefix.
		 *     2. A prefix of an enabled branch type must not be a prefix of another
		 *        enabled branch type. This is to ensure that a branch can be easily
		 *        classified by its prefix unambiguously.
		 *
		 *     It is possible to store an invalid prefix if that branch type would be
		 *     left disabled. Only the passed properties will be updated. The
		 *     properties not passed will be left unchanged. Each branch type must
		 *     have a `kind` property to identify it.
		 *
		 *     There is currently a side effect when using this API endpoint. If the
		 *     repository is inheriting branching model settings from its project,
		 *     updating the branching model for this repository will disable the
		 *     project setting inheritance.
		 *
		 *
		 *     We have deprecated this side effect and will remove it on 1 August 2022.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The updated branching model configuration */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branching_model_settings"]
					}
				}
				/** @description If the request contains invalid branching model configuration */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a commit
		 * @description Returns the specified commit.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The commit object */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["commit"]
					}
				}
				/** @description If the specified commit or repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/approve": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Approve a commit
		 * @description Approve the specified commit as the authenticated user.
		 *
		 *     This operation is only available to users that have explicit access to
		 *     the repository. In contrast, just the fact that a repository is
		 *     publicly accessible to users does not give them the ability to approve
		 *     commits.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The `participant` object recording that the authenticated user approved the commit. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["participant"]
					}
				}
				/** @description If the specified commit, or the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Unapprove a commit
		 * @description Redact the authenticated user's approval of the specified commit.
		 *
		 *     This operation is only available to users that have explicit access to
		 *     the repository. In contrast, just the fact that a repository is
		 *     publicly accessible to users does not give them the ability to approve
		 *     commits.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description An empty response indicating the authenticated user's approval has been withdrawn. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified commit, or the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List a commit's comments
		 * @description Returns the commit's comments.
		 *
		 *     This includes both global and inline comments.
		 *
		 *     The default sorting is oldest to newest and can be overridden with
		 *     the `sort` query parameter.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly q?: string
					/** @description Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commit comments. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_commit_comments"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create comment for a commit
		 * @description Creates new comment on the specified commit.
		 *
		 *     To post a reply to an existing comment, include the `parent.id` field:
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \
		 *       -X POST -u evzijst \
		 *       -H 'Content-Type: application/json' \
		 *       -d '{"content": {"raw": "One more thing!"},
		 *            "parent": {"id": 5728901}}'
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The specified comment. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["commit_comment"]
				}
			}
			readonly responses: {
				/** @description The newly created comment. */
				readonly 201: {
					headers: {
						/** @description The location of the newly created comment. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If the comment was detected as spam, or if the parent comment is not attached to the same node as the new comment */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If a parent ID was passed in that cannot be found */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the comment. */
				readonly comment_id: number
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a commit comment
		 * @description Returns the specified commit comment.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The commit comment. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["commit_comment"]
					}
				}
			}
		}
		/**
		 * Update a commit comment
		 * @description Used to update the contents of a comment. Only the content of the comment can be updated.
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \
		 *       -X PUT -u evzijst \
		 *       -H 'Content-Type: application/json' \
		 *       -d '{"content": {"raw": "One more thing!"}'
		 *     ```
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The updated comment. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["commit_comment"]
				}
			}
			readonly responses: {
				/** @description The newly updated comment. */
				readonly 201: {
					headers: {
						/** @description The location of the newly updated comment. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If the comment update was detected as spam */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a commit comment
		 * @description Deletes the specified commit comment.
		 *
		 *     Note that deleting comments that have visible replies that point to
		 *     them will not really delete the resource. This is to retain the integrity
		 *     of the original comment tree. Instead, the `deleted` element is set to
		 *     `true` and the content is blanked out. The comment will continue to be
		 *     returned by the collections and self endpoints.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates the comment was deleted by this action or a previous delete. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the comment doesn't exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/properties/{app_key}/{property_name}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a commit application property
		 * @description Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
		 */
		readonly get: operations["getCommitHostedPropertyValue"]
		/**
		 * Update a commit application property
		 * @description Update an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
		 */
		readonly put: operations["updateCommitHostedPropertyValue"]
		readonly post?: never
		/**
		 * Delete a commit application property
		 * @description Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a commit.
		 */
		readonly delete: operations["deleteCommitHostedPropertyValue"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List pull requests that contain a commit
		 * @description Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when 'Go to pull request' is clicked from the web interface for a commit's details.
		 */
		readonly get: operations["getPullrequestsForCommit"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List reports
		 * @description Returns a paginated list of Reports linked to this commit.
		 */
		readonly get: operations["getReportsForCommit"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a report
		 * @description Returns a single Report matching the provided ID.
		 */
		readonly get: operations["getReport"]
		/**
		 * Create or update a report
		 * @description Creates or updates a report for the specified commit.
		 *     To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system's name to avoid collisions, for example, mySystem-001.
		 *
		 *     ### Sample cURL request:
		 *     ```
		 *     curl --request PUT 'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001' \
		 *     --header 'Content-Type: application/json' \
		 *     --data-raw '{
		 *         "title": "Security scan report",
		 *         "details": "This pull request introduces 10 new dependency vulnerabilities.",
		 *         "report_type": "SECURITY",
		 *         "reporter": "mySystem",
		 *         "link": "http://www.mysystem.com/reports/001",
		 *         "result": "FAILED",
		 *         "data": [
		 *             {
		 *                 "title": "Duration (seconds)",
		 *                 "type": "DURATION",
		 *                 "value": 14
		 *             },
		 *             {
		 *                 "title": "Safe to merge?",
		 *                 "type": "BOOLEAN",
		 *                 "value": false
		 *             }
		 *         ]
		 *     }'
		 *     ```
		 *
		 *     ### Possible field values:
		 *     report_type: SECURITY, COVERAGE, TEST, BUG
		 *     result: PASSED, FAILED, PENDING
		 *     data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT
		 *
		 *     #### Data field formats
		 *     | Type  Field   | Value Field Type  | Value Field Display |
		 *     |:--------------|:------------------|:--------------------|
		 *     | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text |
		 *     | BOOLEAN	| Boolean | The value will be read as a JSON boolean and displayed as 'Yes' or 'No'. |
		 *     | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. |
		 *     | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. |
		 *     | LINK | Object: `{"text": "Link text here", "href": "https://link.to.annotation/in/external/tool"}` | The value will be read as a JSON object containing the fields "text" and "href" and will be displayed as a clickable link on the report. |
		 *     | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). |
		 *     | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. |
		 *     | TEXT | String | The value will be read as a JSON string and will be displayed as-is |
		 *
		 *     Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information.
		 *
		 */
		readonly put: operations["createOrUpdateReport"]
		readonly post?: never
		/**
		 * Delete a report
		 * @description Deletes a single Report matching the provided ID.
		 */
		readonly delete: operations["deleteReport"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List annotations
		 * @description Returns a paginated list of Annotations for a specified report.
		 */
		readonly get: operations["getAnnotationsForReport"]
		readonly put?: never
		/**
		 * Bulk create or update annotations
		 * @description Bulk upload of annotations.
		 *     Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.
		 *
		 *     Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system's name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.
		 *
		 *     ### Sample cURL request:
		 *     ```
		 *     curl --location 'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mysystem-001/annotations' \
		 *     --header 'Content-Type: application/json' \
		 *     --data-raw '[
		 *       {
		 *             "external_id": "mysystem-annotation001",
		 *             "title": "Security scan report",
		 *             "annotation_type": "VULNERABILITY",
		 *             "summary": "This line represents a security threat.",
		 *             "severity": "HIGH",
		 *           "path": "my-service/src/main/java/com/myCompany/mysystem/logic/Main.java",
		 *             "line": 42
		 *       },
		 *       {
		 *             "external_id": "mySystem-annotation002",
		 *             "title": "Bug report",
		 *             "annotation_type": "BUG",
		 *             "result": "FAILED",
		 *             "summary": "This line might introduce a bug.",
		 *             "severity": "MEDIUM",
		 *           "path": "my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java",
		 *             "line": 13
		 *       }
		 *     ]'
		 *     ```
		 *
		 *     ### Possible field values:
		 *     annotation_type: VULNERABILITY, CODE_SMELL, BUG
		 *     result: PASSED, FAILED, IGNORED, SKIPPED
		 *     severity: HIGH, MEDIUM, LOW, CRITICAL
		 *
		 *     Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information.
		 *
		 */
		readonly post: operations["bulkCreateOrUpdateAnnotations"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get an annotation
		 * @description Returns a single Annotation matching the provided ID.
		 */
		readonly get: operations["getAnnotation"]
		/**
		 * Create or update an annotation
		 * @description Creates or updates an individual annotation for the specified report.
		 *     Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.
		 *
		 *     Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system's name to avoid collisions, for example, mySystem-annotation001.
		 *
		 *     ### Sample cURL request:
		 *     ```
		 *     curl --request PUT 'https://api.bitbucket.org/2.0/repositories/<username>/<reposity-name>/commit/<commit-hash>/reports/mySystem-001/annotations/mysystem-annotation001' \
		 *     --header 'Content-Type: application/json' \
		 *     --data-raw '{
		 *         "title": "Security scan report",
		 *         "annotation_type": "VULNERABILITY",
		 *         "summary": "This line represents a security thread.",
		 *         "severity": "HIGH",
		 *         "path": "my-service/src/main/java/com/myCompany/mysystem/logic/Main.java",
		 *         "line": 42
		 *     }'
		 *     ```
		 *
		 *     ### Possible field values:
		 *     annotation_type: VULNERABILITY, CODE_SMELL, BUG
		 *     result: PASSED, FAILED, IGNORED, SKIPPED
		 *     severity: HIGH, MEDIUM, LOW, CRITICAL
		 *
		 *     Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information.
		 *
		 */
		readonly put: operations["createOrUpdateAnnotation"]
		readonly post?: never
		/**
		 * Delete an annotation
		 * @description Deletes a single Annotation matching the provided ID.
		 */
		readonly delete: operations["deleteAnnotation"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List commit statuses for a commit
		 * @description Returns all statuses (e.g. build results) for a specific commit.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly q?: string
					/** @description If specified, only return commit status objects that were either
					 *     created without a refname, or were created with the specified refname
					 *      */
					readonly refname?: string
					/** @description Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *     Defaults to `created_on`.
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of all commit statuses for this commit. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_commitstatuses"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository or commit does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Create a build status for a commit
		 * @description Creates a new build status against the specified commit.
		 *
		 *     If the specified key already exists, the existing status object will
		 *     be overwritten.
		 *
		 *     Example:
		 *
		 *     ```
		 *     curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H 'Content-Type: application/json'           -d '{
		 *         "key": "MY-BUILD",
		 *         "state": "SUCCESSFUL",
		 *         "description": "42 tests passed",
		 *         "url": "https://www.example.org/my-build-result"
		 *       }'
		 *     ```
		 *
		 *     When creating a new commit status, you can use a URI template for the URL.
		 *     Templates are URLs that contain variable names that Bitbucket will
		 *     evaluate at runtime whenever the URL is displayed anywhere similar to
		 *     parameter substitution in
		 *     [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html).
		 *     For example, one could use `https://foo.com/builds/{repository.full_name}`
		 *     which Bitbucket will turn into `https://foo.com/builds/foo/bar` at render time.
		 *     The context variables available are `repository` and `commit`.
		 *
		 *     To associate a commit status to a pull request, the refname field must be set to the source branch
		 *     of the pull request.
		 *
		 *     Example:
		 *     ```
		 *     curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo/commit/e10dae226959c2194f2b07b077c07762d93821cf/statuses/build/           -X POST -u jdoe -H 'Content-Type: application/json'           -d '{
		 *         "key": "MY-BUILD",
		 *         "state": "SUCCESSFUL",
		 *         "description": "42 tests passed",
		 *         "url": "https://www.example.org/my-build-result",
		 *         "refname": "my-pr-branch"
		 *       }'
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new commit status object. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["commitstatus"]
				}
			}
			readonly responses: {
				/** @description The newly created build status object. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["commitstatus"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository, commit, or build status key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commit/{commit}/statuses/build/{key}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description The build status' unique key */
				readonly key: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a build status for a commit
		 * @description Returns the specified build status for a commit.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description The build status' unique key */
					readonly key: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The build status object with the specified key. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["commitstatus"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository, commit, or build status key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a build status for a commit
		 * @description Used to update the current status of a build status object on the
		 *     specific commit.
		 *
		 *     This operation can also be used to change other properties of the
		 *     build status:
		 *
		 *     * `state`
		 *     * `name`
		 *     * `description`
		 *     * `url`
		 *     * `refname`
		 *
		 *     The `key` cannot be changed.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description The build status' unique key */
					readonly key: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The updated build status object */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["commitstatus"]
				}
			}
			readonly responses: {
				/** @description The updated build status object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["commitstatus"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository or build does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commits": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List commits
		 * @description These are the repository's commits. They are paginated and returned
		 *     in reverse chronological order, similar to the output of `git log`.
		 *     Like these tools, the DAG can be filtered.
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/
		 *
		 *     Returns all commits in the repo in topological order (newest commit
		 *     first). All branches and tags are included (similar to
		 *     `git log --all`).
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master
		 *
		 *     Returns all commits in the repo that are not on master
		 *     (similar to `git log --all ^master`).
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar
		 *
		 *     Returns all commits that are on refs `foo` or `bar`, but not on `fu` or
		 *     `fubar` (similar to `git log foo bar ^fu ^fubar`).
		 *
		 *     An optional `path` parameter can be specified that will limit the
		 *     results to commits that affect that path. `path` can either be a file
		 *     or a directory. If a directory is specified, commits are returned that
		 *     have modified any file in the directory tree rooted by `path`. It is
		 *     important to note that if the `path` parameter is specified, the commits
		 *     returned by this endpoint may no longer be a DAG, parent commits that
		 *     do not modify the path will be omitted from the response.
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master
		 *
		 *     Returns all commits that are on refs `foo` or `bar`, but not on `master`
		 *     that changed the file README.md.
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master
		 *
		 *     Returns all commits that are on refs `foo` or `bar`, but not on `master`
		 *     that changed to a file in any file in the directory src or its children.
		 *
		 *     Because the response could include a very large number of commits, it
		 *     is paginated. Follow the 'next' link in the response to navigate to the
		 *     next page of commits. As with other paginated resources, do not
		 *     construct your own links.
		 *
		 *     When the include and exclude parameters are more than can fit in a
		 *     query string, clients can use a `x-www-form-urlencoded` POST instead.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commits */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_changeset"]
					}
				}
				/** @description If the specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * List commits with include/exclude
		 * @description Identical to `GET /repositories/{workspace}/{repo_slug}/commits`,
		 *     except that POST allows clients to place the include and exclude
		 *     parameters in the request body to avoid URL length issues.
		 *
		 *     **Note that this resource does NOT support new commit creation.**
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commits */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_changeset"]
					}
				}
				/** @description If the specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/commits/{revision}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description A commit SHA1 or ref name. */
				readonly revision: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List commits for revision
		 * @description These are the repository's commits. They are paginated and returned
		 *     in reverse chronological order, similar to the output of `git log`.
		 *     Like these tools, the DAG can be filtered.
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/master
		 *
		 *     Returns all commits on ref `master` (similar to `git log master`).
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include=foo&exclude=master
		 *
		 *     Returns all commits on ref `dev` or `foo`, except those that are reachable on
		 *     `master` (similar to `git log dev foo ^master`).
		 *
		 *     An optional `path` parameter can be specified that will limit the
		 *     results to commits that affect that path. `path` can either be a file
		 *     or a directory. If a directory is specified, commits are returned that
		 *     have modified any file in the directory tree rooted by `path`. It is
		 *     important to note that if the `path` parameter is specified, the commits
		 *     returned by this endpoint may no longer be a DAG, parent commits that
		 *     do not modify the path will be omitted from the response.
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=README.md&include=foo&include=bar&exclude=master
		 *
		 *     Returns all commits that are on refs `dev` or `foo` or `bar`, but not on `master`
		 *     that changed the file README.md.
		 *
		 *     #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path=src/&include=foo&exclude=master
		 *
		 *     Returns all commits that are on refs `dev` or `foo`, but not on `master`
		 *     that changed to a file in any file in the directory src or its children.
		 *
		 *     Because the response could include a very large number of commits, it
		 *     is paginated. Follow the 'next' link in the response to navigate to the
		 *     next page of commits. As with other paginated resources, do not
		 *     construct your own links.
		 *
		 *     When the include and exclude parameters are more than can fit in a
		 *     query string, clients can use a `x-www-form-urlencoded` POST instead.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description A commit SHA1 or ref name. */
					readonly revision: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commits */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_changeset"]
					}
				}
				/** @description If the specified revision does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * List commits for revision using include/exclude
		 * @description Identical to `GET /repositories/{workspace}/{repo_slug}/commits/{revision}`,
		 *     except that POST allows clients to place the include and exclude
		 *     parameters in the request body to avoid URL length issues.
		 *
		 *     **Note that this resource does NOT support new commit creation.**
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description A commit SHA1 or ref name. */
					readonly revision: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commits */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_changeset"]
					}
				}
				/** @description If the specified revision does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/components": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List components
		 * @description Returns the components that have been defined in the issue tracker.
		 *
		 *     This resource is only available on repositories that have the issue
		 *     tracker enabled.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The components that have been defined in the issue tracker. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_components"]
					}
				}
				/** @description The specified repository does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/components/{component_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The component's id */
				readonly component_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a component for issues
		 * @description Returns the specified issue tracker component object.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The component's id */
					readonly component_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified component object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["component"]
					}
				}
				/** @description The specified repository or component does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/default-reviewers": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List default reviewers
		 * @description Returns the repository's default reviewers.
		 *
		 *     These are the users that are automatically added as reviewers on every
		 *     new pull request that is created. To obtain the repository's default reviewers
		 *     as well as the default reviewers inherited from the project, use the
		 *     [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The paginated list of default reviewers */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_accounts"]
					}
				}
				/** @description If the authenticated user does not have access to view the default reviewers */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the username or the UUID of the default reviewer,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly target_username: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a default reviewer
		 * @description Returns the specified reviewer.
		 *
		 *     This can be used to test whether a user is among the repository's
		 *     default reviewers list. A 404 indicates that that specified user is not
		 *     a default reviewer.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the username or the UUID of the default reviewer,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly target_username: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified user is a default reviewer */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["account"]
					}
				}
				/** @description If the authenticated user does not have access to check if the specified user is a default reviewer */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified user does not exist or is not a default reviewer */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Add a user to the default reviewers
		 * @description Adds the specified user to the repository's list of default
		 *     reviewers.
		 *
		 *     This method is idempotent. Adding a user a second time has no effect.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the username or the UUID of the default reviewer,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly target_username: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified user was successfully added to the default reviewers */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["account"]
					}
				}
				/** @description If the authenticated user tried to add a team, bot user, or user without access to the repository to the default reviewers */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have permission to modify the default reviewers */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Remove a user from the default reviewers
		 * @description Removes a default reviewer from the repository.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the username or the UUID of the default reviewer,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly target_username: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified user successfully removed from the default reviewers */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access modify the default reviewers */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/deploy-keys": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List repository deploy keys
		 * @description Returns all deploy-keys belonging to a repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Deploy keys matching the repository */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_deploy_keys"]
					}
				}
				/** @description If the specified user or repository is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user or repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Add a repository deploy key
		 * @description Create a new deploy key in a repository. Note: If authenticating a deploy key
		 *     with an OAuth consumer, any changes to the OAuth consumer will subsequently
		 *     invalidate the deploy key.
		 *
		 *
		 *     Example:
		 *     ```
		 *     $ curl -X POST \
		 *     -H "Authorization <auth header>" \
		 *     -H "Content-type: application/json" \
		 *     https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \
		 *     '{
		 *         "key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8",
		 *         "label": "mydeploykey"
		 *     }'
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The deploy key that was created */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["deploy_key"]
					}
				}
				/** @description Invalid deploy key inputs */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user or repository is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user or repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/deploy-keys/{key_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key ID matching the deploy key. */
				readonly key_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a repository deploy key
		 * @description Returns the deploy key belonging to a specific key.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The key ID matching the deploy key. */
					readonly key_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Deploy key matching the key ID */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["deploy_key"]
					}
				}
				/** @description If the specified user or repository is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user or repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a repository deploy key
		 * @description Create a new deploy key in a repository.
		 *
		 *     The same key needs to be passed in but the comment and label can change.
		 *
		 *     Example:
		 *     ```
		 *     $ curl -X PUT \
		 *     -H "Authorization <auth header>" \
		 *     -H "Content-type: application/json" \
		 *     https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \
		 *     '{
		 *         "label": "newlabel",
		 *         "key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment",
		 *     }'
		 *     ```
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The key ID matching the deploy key. */
					readonly key_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The newly updated deploy key. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["deploy_key"]
					}
				}
				/** @description If the submitted key or related value is invalid */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the current user does not have permission to add a key for the specified user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user, repository, or deploy key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a repository deploy key
		 * @description This deletes a deploy key from a repository.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The key ID matching the deploy key. */
					readonly key_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The key has been deleted */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the current user does not have permission to delete a key for the specified user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user, repository, or deploy key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/deployments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List deployments
		 * @description Find deployments
		 */
		readonly get: operations["getDeploymentsForRepository"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List variables for an environment
		 * @description Find deployment environment level variables.
		 */
		readonly get: operations["getDeploymentVariables"]
		readonly put?: never
		/**
		 * Create a variable for an environment
		 * @description Create a deployment environment level variable.
		 */
		readonly post: operations["createDeploymentVariable"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		readonly get?: never
		/**
		 * Update a variable for an environment
		 * @description Update a deployment environment level variable.
		 */
		readonly put: operations["updateDeploymentVariable"]
		readonly post?: never
		/**
		 * Delete a variable for an environment
		 * @description Delete a deployment environment level variable.
		 */
		readonly delete: operations["deleteDeploymentVariable"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/deployments/{deployment_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a deployment
		 * @description Retrieve a deployment
		 */
		readonly get: operations["getDeploymentForRepository"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/diff/{spec}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description A commit SHA (e.g. `3a8b42`) or a commit range using double dot
				 *     notation (e.g. `3a8b42..9ff173`).
				 *      */
				readonly spec: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Compare two commits
		 * @description Produces a raw git-style diff.
		 *
		 *     #### Single commit spec
		 *
		 *     If the `spec` argument to this API is a single commit, the diff is
		 *     produced against the first parent of the specified commit.
		 *
		 *     #### Two commit spec
		 *
		 *     Two commits separated by `..` may be provided as the `spec`, e.g.,
		 *     `3a8b42..9ff173`. When two commits are provided and the `topic` query
		 *     parameter is true, this API produces a 2-way three dot diff.
		 *     This is the diff between source commit and the merge base of the source
		 *     commit and the destination commit. When the `topic` query param is false,
		 *     a simple git-style diff is produced.
		 *
		 *     The two commits are interpreted as follows:
		 *
		 *     * First commit: the commit containing the changes we wish to preview
		 *     * Second commit: the commit representing the state to which we want to
		 *       compare the first commit
		 *     * **Note**: This is the opposite of the order used in `git diff`.
		 *
		 *     #### Comparison to patches
		 *
		 *     While similar to patches, diffs:
		 *
		 *     * Don't have a commit header (username, commit message, etc)
		 *     * Support the optional `path=foo/bar.py` query param to filter
		 *       the diff to just that one file diff
		 *
		 *     #### Response
		 *
		 *     The raw diff is returned as-is, in whatever encoding the files in the
		 *     repository use. It is not decoded into unicode. As such, the
		 *     content-type is `text/plain`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Generate diffs that include binary files, true if omitted. */
					readonly binary?: boolean
					/** @description Generate diffs with <n> lines of context instead of the usual three. */
					readonly context?: number
					/** @description Generate diffs that ignore whitespace. */
					readonly ignore_whitespace?: boolean
					/** @description This parameter is deprecated. The 'topic' parameter should be used
					 *     instead. The 'merge' and 'topic' parameters cannot be both used at
					 *     the same time.
					 *
					 *     If true, the source commit is merged into the
					 *     destination commit, and then a diff from the
					 *     destination to the merge result is returned. If false,
					 *     a simple 'two dot' diff between the source and
					 *     destination is returned. True if omitted. */
					readonly merge?: boolean
					/** @description Limit the diff to a particular file (this parameter
					 *     can be repeated for multiple paths). */
					readonly path?: string
					/** @description Whether to perform rename detection, true if omitted. */
					readonly renames?: boolean
					/** @description If true, returns 2-way 'three-dot' diff.
					 *     This is a diff between the source commit and the merge base
					 *     of the source commit and the destination commit.
					 *     If false, a simple 'two dot' diff between the source and
					 *     destination is returned. */
					readonly topic?: boolean
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description A commit SHA (e.g. `3a8b42`) or a commit range using double dot
					 *     notation (e.g. `3a8b42..9ff173`).
					 *      */
					readonly spec: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The raw diff */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the diff was too large and timed out.
				 *
				 *     Since this endpoint does not employ any form of pagination, but
				 *     instead returns the diff as a single document, it can run into
				 *     trouble on very large diffs. If Bitbucket times out in cases
				 *     like these, a 555 status code is returned. */
				readonly 555: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/diffstat/{spec}": {
		readonly parameters: {
			readonly query?: {
				/** @description Generate diffs that ignore whitespace */
				readonly ignore_whitespace?: boolean
				/** @description This parameter is deprecated. The 'topic' parameter should be used
				 *     instead. The 'merge' and 'topic' parameters cannot be both used at
				 *     the same time.
				 *
				 *     If true, the source commit is merged into the
				 *     destination commit, and then a diffstat from the
				 *     destination to the merge result is returned. If false,
				 *     a simple 'two dot' diffstat between the source and
				 *     destination is returned. True if omitted. */
				readonly merge?: boolean
				/** @description Limit the diffstat to a particular file (this parameter
				 *     can be repeated for multiple paths). */
				readonly path?: string
				/** @description Whether to perform rename detection, true if omitted. */
				readonly renames?: boolean
				/** @description If true, returns 2-way 'three-dot' diff.
				 *     This is a diff between the source commit and the merge base
				 *     of the source commit and the destination commit.
				 *     If false, a simple 'two dot' diff between the source and
				 *     destination is returned. */
				readonly topic?: boolean
			}
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description A commit SHA (e.g. `3a8b42`) or a commit range using double dot
				 *     notation (e.g. `3a8b42..9ff173`).
				 *      */
				readonly spec: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Compare two commit diff stats
		 * @description Produces a response in JSON format with a record for every path
		 *     modified, including information on the type of the change and the
		 *     number of lines added and removed.
		 *
		 *     #### Single commit spec
		 *
		 *     If the `spec` argument to this API is a single commit, the diff is
		 *     produced against the first parent of the specified commit.
		 *
		 *     #### Two commit spec
		 *
		 *     Two commits separated by `..` may be provided as the `spec`, e.g.,
		 *     `3a8b42..9ff173`. When two commits are provided and the `topic` query
		 *     parameter is true, this API produces a 2-way three dot diff.
		 *     This is the diff between source commit and the merge base of the source
		 *     commit and the destination commit. When the `topic` query param is false,
		 *     a simple git-style diff is produced.
		 *
		 *     The two commits are interpreted as follows:
		 *
		 *     * First commit: the commit containing the changes we wish to preview
		 *     * Second commit: the commit representing the state to which we want to
		 *       compare the first commit
		 *     * **Note**: This is the opposite of the order used in `git diff`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Generate diffs that ignore whitespace */
					readonly ignore_whitespace?: boolean
					/** @description This parameter is deprecated. The 'topic' parameter should be used
					 *     instead. The 'merge' and 'topic' parameters cannot be both used at
					 *     the same time.
					 *
					 *     If true, the source commit is merged into the
					 *     destination commit, and then a diffstat from the
					 *     destination to the merge result is returned. If false,
					 *     a simple 'two dot' diffstat between the source and
					 *     destination is returned. True if omitted. */
					readonly merge?: boolean
					/** @description Limit the diffstat to a particular file (this parameter
					 *     can be repeated for multiple paths). */
					readonly path?: string
					/** @description Whether to perform rename detection, true if omitted. */
					readonly renames?: boolean
					/** @description If true, returns 2-way 'three-dot' diff.
					 *     This is a diff between the source commit and the merge base
					 *     of the source commit and the destination commit.
					 *     If false, a simple 'two dot' diff between the source and
					 *     destination is returned. */
					readonly topic?: boolean
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description A commit SHA (e.g. `3a8b42`) or a commit range using double dot
					 *     notation (e.g. `3a8b42..9ff173`).
					 *      */
					readonly spec: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The diff stats */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_diffstats"]
					}
				}
				/** @description If generating the diffstat timed out. */
				readonly 555: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/downloads": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List download artifacts
		 * @description Returns a list of download links associated with the repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Returns a paginated list of the downloads associated with the repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description User is not authorized to read from the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Upload a download artifact
		 * @description Upload new download artifacts.
		 *
		 *     To upload files, perform a `multipart/form-data` POST containing one
		 *     or more `files` fields:
		 *
		 *         $ echo Hello World > hello.txt
		 *         $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files=@hello.txt
		 *
		 *     When a file is uploaded with the same name as an existing artifact,
		 *     then the existing file will be replaced.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The artifact was uploaded sucessfully. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Bad Request. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description User is not authorized to write to the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description Unsupported Content-Type. Use multiplart/form-data. */
				readonly 406: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/downloads/{filename}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Name of the file. */
				readonly filename: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a download artifact link
		 * @description Return a redirect to the contents of a download artifact.
		 *
		 *     This endpoint returns the actual file contents and not the artifact's
		 *     metadata.
		 *
		 *         $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt
		 *         Hello World
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Name of the file. */
					readonly filename: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Redirects to the url of the specified download artifact. */
				readonly 302: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description User is not authorized to read from the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified download artifact does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a download artifact
		 * @description Deletes the specified download artifact from the repository.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Name of the file. */
					readonly filename: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified download artifact was deleted. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description User is not authorized to write to the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified download does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/effective-branching-model": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** Get the effective, or currently applied, branching model for a repository */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The effective branching model object */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["effective_repo_branching_model"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have read access to the repository */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/effective-default-reviewers": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List effective default reviewers
		 * @description Returns the repository's effective default reviewers. This includes both default
		 *     reviewers defined at the repository level as well as those inherited from its project.
		 *
		 *     These are the users that are automatically added as reviewers on every
		 *     new pull request that is created.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The paginated list of effective default reviewers */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_default_reviewer_and_type"]
					}
				}
				/** @description If the authenticated user does not have access to view the default reviewers */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/environments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List environments
		 * @description Find environments
		 */
		readonly get: operations["getEnvironmentsForRepository"]
		readonly put?: never
		/**
		 * Create an environment
		 * @description Create an environment.
		 */
		readonly post: operations["createEnvironment"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get an environment
		 * @description Retrieve an environment
		 */
		readonly get: operations["getEnvironmentForRepository"]
		readonly put?: never
		readonly post?: never
		/**
		 * Delete an environment
		 * @description Delete an environment
		 */
		readonly delete: operations["deleteEnvironmentForRepository"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/environments/{environment_uuid}/changes": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Update an environment
		 * @description Update an environment
		 */
		readonly post: operations["updateEnvironmentForRepository"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/filehistory/{commit}/{path}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description Path to the file. */
				readonly path: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List commits that modified a file
		 * @description Returns a paginated list of commits that modified the specified file.
		 *
		 *     Commits are returned in reverse chronological order. This is roughly
		 *     equivalent to the following commands:
		 *
		 *         $ git log --follow --date-order <sha> <path>
		 *
		 *     By default, Bitbucket will follow renames and the path name in the
		 *     returned entries reflects that. This can be turned off using the
		 *     `?renames=false` query parameter.
		 *
		 *     Results are returned in descending chronological order by default, and
		 *     like most endpoints you can
		 *     [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to
		 *     only provide exactly the data you want.
		 *
		 *     The example response returns commits made before 2011-05-18 against a file
		 *     named `README.rst`. The results are filtered to only return the path and
		 *     date. This request can be made using:
		 *
		 *     ```
		 *     $ curl 'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst'\
		 *       '?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18'
		 *     ```
		 *
		 *     In the response you can see that the file was renamed to `README.rst`
		 *     by the commit made on 2011-05-16, and was previously named `README.txt`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     When `true`, Bitbucket will follow the history of the file across
					 *     renames (this is the default behavior). This can be turned off by
					 *     specifying `false`. */
					readonly renames?: string
					/** @description
					 *     Name of a response property sort the result by as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description Path to the file. */
					readonly path: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commits that modified the specified file */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_files"]
					}
				}
				/** @description If the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/forks": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List repository forks
		 * @description Returns a paginated list of all the forks of the specified
		 *     repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly q?: string
					/** @description Filters the result based on the authenticated user's role on each repository.
					 *
					 *     * **member**: returns repositories to which the user has explicit read access
					 *     * **contributor**: returns repositories to which the user has explicit write access
					 *     * **admin**: returns repositories to which the user has explicit administrator access
					 *     * **owner**: returns all repositories owned by the current user
					 *      */
					readonly role?: "admin" | "contributor" | "member" | "owner"
					/** @description Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description All forks. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repositories"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Fork a repository
		 * @description Creates a new fork of the specified repository.
		 *
		 *     #### Forking a repository
		 *
		 *     To create a fork, specify the workspace explicitly as part of the
		 *     request body:
		 *
		 *     ```
		 *     $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \
		 *       -H 'Content-Type: application/json' -d '{
		 *         "name": "bbql_fork",
		 *         "workspace": {
		 *           "slug": "atlassian"
		 *         }
		 *     }'
		 *     ```
		 *
		 *     To fork a repository into the same workspace, also specify a new `name`.
		 *
		 *     When you specify a value for `name`, it will also affect the `slug`.
		 *     The `slug` is reflected in the repository URL of the new fork. It is
		 *     derived from `name` by substituting non-ASCII characters, removes
		 *     whitespace, and changes characters to lower case. For example,
		 *     `My repo` would turn into `my_repo`.
		 *
		 *     You need contributor access to create new forks within a workspace.
		 *
		 *
		 *     #### Change the properties of a new fork
		 *
		 *     By default the fork inherits most of its properties from the parent.
		 *     However, since the optional POST body document follows the normal
		 *     `repository` JSON schema and you can override the new fork's
		 *     properties.
		 *
		 *     Properties that can be overridden include:
		 *
		 *     * description
		 *     * fork_policy
		 *     * language
		 *     * mainbranch
		 *     * is_private (note that a private repo's fork_policy might prohibit
		 *       the creation of public forks, in which `is_private=False` would fail)
		 *     * has_issues (to initialize or disable the new repo's issue tracker --
		 *       note that the actual contents of the parent repository's issue
		 *       tracker are not copied during forking)
		 *     * has_wiki (to initialize or disable the new repo's wiki --
		 *       note that the actual contents of the parent repository's wiki are not
		 *       copied during forking)
		 *     * project (when forking into a private project, the fork's `is_private`
		 *       must be `true`)
		 *
		 *     Properties that cannot be modified include:
		 *
		 *     * scm
		 *     * parent
		 *     * full_name
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description A repository object. This can be left blank. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["repository"]
				}
			}
			readonly responses: {
				/** @description The newly created fork. */
				readonly 201: {
					headers: {
						/** @description The URL of the newly created fork */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["repository"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/hooks": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List webhooks for a repository
		 * @description Returns a paginated list of webhooks installed on this repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The paginated list of installed webhooks. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_webhook_subscriptions"]
					}
				}
				/** @description If the authenticated user does not have permission to access the webhooks. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a webhook for a repository
		 * @description Creates a new webhook on the specified repository.
		 *
		 *     Example:
		 *
		 *     ```
		 *     $ curl -X POST -u credentials -H 'Content-Type: application/json'
		 *       https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks
		 *       -d '
		 *         {
		 *           "description": "Webhook Description",
		 *           "url": "https://example.com/",
		 *           "active": true,
		 *           "secret": "this is a really bad secret",
		 *           "events": [
		 *             "repo:push",
		 *             "issue:created",
		 *             "issue:updated"
		 *           ]
		 *         }'
		 *     ```
		 *
		 *     When the `secret` is provided it will be used as the key to generate a HMAC
		 *     digest value sent in the `X-Hub-Signature` header at delivery time. Passing
		 *     a `null` or empty `secret` or not passing a `secret` will leave the webhook's
		 *     secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook's
		 *     secret is set.
		 *
		 *     Note that this call requires the webhook scope, as well as any scope
		 *     that applies to the events that the webhook subscribes to. In the
		 *     example above that means: `webhook`, `repository` and `issue`.
		 *
		 *     Also note that the `url` must properly resolve and cannot be an
		 *     internal, non-routed address.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the webhook was registered successfully. */
				readonly 201: {
					headers: {
						/** @description The URL of new newly created webhook. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["webhook_subscription"]
					}
				}
				/** @description If the authenticated user does not have permission to install webhooks on the specified repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/hooks/{uid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description Installed webhook's ID */
				readonly uid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a webhook for a repository
		 * @description Returns the webhook with the specified id installed on the specified
		 *     repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description Installed webhook's ID */
					readonly uid: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The webhook subscription object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["webhook_subscription"]
					}
				}
				/** @description If the webhook or repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a webhook for a repository
		 * @description Updates the specified webhook subscription.
		 *
		 *     The following properties can be mutated:
		 *
		 *     * `description`
		 *     * `url`
		 *     * `secret`
		 *     * `active`
		 *     * `events`
		 *
		 *     The hook's secret is used as a key to generate the HMAC hex digest sent in the
		 *     `X-Hub-Signature` header at delivery time. This signature is only generated
		 *     when the hook has a secret.
		 *
		 *     Set the hook's secret by passing the new value in the `secret` field. Passing a
		 *     `null` value in the `secret` field will remove the secret from the hook. The
		 *     hook's secret can be left unchanged by not passing the `secret` field in the
		 *     request.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description Installed webhook's ID */
					readonly uid: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The webhook subscription object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["webhook_subscription"]
					}
				}
				/** @description If the authenticated user does not have permission to update the webhook. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the webhook or repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a webhook for a repository
		 * @description Deletes the specified webhook subscription from the given
		 *     repository.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description Installed webhook's ID */
					readonly uid: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description When the webhook was deleted successfully */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have permission to delete the webhook. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the webhook or repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List issues
		 * @description Returns the issues in the issue tracker.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of the issues matching any filter criteria that were provided. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_issues"]
					}
				}
				/** @description The specified repository does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create an issue
		 * @description Creates a new issue.
		 *
		 *     This call requires authentication. Private repositories or private
		 *     issue trackers require the caller to authenticate with an account that
		 *     has appropriate authorization.
		 *
		 *     The authenticated user is used for the issue's `reporter` field.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new issue. The only required element is `title`. All other elements can be omitted from the body. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["issue"]
				}
			}
			readonly responses: {
				/** @description The newly created issue. */
				readonly 201: {
					headers: {
						/** @description The (absolute) URL of the newly created issue. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["issue"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the authenticated user isn't authorized to create the issue. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get an issue
		 * @description Returns the specified issue.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The issue object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue"]
					}
				}
				/** @description When the authenticated user isn't authorized to access the issue. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified issue is unavailable. */
				readonly 410: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update an issue
		 * @description Modifies the issue.
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \
		 *       -u evzijst -s -X PUT -H 'Content-Type: application/json' \
		 *       -d '{
		 *       "title": "Updated title",
		 *       "assignee": {
		 *         "account_id": "5d5355e8c6b9320d9ea5b28d"
		 *       },
		 *       "priority": "minor",
		 *       "version": {
		 *         "name": "1.0"
		 *       },
		 *       "component": null
		 *     }'
		 *     ```
		 *
		 *     This example changes the `title`, `assignee`, `priority` and the
		 *     `version`. It also removes the value of the `component` from the issue
		 *     by setting the field to `null`. Any field not present keeps its existing
		 *     value.
		 *
		 *     Each time an issue is edited in the UI or through the API, an immutable
		 *     change record is created under the `/issues/123/changes` endpoint. It
		 *     also has a comment associated with the change.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The updated issue object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue"]
					}
				}
				/** @description When the authenticated user isn't authorized to access the issue. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete an issue
		 * @description Deletes the specified issue. This requires write access to the
		 *     repository.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates the issue was deleted successfully. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description When the authenticated user isn't authorized to delete the issue. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List attachments for an issue
		 * @description Returns all attachments for this issue.
		 *
		 *     This returns the files' meta data. This does not return the files'
		 *     actual contents.
		 *
		 *     The files are always ordered by their upload date.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of all attachments for this issue. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_issue_attachments"]
					}
				}
				/** @description If the issue tracker is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Upload an attachment to an issue
		 * @description Upload new issue attachments.
		 *
		 *     To upload files, perform a `multipart/form-data` POST containing one
		 *     or more file fields.
		 *
		 *     When a file is uploaded with the same name as an existing attachment,
		 *     then the existing file will be replaced.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description An empty response document. */
				readonly 201: {
					headers: {
						/** @description The URL to the issue's collection of attachments. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If no files were uploaded, or if the wrong `Content-Type` was used. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the issue tracker is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description Path to the file. */
				readonly path: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get attachment for an issue
		 * @description Returns the contents of the specified file attachment.
		 *
		 *     Note that this endpoint does not return a JSON response, but instead
		 *     returns a redirect pointing to the actual file that in turn will return
		 *     the raw contents.
		 *
		 *     The redirect URL contains a one-time token that has a limited lifetime.
		 *     As a result, the link should not be persisted, stored, or shared.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description Path to the file. */
					readonly path: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A redirect to the file's contents */
				readonly 302: {
					headers: {
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If the issue tracker is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete an attachment for an issue
		 * @description Deletes an attachment.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description Path to the file. */
					readonly path: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates that the deletion was successful */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the issue tracker is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List changes on an issue
		 * @description Returns the list of all changes that have been made to the specified
		 *     issue. Changes are returned in chronological order with the oldest
		 *     change first.
		 *
		 *     Each time an issue is edited in the UI or through the API, an immutable
		 *     change record is created under the `/issues/123/changes` endpoint. It
		 *     also has a comment associated with the change.
		 *
		 *     Note that this operation is changing significantly, due to privacy changes.
		 *     See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)
		 *     for details.
		 *
		 *     Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that
		 *     can be used to search for specific changes. For instance, to see
		 *     when an issue transitioned to "resolved":
		 *
		 *     ```
		 *     $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \
		 *        -G --data-urlencode='q=changes.state.new = "resolved"'
		 *     ```
		 *
		 *     This resource is only available on repositories that have the issue
		 *     tracker enabled.
		 *
		 *     N.B.
		 *
		 *     The `changes.assignee` and `changes.assignee_account_id` fields are not
		 *     a `user` object. Instead, they contain the raw `username` and
		 *     `account_id` of the user. This is to protect the integrity of the audit
		 *     log even after a user account gets deleted.
		 *
		 *     The `changes.assignee` field is deprecated will disappear in the
		 *     future. Use `changes.assignee_account_id` instead.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details. */
					readonly q?: string
					/** @description
					 *     Name of a response property to sort results. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results)
					 *     for details.
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Returns all the issue changes that were made on the specified issue. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_log_entries"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Modify the state of an issue
		 * @description Makes a change to the specified issue.
		 *
		 *     For example, to change an issue's state and assignee, create a new
		 *     change object that modifies these fields:
		 *
		 *     ```
		 *     curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \
		 *       -s -u evzijst -X POST -H "Content-Type: application/json" \
		 *       -d '{
		 *         "changes": {
		 *           "assignee_account_id": {
		 *             "new": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
		 *           },
		 *           "state": {
		 *             "new": 'resolved"
		 *           }
		 *         }
		 *         "message": {
		 *           "raw": "This is now resolved."
		 *         }
		 *       }'
		 *     ```
		 *
		 *     The above example also includes a custom comment to go alongside the
		 *     change. This comment will also be visible on the issue page in the UI.
		 *
		 *     The fields of the `changes` object are strings, not objects. This
		 *     allows for immutable change log records, even after user accounts,
		 *     milestones, or other objects recorded in a change entry, get renamed or
		 *     deleted.
		 *
		 *     The `assignee_account_id` field stores the account id. When POSTing a
		 *     new change and changing the assignee, the client should therefore use
		 *     the user's account_id in the `changes.assignee_account_id.new` field.
		 *
		 *     This call requires authentication. Private repositories or private
		 *     issue trackers require the caller to authenticate with an account that
		 *     has appropriate authorization.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new issue state change. The only required elements are `changes.[].new`. All other elements can be omitted from the body. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["issue_change"]
				}
			}
			readonly responses: {
				/** @description The newly created issue change. */
				readonly 201: {
					headers: {
						/** @description The (absolute) URL of the newly created issue change. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["issue_change"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the authenticated user isn't authorized to modify the issue. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue change id */
				readonly change_id: string
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get issue change object
		 * @description Returns the specified issue change object.
		 *
		 *     This resource is only available on repositories that have the issue
		 *     tracker enabled.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue change id */
					readonly change_id: string
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified issue change object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_change"]
					}
				}
				/** @description The specified repository or issue change does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List comments on an issue
		 * @description Returns a paginated list of all comments that were made on the
		 *     specified issue.
		 *
		 *     The default sorting is oldest to newest and can be overridden with
		 *     the `sort` query parameter.
		 *
		 *     This endpoint also supports filtering and sorting of the results. See
		 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of issue comments. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_issue_comments"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a comment on an issue
		 * @description Creates a new issue comment.
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \
		 *       -X POST -u evzijst \
		 *       -H 'Content-Type: application/json' \
		 *       -d '{"content": {"raw": "Lorem ipsum."}}'
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new issue comment object. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["issue_comment"]
				}
			}
			readonly responses: {
				/** @description The newly created comment. */
				readonly 201: {
					headers: {
						/** @description The location of the newly issue comment. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If the input was invalid, or if the comment being created is detected as spam  */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the comment. */
				readonly comment_id: number
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a comment on an issue
		 * @description Returns the specified issue comment object.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The issue comment. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_comment"]
					}
				}
			}
		}
		/**
		 * Update a comment on an issue
		 * @description Updates the content of the specified issue comment. Note that only
		 *     the `content.raw` field can be modified.
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \
		 *       -X PUT -u evzijst \
		 *       -H 'Content-Type: application/json' \
		 *       -d '{"content": {"raw": "Lorem ipsum."}'
		 *     ```
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The updated comment. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["issue_comment"]
				}
			}
			readonly responses: {
				/** @description The updated issue comment. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_comment"]
					}
				}
				/** @description If the input was invalid, or if the update to the comment is detected as spam  */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a comment on an issue
		 * @description Deletes the specified comment.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates successful deletion. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Check if current user voted for an issue
		 * @description Check whether the authenticated user has voted for this issue.
		 *     A 204 status code indicates that the user has voted, while a 404
		 *     implies they haven't.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the authenticated user has not voted for this issue. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user has not voted for this issue, or when the repo does not exist, or does not have an issue tracker. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Vote for an issue
		 * @description Vote for this issue.
		 *
		 *     To cast your vote, do an empty PUT. The 204 status code indicates that
		 *     the operation was successful.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicating the authenticated user has cast their vote successfully. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Remove vote for an issue
		 * @description Retract your vote.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Unexpected error. */
				readonly default: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The issue id */
				readonly issue_id: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Check if current user is watching a issue
		 * @description Indicated whether or not the authenticated user is watching this
		 *     issue.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the authenticated user is watching this issue. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user is not watching this issue, or when the repo does not exist, or does not have an issue tracker. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Watch an issue
		 * @description Start watching this issue.
		 *
		 *     To start watching this issue, do an empty PUT. The 204 status code
		 *     indicates that the operation was successful.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates that the authenticated user successfully started watching this issue. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user is not watching this issue, or when the repo does not exist, or does not have an issue tracker. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Stop watching an issue
		 * @description Stop watching this issue.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The issue id */
					readonly issue_id: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates that the authenticated user successfully stopped watching this issue. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or issue does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/export": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Export issues
		 * @description A POST request to this endpoint initiates a new background celery task that archives the repo's issues.
		 *
		 *     When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the
		 *     'Location' response header. This url is the endpoint for where the user can obtain their zip files."
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The options to apply to the export. Available options include `project_key` and `project_name` which, if specified, are used as the project key and name in the exported Jira json format. Option `send_email` specifies whether an email should be sent upon export result. Option `include_attachments` specifies whether attachments are included in the export. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["export_options"]
				}
			}
			readonly responses: {
				/** @description The export job has been accepted */
				readonly 202: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The request wasn't authenticated properly */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the authenticated user does not have admin permission on the repo */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The repo does not exist or does not have an issue tracker */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The name of the repo */
				readonly repo_name: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description The ID of the export task */
				readonly task_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Check issue export status
		 * @description This endpoint is used to poll for the progress of an issue export
		 *     job and return the zip file after the job is complete.
		 *     As long as the job is running, this will return a 202 response
		 *     with in the response body a description of the current status.
		 *
		 *     After the job has been scheduled, but before it starts executing, the endpoint
		 *     returns a 202 response with status `ACCEPTED`.
		 *
		 *     Once it starts running, it is a 202 response with status `STARTED` and progress filled.
		 *
		 *     After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The name of the repo */
					readonly repo_name: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description The ID of the export task */
					readonly task_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Export job accepted */
				readonly 202: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_job_status"]
					}
				}
				/** @description The request wasn't authenticated properly */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the authenticated user does not have admin permission on the repo */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description No export job has begun */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/issues/import": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Check issue import status
		 * @description When using GET, this endpoint reports the status of the current import task.
		 *
		 *     After the job has been scheduled, but before it starts executing, the endpoint
		 *     returns a 202 response with status `ACCEPTED`.
		 *
		 *     Once it starts running, it is a 202 response with status `STARTED` and progress filled.
		 *
		 *     After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Import job complete with either FAILURE or SUCCESS status */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_job_status"]
					}
				}
				/** @description Import job started */
				readonly 202: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_job_status"]
					}
				}
				/** @description The request wasn't authenticated properly */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the authenticated user does not have admin permission on the repo */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description No export job has begun */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Import issues
		 * @description A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All
		 *     existing issues will be deleted and replaced by the contents of the imported zip file.
		 *
		 *     Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name
		 *     "archive," which needs to be a file field:
		 *
		 *     ```
		 *     $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Import job accepted */
				readonly 202: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["issue_job_status"]
					}
				}
				/** @description The request wasn't authenticated properly */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description When the authenticated user does not have admin permission on the repo */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description No export job has begun */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description Import already running */
				readonly 409: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/merge-base/{revspec}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description A commit range using double dot notation (e.g. `3a8b42..9ff173`).
				 *      */
				readonly revspec: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the common ancestor between two commits
		 * @description Returns the best common ancestor between two commits, specified in a revspec
		 *     of 2 commits (e.g. 3a8b42..9ff173).
		 *
		 *     If more than one best common ancestor exists, only one will be returned. It is
		 *     unspecified which will be returned.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description A commit range using double dot notation (e.g. `3a8b42..9ff173`).
					 *      */
					readonly revspec: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The merge base of the provided spec. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["commit"]
					}
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have access to any of the repositories specified. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository or ref in the spec does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/milestones": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List milestones
		 * @description Returns the milestones that have been defined in the issue tracker.
		 *
		 *     This resource is only available on repositories that have the issue
		 *     tracker enabled.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The milestones that have been defined in the issue tracker. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_milestones"]
					}
				}
				/** @description The specified repository does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The milestone's id */
				readonly milestone_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a milestone
		 * @description Returns the specified issue tracker milestone object.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The milestone's id */
					readonly milestone_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified milestone object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["milestone"]
					}
				}
				/** @description The specified repository or milestone does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/override-settings": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** Retrieve the inheritance state for repository settings */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The repository setting inheritance state */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository_inheritance_state"]
					}
				}
				/** @description If no repository exists at this location */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/** Set the inheritance state for repository settings
		 *                      */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The repository setting inheritance state was set and no content returned */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If no repository exists at this location */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/patch/{spec}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description A commit SHA (e.g. `3a8b42`) or a commit range using double dot
				 *     notation (e.g. `3a8b42..9ff173`).
				 *      */
				readonly spec: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a patch for two commits
		 * @description Produces a raw patch for a single commit (diffed against its first
		 *     parent), or a patch-series for a revspec of 2 commits (e.g.
		 *     `3a8b42..9ff173` where the first commit represents the source and the
		 *     second commit the destination).
		 *
		 *     In case of the latter (diffing a revspec), a patch series is returned
		 *     for the commits on the source branch (`3a8b42` and its ancestors in
		 *     our example).
		 *
		 *     While similar to diffs, patches:
		 *
		 *     * Have a commit header (username, commit message, etc)
		 *     * Do not support the `path=foo/bar.py` query parameter
		 *
		 *     The raw patch is returned as-is, in whatever encoding the files in the
		 *     repository use. It is not decoded into unicode. As such, the
		 *     content-type is `text/plain`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description A commit SHA (e.g. `3a8b42`) or a commit range using double dot
					 *     notation (e.g. `3a8b42..9ff173`).
					 *      */
					readonly spec: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The raw patches */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the diff was too large and timed out.
				 *
				 *     Since this endpoint does not employ any form of pagination, but
				 *     instead returns the diff as a single document, it can run into
				 *     trouble on very large diffs. If Bitbucket times out in cases
				 *     like these, a 555 status code is returned. */
				readonly 555: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/permissions-config/groups": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List explicit group permissions for a repository
		 * @description Returns a paginated list of explicit group permissions for the given repository.
		 *     This endpoint does not support BBQL features.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Paginated of explicit group permissions on the repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repository_group_permissions"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or both of the workspace and repository doesn't exist for the given identifiers. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Slug of the requested group. */
				readonly group_slug: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get an explicit group permission for a repository
		 * @description Returns the group permission for a given group slug and repository
		 *
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 *     * `none`
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Slug of the requested group. */
					readonly group_slug: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Group permission for group slug and repository */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository_group_permission"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The given user, workspace, and/or repository could not be found */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update an explicit group permission for a repository
		 * @description Updates the group permission, or grants a new permission if one does not already exist.
		 *
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     The only authentication method supported for this endpoint is via app passwords.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Slug of the requested group. */
					readonly group_slug: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema"]
			readonly responses: {
				/** @description Group permission updated */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository_group_permission"]
					}
				}
				/** @description No permission value was provided or the value is invalid(not one of read, write, or admin) */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description You have reached your plan's user limit and must upgrade before giving access to additional users. */
				readonly 402: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The workspace does not exist, the repository does not exist, or the group does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete an explicit group permission for a repository
		 * @description Deletes the repository group permission between the requested repository and group, if one exists.
		 *
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     The only authentication method supported for this endpoint is via app passwords.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Slug of the requested group. */
					readonly group_slug: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Group permission deleted */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The workspace does not exist, the repository does not exist, or the group does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/permissions-config/users": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List explicit user permissions for a repository
		 * @description Returns a paginated list of explicit user permissions for the given repository.
		 *     This endpoint does not support BBQL features.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Paginated of explicit user permissions on the repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repository_user_permissions"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description No repository exists for the given repository slug and workspace. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the UUID of the account, surrounded by curly-braces, for
				 *     example: `{account UUID}`, OR an Atlassian Account ID.
				 *      */
				readonly selected_user_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get an explicit user permission for a repository
		 * @description Returns the explicit user permission for a given user and repository.
		 *
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 *     * `none`
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the UUID of the account, surrounded by curly-braces, for
					 *     example: `{account UUID}`, OR an Atlassian Account ID.
					 *      */
					readonly selected_user_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Explicit user permission for user and repository */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository_user_permission"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or both of the workspace and repository doesn't exist for the given identifiers. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update an explicit user permission for a repository
		 * @description Updates the explicit user permission for a given user and repository. The selected user must be a member of
		 *     the workspace, and cannot be the workspace owner.
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     The only authentication method for this endpoint is via app passwords.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the UUID of the account, surrounded by curly-braces, for
					 *     example: `{account UUID}`, OR an Atlassian Account ID.
					 *      */
					readonly selected_user_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema"]
			readonly responses: {
				/** @description Explicit user permission updated */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["repository_user_permission"]
					}
				}
				/** @description No permission value was provided or the value is invalid (not one of read, write, or admin), or the selected user is not a valid user to update. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description You have reached your plan's user limit and must upgrade before giving access to additional users. */
				readonly 402: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, repository, and selected user doesn't exist for the given identifiers. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete an explicit user permission for a repository
		 * @description Deletes the repository user permission between the requested repository and user, if one exists.
		 *
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     The only authentication method for this endpoint is via app passwords.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the UUID of the account, surrounded by curly-braces, for
					 *     example: `{account UUID}`, OR an Atlassian Account ID.
					 *      */
					readonly selected_user_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The repository user permission was deleted and no content returned. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the repository, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, repository, and user doesn't exist for the given identifiers. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List pipelines
		 * @description Find pipelines in a repository.
		 *
		 *     Note that unlike other endpoints in the Bitbucket API, this endpoint utilizes query parameters to allow filtering
		 *     and sorting of returned results. See [query parameters](#api-repositories-workspace-repo-slug-pipelines-get-request-Query%20parameters)
		 *     for specific details.
		 *
		 */
		readonly get: operations["getPipelinesForRepository"]
		readonly put?: never
		/**
		 * Run a pipeline
		 * @description Endpoint to create and initiate a pipeline.
		 *     There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
		 *     # Trigger a Pipeline for a branch
		 *     One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
		 *     The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.
		 *
		 *     ### Example
		 *
		 *     ```
		 *     $ curl -X POST -is -u username:password \
		 *       -H 'Content-Type: application/json' \
		 *      https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
		 *       -d '
		 *       {
		 *         "target": {
		 *           "ref_type": "branch",
		 *           "type": "pipeline_ref_target",
		 *           "ref_name": "master"
		 *         }
		 *       }'
		 *     ```
		 *     # Trigger a Pipeline for a commit on a branch or tag
		 *     You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
		 *     The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.
		 *
		 *     The following reference types are supported:
		 *
		 *     * `branch`
		 *     * `named_branch`
		 *     * `bookmark`
		 *      * `tag`
		 *
		 *     ### Example
		 *
		 *     ```
		 *     $ curl -X POST -is -u username:password \
		 *       -H 'Content-Type: application/json' \
		 *       https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
		 *       -d '
		 *       {
		 *         "target": {
		 *           "commit": {
		 *             "type": "commit",
		 *             "hash": "ce5b7431602f7cbba007062eeb55225c6e18e956"
		 *           },
		 *           "ref_type": "branch",
		 *           "type": "pipeline_ref_target",
		 *           "ref_name": "master"
		 *         }
		 *       }'
		 *     ```
		 *     # Trigger a specific pipeline definition for a commit
		 *     You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
		 *     In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.
		 *
		 *     ### Example
		 *
		 *     ```
		 *     $ curl -X POST -is -u username:password \
		 *       -H 'Content-Type: application/json' \
		 *      https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
		 *      -d '
		 *       {
		 *          "target": {
		 *           "commit": {
		 *              "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
		 *              "type":"commit"
		 *            },
		 *             "selector": {
		 *                "type":"custom",
		 *                   "pattern":"Deploy to production"
		 *               },
		 *             "type":"pipeline_commit_target"
		 *        }
		 *       }'
		 *     ```
		 *     # Trigger a specific pipeline definition for a commit on a branch or tag
		 *     You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
		 *     In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.
		 *
		 *     ### Example
		 *
		 *     ```
		 *     $ curl -X POST -is -u username:password \
		 *       -H 'Content-Type: application/json' \
		 *      https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
		 *      -d '
		 *       {
		 *          "target": {
		 *           "commit": {
		 *              "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
		 *              "type":"commit"
		 *            },
		 *            "selector": {
		 *               "type": "custom",
		 *               "pattern": "Deploy to production"
		 *            },
		 *            "type": "pipeline_ref_target",
		 *            "ref_name": "master",
		 *            "ref_type": "branch"
		 *          }
		 *       }'
		 *     ```
		 *
		 *
		 *     # Trigger a custom pipeline with variables
		 *     In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).
		 *
		 *     ### Example
		 *
		 *     ```
		 *     $ curl -X POST -is -u username:password \
		 *       -H 'Content-Type: application/json' \
		 *      https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
		 *      -d '
		 *       {
		 *         "target": {
		 *           "type": "pipeline_ref_target",
		 *           "ref_type": "branch",
		 *           "ref_name": "master",
		 *           "selector": {
		 *             "type": "custom",
		 *             "pattern": "Deploy to production"
		 *           }
		 *         },
		 *         "variables": [
		 *           {
		 *             "key": "var1key",
		 *             "value": "var1value",
		 *             "secured": true
		 *           },
		 *           {
		 *             "key": "var2key",
		 *             "value": "var2value"
		 *           }
		 *         ]
		 *       }'
		 *     ```
		 *
		 *     # Trigger a pull request pipeline
		 *
		 *     You can also initiate a pipeline for a specific pull request.
		 *
		 *     ### Example
		 *
		 *     ```
		 *     $ curl -X POST -is -u username:password \
		 *       -H 'Content-Type: application/json' \
		 *      https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
		 *      -d '
		 *       {
		 *         "target": {
		 *           "type": "pipeline_pullrequest_target",
		 *           "source": "pull-request-branch",
		 *           "destination": "master",
		 *           "destination_commit": {
		 *             "hash": "9f848b7"
		 *           },
		 *           "commit": {
		 *             "hash": "1a372fc"
		 *           },
		 *           "pullrequest": {
		 *             "id": "3"
		 *           },
		 *           "selector": {
		 *             "type": "pull-requests",
		 *             "pattern": "**"
		 *           }
		 *         }
		 *       }'
		 *     ```
		 *
		 */
		readonly post: operations["createPipelineForRepository"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get configuration
		 * @description Retrieve the repository pipelines configuration.
		 */
		readonly get: operations["getRepositoryPipelineConfig"]
		/**
		 * Update configuration
		 * @description Update the pipelines configuration for a repository.
		 */
		readonly put: operations["updateRepositoryPipelineConfig"]
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/build_number": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		readonly get?: never
		/**
		 * Update the next build number
		 * @description Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
		 */
		readonly put: operations["updateRepositoryBuildNumber"]
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List schedules
		 * @description Retrieve the configured schedules for the given repository.
		 */
		readonly get: operations["getRepositoryPipelineSchedules"]
		readonly put?: never
		/**
		 * Create a schedule
		 * @description Create a schedule for the given repository.
		 */
		readonly post: operations["createRepositoryPipelineSchedule"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a schedule
		 * @description Retrieve a schedule by its UUID.
		 */
		readonly get: operations["getRepositoryPipelineSchedule"]
		/**
		 * Update a schedule
		 * @description Update a schedule.
		 */
		readonly put: operations["updateRepositoryPipelineSchedule"]
		readonly post?: never
		/**
		 * Delete a schedule
		 * @description Delete a schedule.
		 */
		readonly delete: operations["deleteRepositoryPipelineSchedule"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List executions of a schedule
		 * @description Retrieve the executions of a given schedule.
		 */
		readonly get: operations["getRepositoryPipelineScheduleExecutions"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get SSH key pair
		 * @description Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
		 */
		readonly get: operations["getRepositoryPipelineSshKeyPair"]
		/**
		 * Update SSH key pair
		 * @description Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
		 */
		readonly put: operations["updateRepositoryPipelineKeyPair"]
		readonly post?: never
		/**
		 * Delete SSH key pair
		 * @description Delete the repository SSH key pair.
		 */
		readonly delete: operations["deleteRepositoryPipelineKeyPair"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List known hosts
		 * @description Find repository level known hosts.
		 */
		readonly get: operations["getRepositoryPipelineKnownHosts"]
		readonly put?: never
		/**
		 * Create a known host
		 * @description Create a repository level known host.
		 */
		readonly post: operations["createRepositoryPipelineKnownHost"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a known host
		 * @description Retrieve a repository level known host.
		 */
		readonly get: operations["getRepositoryPipelineKnownHost"]
		/**
		 * Update a known host
		 * @description Update a repository level known host.
		 */
		readonly put: operations["updateRepositoryPipelineKnownHost"]
		readonly post?: never
		/**
		 * Delete a known host
		 * @description Delete a repository level known host.
		 */
		readonly delete: operations["deleteRepositoryPipelineKnownHost"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/variables": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List variables for a repository
		 * @description Find repository level variables.
		 */
		readonly get: operations["getRepositoryPipelineVariables"]
		readonly put?: never
		/**
		 * Create a variable for a repository
		 * @description Create a repository level variable.
		 */
		readonly post: operations["createRepositoryPipelineVariable"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a variable for a repository
		 * @description Retrieve a repository level variable.
		 */
		readonly get: operations["getRepositoryPipelineVariable"]
		/**
		 * Update a variable for a repository
		 * @description Update a repository level variable.
		 */
		readonly put: operations["updateRepositoryPipelineVariable"]
		readonly post?: never
		/**
		 * Delete a variable for a repository
		 * @description Delete a repository level variable.
		 */
		readonly delete: operations["deleteRepositoryPipelineVariable"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines-config/caches": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List caches
		 * @description Retrieve the repository pipelines caches.
		 */
		readonly get: operations["getRepositoryPipelineCaches"]
		readonly put?: never
		readonly post?: never
		/**
		 * Delete caches
		 * @description Delete repository cache versions by name.
		 */
		readonly delete: operations["deleteRepositoryPipelineCaches"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a cache
		 * @description Delete a repository cache.
		 */
		readonly delete: operations["deleteRepositoryPipelineCache"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get cache content URI
		 * @description Retrieve the URI of the content of the specified cache.
		 */
		readonly get: operations["getRepositoryPipelineCacheContentURI"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a pipeline
		 * @description Retrieve a specified pipeline
		 */
		readonly get: operations["getPipelineForRepository"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List steps for a pipeline
		 * @description Find steps for the given pipeline.
		 */
		readonly get: operations["getPipelineStepsForRepository"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a step of a pipeline
		 * @description Retrieve a given step of a pipeline.
		 */
		readonly get: operations["getPipelineStepForRepository"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get log file for a step
		 * @description Retrieve the log file for a given step of a pipeline.
		 *
		 *     This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
		 */
		readonly get: operations["getPipelineStepLogForRepository"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get the logs for the build container or a service container for a given step of a pipeline.
		 * @description Retrieve the log file for a build container or service container.
		 *
		 *     This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
		 */
		readonly get: operations["getPipelineContainerLog"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/** Get a summary of test reports for a given step of a pipeline. */
		readonly get: operations["getPipelineTestReports"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/** Get test cases for a given step of a pipeline. */
		readonly get: operations["getPipelineTestReportTestCases"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/** Get test case reasons (output) for a given test case in a step of a pipeline. */
		readonly get: operations["getPipelineTestReportTestCaseReasons"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Stop a pipeline
		 * @description Signal the stop of a pipeline and all of its steps that not have completed yet.
		 */
		readonly post: operations["stopPipeline"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/properties/{app_key}/{property_name}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a repository application property
		 * @description Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
		 */
		readonly get: operations["getRepositoryHostedPropertyValue"]
		/**
		 * Update a repository application property
		 * @description Update an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
		 */
		readonly put: operations["updateRepositoryHostedPropertyValue"]
		readonly post?: never
		/**
		 * Delete a repository application property
		 * @description Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a repository.
		 */
		readonly delete: operations["deleteRepositoryHostedPropertyValue"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List pull requests
		 * @description Returns all pull requests on the specified repository.
		 *
		 *     By default only open pull requests are returned. This can be controlled
		 *     using the `state` query parameter. To retrieve pull requests that are
		 *     in one of multiple states, repeat the `state` parameter for each
		 *     individual state.
		 *
		 *     This endpoint also supports filtering and sorting of the results. See
		 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Only return pull requests that are in this state. This parameter can be repeated. */
					readonly state?: "DECLINED" | "MERGED" | "OPEN" | "SUPERSEDED"
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description All pull requests on the specified repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_pullrequests"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a pull request
		 * @description Creates a new pull request where the destination repository is
		 *     this repository and the author is the authenticated user.
		 *
		 *     The minimum required fields to create a pull request are `title` and
		 *     `source`, specified by a branch name.
		 *
		 *     ```
		 *     curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \
		 *         -u my-username:my-password \
		 *         --request POST \
		 *         --header 'Content-Type: application/json' \
		 *         --data '{
		 *             "title": "My Title",
		 *             "source": {
		 *                 "branch": {
		 *                     "name": "staging"
		 *                 }
		 *             }
		 *         }'
		 *     ```
		 *
		 *     If the pull request's `destination` is not specified, it will default
		 *     to the `repository.mainbranch`. To open a pull request to a
		 *     different branch, say from a feature branch to a staging branch,
		 *     specify a `destination` (same format as the `source`):
		 *
		 *     ```
		 *     {
		 *         "title": "My Title",
		 *         "source": {
		 *             "branch": {
		 *                 "name": "my-feature-branch"
		 *             }
		 *         },
		 *         "destination": {
		 *             "branch": {
		 *                 "name": "staging"
		 *             }
		 *         }
		 *     }
		 *     ```
		 *
		 *     Reviewers can be specified by adding an array of user objects as the
		 *     `reviewers` property.
		 *
		 *     ```
		 *     {
		 *         "title": "My Title",
		 *         "source": {
		 *             "branch": {
		 *                 "name": "my-feature-branch"
		 *             }
		 *         },
		 *         "reviewers": [
		 *             {
		 *                 "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
		 *             }
		 *         ]
		 *     }
		 *     ```
		 *
		 *     Other fields:
		 *
		 *     * `description` - a string
		 *     * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The new pull request.
			 *
			 *     The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).
			 *
			 *     Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest"]
				}
			}
			readonly responses: {
				/** @description The newly created pull request. */
				readonly 201: {
					headers: {
						/** @description The URL of new newly created pull request. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["pullrequest"]
					}
				}
				/** @description If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a pull request
		 * @description Returns the specified pull request.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The pull request object */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository or pull request does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a pull request
		 * @description Mutates the specified pull request.
		 *
		 *     This can be used to change the pull request's branches or description.
		 *
		 *     Only open pull requests can be mutated.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The pull request that is to be updated. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest"]
				}
			}
			readonly responses: {
				/** @description The updated pull request */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest"]
					}
				}
				/** @description If the input document was invalid. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository or pull request id does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/activity": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List a pull request activity log
		 * @description Returns a paginated list of the pull request's activity log.
		 *
		 *     This handler serves both a v20 and internal endpoint. The v20 endpoint
		 *     returns reviewer comments, updates, approvals and request changes. The internal
		 *     endpoint includes those plus tasks and attachments.
		 *
		 *     Comments created on a file or a line of code have an inline property.
		 *
		 *     Comment example:
		 *     ```
		 *     {
		 *         "pagelen": 20,
		 *         "values": [
		 *             {
		 *                 "comment": {
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
		 *                         }
		 *                     },
		 *                     "deleted": false,
		 *                     "pullrequest": {
		 *                         "type": "pullrequest",
		 *                         "id": 5695,
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                             }
		 *                         },
		 *                         "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                     },
		 *                     "content": {
		 *                         "raw": "inline with to a dn from lines",
		 *                         "markup": "markdown",
		 *                         "html": "<p>inline with to a dn from lines</p>",
		 *                         "type": "rendered"
		 *                     },
		 *                     "created_on": "2019-09-27T00:33:46.039178+00:00",
		 *                     "user": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     },
		 *                     "created_on": "2019-09-27T00:33:46.039178+00:00",
		 *                     "user": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     },
		 *                     "updated_on": "2019-09-27T00:33:46.055384+00:00",
		 *                     "inline": {
		 *                         "context_lines": "",
		 *                         "to": null,
		 *                         "path": "",
		 *                         "outdated": false,
		 *                         "from": 211
		 *                     },
		 *                     "type": "pullrequest_comment",
		 *                     "id": 118571088
		 *                 },
		 *                 "pull_request": {
		 *                     "type": "pullrequest",
		 *                     "id": 5695,
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                         }
		 *                     },
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                 }
		 *             }
		 *         ]
		 *     }
		 *     ```
		 *
		 *     Updates include a state property of OPEN, MERGED, or DECLINED.
		 *
		 *     Update example:
		 *     ```
		 *     {
		 *         "pagelen": 20,
		 *         "values": [
		 *             {
		 *                 "update": {
		 *                     "description": "",
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
		 *                     "destination": {
		 *                         "commit": {
		 *                             "type": "commit",
		 *                             "hash": "6a2c16e4a152",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
		 *                                 }
		 *                             }
		 *                         },
		 *                         "branch": {
		 *                             "name": "master"
		 *                         },
		 *                         "repository": {
		 *                             "name": "Atlaskit-MK-2",
		 *                             "type": "repository",
		 *                             "full_name": "atlassian/atlaskit-mk-2",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "avatar": {
		 *                                     "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
		 *                                 }
		 *                             },
		 *                             "uuid": "{}"
		 *                         }
		 *                     },
		 *                     "reason": "",
		 *                     "source": {
		 *                         "commit": {
		 *                             "type": "commit",
		 *                             "hash": "728c8bad1813",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
		 *                                 }
		 *                             }
		 *                         },
		 *                         "branch": {
		 *                             "name": "username/NONE-add-onClick-prop-for-accessibility"
		 *                         },
		 *                         "repository": {
		 *                             "name": "Atlaskit-MK-2",
		 *                             "type": "repository",
		 *                             "full_name": "atlassian/atlaskit-mk-2",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "avatar": {
		 *                                     "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
		 *                                 }
		 *                             },
		 *                             "uuid": "{}"
		 *                         }
		 *                     },
		 *                     "state": "OPEN",
		 *                     "author": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     },
		 *                     "date": "2019-05-10T06:48:25.305565+00:00"
		 *                 },
		 *                 "pull_request": {
		 *                     "type": "pullrequest",
		 *                     "id": 5695,
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                         }
		 *                     },
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                 }
		 *             }
		 *         ]
		 *     }
		 *     ```
		 *
		 *     Approval example:
		 *     ```
		 *     {
		 *         "pagelen": 20,
		 *         "values": [
		 *             {
		 *                 "approval": {
		 *                     "date": "2019-09-27T00:37:19.849534+00:00",
		 *                     "pullrequest": {
		 *                         "type": "pullrequest",
		 *                         "id": 5695,
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                             }
		 *                         },
		 *                         "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                     },
		 *                     "user": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     }
		 *                 },
		 *                 "pull_request": {
		 *                     "type": "pullrequest",
		 *                     "id": 5695,
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                         }
		 *                     },
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                 }
		 *             }
		 *         ]
		 *     }
		 *     ```
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The pull request activity log */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Approve a pull request
		 * @description Approve the specified pull request as the authenticated user.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The `participant` object recording that the authenticated user approved the pull request. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["participant"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified pull request or the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Unapprove a pull request
		 * @description Redact the authenticated user's approval of the specified pull
		 *     request.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description An empty response indicating the authenticated user's approval has been withdrawn. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Pull request cannot be unapproved because the pull request has already been merged. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified pull request or the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List comments on a pull request
		 * @description Returns a paginated list of the pull request's comments.
		 *
		 *     This includes both global, inline comments and replies.
		 *
		 *     The default sorting is oldest to newest and can be overridden with
		 *     the `sort` query parameter.
		 *
		 *     This endpoint also supports filtering and sorting of the results. See
		 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more
		 *     details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of comments made on the given pull request, in chronological order. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_pullrequest_comments"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the pull request does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a comment on a pull request
		 * @description Creates a new pull request comment.
		 *
		 *     Returns the newly created pull request comment.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The comment object. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest_comment"]
				}
			}
			readonly responses: {
				/** @description The newly created comment. */
				readonly 201: {
					headers: {
						/** @description The URL of the new comment */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["pullrequest_comment"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the pull request does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the comment. */
				readonly comment_id: number
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a comment on a pull request
		 * @description Returns a specific pull request comment.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The comment. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest_comment"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a comment on a pull request
		 * @description Updates a specific pull request comment.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The contents of the updated comment. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest_comment"]
				}
			}
			readonly responses: {
				/** @description The updated comment. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest_comment"]
					}
				}
				/** @description If the authenticated user does not have access to the comment. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a comment on a pull request
		 * @description Deletes a specific pull request comment.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful deletion. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access to delete the comment. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the comment. */
				readonly comment_id: number
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/** Resolve a comment thread */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The comment resolution details. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["comment_resolution"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request,
				 *     if the provided comment is not a top-level comment,
				 *     or if the comment is not on the diff. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment has already been resolved. */
				readonly 409: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/** Reopen a comment thread */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The comment is reopened. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access to the pull request,
				 *     or if the provided comment is not a top-level comment. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment does not exist, or if the comment has not been resolved */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/commits": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List commits on a pull request
		 * @description Returns a paginated list of the pull request's commits.
		 *
		 *     These are the commits that are being merged into the destination
		 *     branch when the pull requests gets accepted.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of commits made on the given pull request, in chronological order. This list will be empty if the source branch no longer exists. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the pull request does not exist or the source branch is from a forked repository which no longer exists. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/decline": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Decline a pull request
		 * @description Declines the pull request.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The pull request was successfully declined. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest"]
					}
				}
				/** @description If the decline took too long and timed out.
				 *     In this case the caller should retry the request later. */
				readonly 555: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diff": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List changes in a pull request
		 * @description Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get)
		 *     with the revspec that corresponds to the pull request.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get) with the
				 *     revspec that corresponds to the pull request.
				 *      */
				readonly 302: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diffstat": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the diff stat for a pull request
		 * @description Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get)
		 *     with the revspec that corresponds to the pull request.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get) with
				 *     the revspec that corresponds to pull request.
				 *      */
				readonly 302: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/**
		 * Merge a pull request
		 * @description Merges the pull request.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: {
					/** @description Default value is false.
					 *
					 *
					 *     When set to true, runs merge asynchronously and
					 *     immediately returns a 202 with polling link to
					 *     the task-status API in the Location header.
					 *
					 *
					 *     When set to false, runs merge and waits for it to
					 *     complete, returning 200 when it succeeds. If the
					 *     duration of the merge exceeds a timeout threshold,
					 *     the API returns a 202 with polling link to the
					 *     task-status API in the Location header. */
					readonly async?: boolean
				}
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest_merge_parameters"]
				}
			}
			readonly responses: {
				/** @description The pull request object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest"]
					}
				}
				/** @description In the Location header, the URL to poll for the pull request merge status */
				readonly 202: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Unable to merge because one of the refs involved changed while attempting to merge */
				readonly 409: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the merge took too long and timed out.
				 *     In this case the caller should retry the request later */
				readonly 555: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge/task-status/{task_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description ID of the merge task */
				readonly task_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the merge task status for a pull request
		 * @description When merging a pull request takes too long, the client receives a
		 *     task ID along with a 202 status code. The task ID can be used in a call
		 *     to this endpoint to check the status of a merge task.
		 *
		 *     ```
		 *     curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>
		 *     ```
		 *
		 *     If the merge task is not yet finished, a PENDING status will be returned.
		 *
		 *     ```
		 *     HTTP/2 200
		 *     {
		 *         "task_status": "PENDING",
		 *         "links": {
		 *             "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
		 *             }
		 *         }
		 *     }
		 *     ```
		 *
		 *     If the merge was successful, a SUCCESS status will be returned.
		 *
		 *     ```
		 *     HTTP/2 200
		 *     {
		 *         "task_status": "SUCCESS",
		 *         "links": {
		 *             "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
		 *             }
		 *         },
		 *         "merge_result": <the merged pull request object>
		 *     }
		 *     ```
		 *
		 *     If the merge task failed, an error will be returned.
		 *
		 *     ```
		 *     {
		 *         "type": "error",
		 *         "error": {
		 *             "message": "<error message>"
		 *         }
		 *     }
		 *     ```
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description ID of the merge task */
					readonly task_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Returns a task status if the merge is either pending or successful, and if it is successful, a pull request */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the provided task ID does not relate to this pull request, or if something went wrong during the merge operation */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The user making the request does not have permission to the repo and is different from the user who queued the task */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Unable to merge because one of the refs involved changed while attempting to merge */
				readonly 409: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/patch": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the patch for a pull request
		 * @description Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get)
		 *     with the revspec that corresponds to pull request.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get) with
				 *     the revspec that corresponds to pull request.
				 *      */
				readonly 302: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly get?: never
		readonly put?: never
		/** Request changes for a pull request */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The `participant` object recording that the authenticated user requested changes on the pull request. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["participant"]
					}
				}
				/** @description Pull request changes cannot be requested because the pull request has already been merged. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified pull request or the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/** Remove change request for a pull request */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description An empty response indicating the authenticated user's request for change has been withdrawn. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description Pull request requested changes cannot be removed because the pull request has already been merged. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified pull request or the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List commit statuses for a pull request
		 * @description Returns all statuses (e.g. build results) for the given pull
		 *     request.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *      */
					readonly q?: string
					/** @description Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *     Defaults to `created_on`.
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of all commit statuses for this pull request. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_commitstatuses"]
					}
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified repository or pull request does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List tasks on a pull request
		 * @description Returns a paginated list of the pull request's tasks.
		 *
		 *     This endpoint supports filtering and sorting of the results by the 'task' field.
		 *     See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Current number of objects on the existing page.
					 *     The default value is 10 with 100 being the maximum allowed value.
					 *     Individual APIs may enforce different values.
					 *      */
					readonly pagelen?: number
					/** @description
					 *     Query string to narrow down the response. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details. */
					readonly q?: string
					/** @description
					 *     Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).
					 *     Defaults to `created_on`.
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of pull request tasks for the given pull request. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_tasks"]
					}
				}
				/** @description If the user provides an invalid filter, sort, or fields query parameter. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the pull request does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a task on a pull request
		 * @description Creates a new pull request task.
		 *
		 *     Returns the newly created pull request task.
		 *
		 *     Tasks can optionally be created in relation to a comment specified by the comment's ID which
		 *     will cause the task to appear below the comment on a pull request when viewed in Bitbucket.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The contents of the task */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest_task_create"]
				}
			}
			readonly responses: {
				/** @description The newly created task. */
				readonly 201: {
					headers: {
						/** @description The URL of the new task */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["pullrequest_comment_task"]
					}
				}
				/** @description There is a missing required field in the request or the task content is blank. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the pull request does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the pull request. */
				readonly pull_request_id: number
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description The ID of the task. */
				readonly task_id: number
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a task on a pull request
		 * @description Returns a specific pull request task.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description The ID of the task. */
					readonly task_id: number
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The task. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest_comment_task"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the task does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a task on a pull request
		 * @description Updates a specific pull request task.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description The ID of the task. */
					readonly task_id: number
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The updated state and content of the task. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["pullrequest_task_update"]
				}
			}
			readonly responses: {
				/** @description The updated task. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["pullrequest_comment_task"]
					}
				}
				/** @description There is a missing required field in the request or the task content is blank. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have access to the pull request. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the task does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a task on a pull request
		 * @description Deletes a specific pull request task.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the pull request. */
					readonly pull_request_id: number
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description The ID of the task. */
					readonly task_id: number
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful deletion. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access to delete the task. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the task does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/{pullrequest_id}/properties/{app_key}/{property_name}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a pull request application property
		 * @description Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
		 */
		readonly get: operations["getPullRequestHostedPropertyValue"]
		/**
		 * Update a pull request application property
		 * @description Update an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
		 */
		readonly put: operations["updatePullRequestHostedPropertyValue"]
		readonly post?: never
		/**
		 * Delete a pull request application property
		 * @description Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a pull request.
		 */
		readonly delete: operations["deletePullRequestHostedPropertyValue"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/pullrequests/activity": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List a pull request activity log
		 * @description Returns a paginated list of the pull request's activity log.
		 *
		 *     This handler serves both a v20 and internal endpoint. The v20 endpoint
		 *     returns reviewer comments, updates, approvals and request changes. The internal
		 *     endpoint includes those plus tasks and attachments.
		 *
		 *     Comments created on a file or a line of code have an inline property.
		 *
		 *     Comment example:
		 *     ```
		 *     {
		 *         "pagelen": 20,
		 *         "values": [
		 *             {
		 *                 "comment": {
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
		 *                         }
		 *                     },
		 *                     "deleted": false,
		 *                     "pullrequest": {
		 *                         "type": "pullrequest",
		 *                         "id": 5695,
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                             }
		 *                         },
		 *                         "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                     },
		 *                     "content": {
		 *                         "raw": "inline with to a dn from lines",
		 *                         "markup": "markdown",
		 *                         "html": "<p>inline with to a dn from lines</p>",
		 *                         "type": "rendered"
		 *                     },
		 *                     "created_on": "2019-09-27T00:33:46.039178+00:00",
		 *                     "user": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     },
		 *                     "created_on": "2019-09-27T00:33:46.039178+00:00",
		 *                     "user": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     },
		 *                     "updated_on": "2019-09-27T00:33:46.055384+00:00",
		 *                     "inline": {
		 *                         "context_lines": "",
		 *                         "to": null,
		 *                         "path": "",
		 *                         "outdated": false,
		 *                         "from": 211
		 *                     },
		 *                     "type": "pullrequest_comment",
		 *                     "id": 118571088
		 *                 },
		 *                 "pull_request": {
		 *                     "type": "pullrequest",
		 *                     "id": 5695,
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                         }
		 *                     },
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                 }
		 *             }
		 *         ]
		 *     }
		 *     ```
		 *
		 *     Updates include a state property of OPEN, MERGED, or DECLINED.
		 *
		 *     Update example:
		 *     ```
		 *     {
		 *         "pagelen": 20,
		 *         "values": [
		 *             {
		 *                 "update": {
		 *                     "description": "",
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
		 *                     "destination": {
		 *                         "commit": {
		 *                             "type": "commit",
		 *                             "hash": "6a2c16e4a152",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
		 *                                 }
		 *                             }
		 *                         },
		 *                         "branch": {
		 *                             "name": "master"
		 *                         },
		 *                         "repository": {
		 *                             "name": "Atlaskit-MK-2",
		 *                             "type": "repository",
		 *                             "full_name": "atlassian/atlaskit-mk-2",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "avatar": {
		 *                                     "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
		 *                                 }
		 *                             },
		 *                             "uuid": "{}"
		 *                         }
		 *                     },
		 *                     "reason": "",
		 *                     "source": {
		 *                         "commit": {
		 *                             "type": "commit",
		 *                             "hash": "728c8bad1813",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
		 *                                 }
		 *                             }
		 *                         },
		 *                         "branch": {
		 *                             "name": "username/NONE-add-onClick-prop-for-accessibility"
		 *                         },
		 *                         "repository": {
		 *                             "name": "Atlaskit-MK-2",
		 *                             "type": "repository",
		 *                             "full_name": "atlassian/atlaskit-mk-2",
		 *                             "links": {
		 *                                 "self": {
		 *                                     "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "html": {
		 *                                     "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
		 *                                 },
		 *                                 "avatar": {
		 *                                     "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
		 *                                 }
		 *                             },
		 *                             "uuid": "{}"
		 *                         }
		 *                     },
		 *                     "state": "OPEN",
		 *                     "author": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     },
		 *                     "date": "2019-05-10T06:48:25.305565+00:00"
		 *                 },
		 *                 "pull_request": {
		 *                     "type": "pullrequest",
		 *                     "id": 5695,
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                         }
		 *                     },
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                 }
		 *             }
		 *         ]
		 *     }
		 *     ```
		 *
		 *     Approval example:
		 *     ```
		 *     {
		 *         "pagelen": 20,
		 *         "values": [
		 *             {
		 *                 "approval": {
		 *                     "date": "2019-09-27T00:37:19.849534+00:00",
		 *                     "pullrequest": {
		 *                         "type": "pullrequest",
		 *                         "id": 5695,
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                             }
		 *                         },
		 *                         "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                     },
		 *                     "user": {
		 *                         "display_name": "Name Lastname",
		 *                         "uuid": "{}",
		 *                         "links": {
		 *                             "self": {
		 *                                 "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
		 *                             },
		 *                             "html": {
		 *                                 "href": "https://bitbucket.org/%7B%7D/"
		 *                             },
		 *                             "avatar": {
		 *                                 "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
		 *                             }
		 *                         },
		 *                         "type": "user",
		 *                         "nickname": "Name",
		 *                         "account_id": ""
		 *                     }
		 *                 },
		 *                 "pull_request": {
		 *                     "type": "pullrequest",
		 *                     "id": 5695,
		 *                     "links": {
		 *                         "self": {
		 *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
		 *                         },
		 *                         "html": {
		 *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
		 *                         }
		 *                     },
		 *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
		 *                 }
		 *             }
		 *         ]
		 *     }
		 *     ```
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The pull request activity log */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/refs": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List branches and tags
		 * @description Returns the branches and tags in the repository.
		 *
		 *     By default, results will be in the order the underlying source control system returns them and identical to
		 *     the ordering one sees when running "$ git show-ref". Note that this follows simple
		 *     lexical ordering of the ref names.
		 *
		 *     This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are
		 *     sorted ["branch1", "branch10", "branch2", "v10", "v11", "v9"] instead of ["branch1", "branch2",
		 *     "branch10", "v9", "v10", "v11"].
		 *
		 *     Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
		 *     Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The `name`
					 *     field is handled specially for refs in that, if specified as the sort field, it
					 *     uses a natural sort order instead of the default lexicographical sort order. For example,
					 *     it will return ['1.1', '1.2', '1.10'] instead of ['1.1', '1.10', '1.2']. */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of refs matching any filter criteria that were provided. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_refs"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/refs/branches": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List open branches
		 * @description Returns a list of all open branches within the specified repository.
		 *     Results will be in the order the source control manager returns them.
		 *
		 *     Branches support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering)
		 *     that can be used to search for specific branches. For instance, to find
		 *     all branches that have "stab" in their name:
		 *
		 *     ```
		 *     curl -s https://api.bitbucket.org/2.0/repositories/atlassian/aui/refs/branches -G --data-urlencode 'q=name ~ "stab"'
		 *     ```
		 *
		 *     By default, results will be in the order the underlying source control system returns them and identical to
		 *     the ordering one sees when running "$ git branch --list". Note that this follows simple
		 *     lexical ordering of the ref names.
		 *
		 *     This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
		 *     sorted ["v10", "v11", "v9"] instead of ["v9", "v10", "v11"].
		 *
		 *     Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name,
		 *     Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The `name`
					 *     field is handled specially for branches in that, if specified as the sort field, it
					 *     uses a natural sort order instead of the default lexicographical sort order. For example,
					 *     it will return ['branch1', 'branch2', 'branch10'] instead of ['branch1', 'branch10', 'branch2']. */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of branches matching any filter criteria that were provided. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_branches"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a branch
		 * @description Creates a new branch in the specified repository.
		 *
		 *     The payload of the POST should consist of a JSON document that
		 *     contains the name of the tag and the target hash.
		 *
		 *     ```
		 *     curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \
		 *     -s -u seanfarley -X POST -H "Content-Type: application/json" \
		 *     -d '{
		 *         "name" : "smf/create-feature",
		 *         "target" : {
		 *             "hash" : "default",
		 *         }
		 *     }'
		 *     ```
		 *
		 *     This call requires authentication. Private repositories require the
		 *     caller to authenticate with an account that has appropriate
		 *     authorization.
		 *
		 *     The branch name should not include any prefixes (e.g.
		 *     refs/heads). This endpoint does support using short hash prefixes for
		 *     the commit hash, but it may return a 400 response if the provided
		 *     prefix is ambiguous. Using a full commit hash is the preferred
		 *     approach.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The newly created branch object. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branch"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or branch does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/refs/branches/{name}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The name of the branch. */
				readonly name: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a branch
		 * @description Returns a branch object within the specified repository.
		 *
		 *     This call requires authentication. Private repositories require the
		 *     caller to authenticate with an account that has appropriate
		 *     authorization.
		 *
		 *     For Git, the branch name should not include any prefixes (e.g.
		 *     refs/heads).
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The name of the branch. */
					readonly name: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The branch object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branch"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or branch does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a branch
		 * @description Delete a branch in the specified repository.
		 *
		 *     The main branch is not allowed to be deleted and will return a 400
		 *     response.
		 *
		 *     The branch name should not include any prefixes (e.g.
		 *     refs/heads).
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The name of the branch. */
					readonly name: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates that the specified branch was successfully deleted. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or branch does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/refs/tags": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List tags
		 * @description Returns the tags in the repository.
		 *
		 *     By default, results will be in the order the underlying source control system returns them and identical to
		 *     the ordering one sees when running "$ git tag --list". Note that this follows simple
		 *     lexical ordering of the ref names.
		 *
		 *     This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
		 *     sorted ["v10", "v11", "v9"] instead of ["v9", "v10", "v11"].
		 *
		 *     Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
		 *     Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     Field by which the results should be sorted as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). The `name`
					 *     field is handled specially for tags in that, if specified as the sort field, it
					 *     uses a natural sort order instead of the default lexicographical sort order. For example,
					 *     it will return ['1.1', '1.2', '1.10'] instead of ['1.1', '1.10', '1.2']. */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of tags matching any filter criteria that were provided. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_tags"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a tag
		 * @description Creates a new tag in the specified repository.
		 *
		 *     The payload of the POST should consist of a JSON document that
		 *     contains the name of the tag and the target hash.
		 *
		 *     ```
		 *     curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \
		 *     -s -u jdoe -X POST -H "Content-Type: application/json" \
		 *     -d '{
		 *         "name" : "new-tag-name",
		 *         "target" : {
		 *             "hash" : "a1b2c3d4e5f6",
		 *         }
		 *     }'
		 *     ```
		 *
		 *     This endpoint does support using short hash prefixes for the commit
		 *     hash, but it may return a 400 response if the provided prefix is
		 *     ambiguous. Using a full commit hash is the preferred approach.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["tag"]
				}
			}
			readonly responses: {
				/** @description The newly created tag. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["tag"]
					}
				}
				/** @description If the target hash is missing, ambiguous, or invalid, or if the name is not provided. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/refs/tags/{name}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The name of the tag. */
				readonly name: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a tag
		 * @description Returns the specified tag.
		 *
		 *     ```
		 *     $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq .
		 *     {
		 *       "name": "3.8",
		 *       "links": {
		 *         "commits": {
		 *           "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8"
		 *         },
		 *         "self": {
		 *           "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8"
		 *         },
		 *         "html": {
		 *           "href": "https://bitbucket.org/seanfarley/hg/commits/tag/3.8"
		 *         }
		 *       },
		 *       "tagger": {
		 *         "raw": "Matt Mackall <mpm@selenic.com>",
		 *         "type": "author",
		 *         "user": {
		 *           "username": "mpmselenic",
		 *           "nickname": "mpmselenic",
		 *           "display_name": "Matt Mackall",
		 *           "type": "user",
		 *           "uuid": "{a4934530-db4c-419c-a478-9ab4964c2ee7}",
		 *           "links": {
		 *             "self": {
		 *               "href": "https://api.bitbucket.org/2.0/users/mpmselenic"
		 *             },
		 *             "html": {
		 *               "href": "https://bitbucket.org/mpmselenic/"
		 *             },
		 *             "avatar": {
		 *               "href": "https://bitbucket.org/account/mpmselenic/avatar/32/"
		 *             }
		 *           }
		 *         }
		 *       },
		 *       "date": "2016-05-01T18:52:25+00:00",
		 *       "message": "Added tag 3.8 for changeset f85de28eae32",
		 *       "type": "tag",
		 *       "target": {
		 *         "hash": "f85de28eae32e7d3064b1a1321309071bbaaa069",
		 *         "repository": {
		 *           "links": {
		 *             "self": {
		 *               "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg"
		 *             },
		 *             "html": {
		 *               "href": "https://bitbucket.org/seanfarley/hg"
		 *             },
		 *             "avatar": {
		 *               "href": "https://bitbucket.org/seanfarley/hg/avatar/32/"
		 *             }
		 *           },
		 *           "type": "repository",
		 *           "name": "hg",
		 *           "full_name": "seanfarley/hg",
		 *           "uuid": "{c75687fb-e99d-4579-9087-190dbd406d30}"
		 *         },
		 *         "links": {
		 *           "self": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069"
		 *           },
		 *           "comments": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments"
		 *           },
		 *           "patch": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069"
		 *           },
		 *           "html": {
		 *             "href": "https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069"
		 *           },
		 *           "diff": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069"
		 *           },
		 *           "approve": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve"
		 *           },
		 *           "statuses": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses"
		 *           }
		 *         },
		 *         "author": {
		 *           "raw": "Sean Farley <sean@farley.io>",
		 *           "type": "author",
		 *           "user": {
		 *             "username": "seanfarley",
		 *             "nickname": "seanfarley",
		 *             "display_name": "Sean Farley",
		 *             "type": "user",
		 *             "uuid": "{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}",
		 *             "links": {
		 *               "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/users/seanfarley"
		 *               },
		 *               "html": {
		 *                 "href": "https://bitbucket.org/seanfarley/"
		 *               },
		 *               "avatar": {
		 *                 "href": "https://bitbucket.org/account/seanfarley/avatar/32/"
		 *               }
		 *             }
		 *           }
		 *         },
		 *         "parents": [
		 *           {
		 *             "hash": "9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2",
		 *             "type": "commit",
		 *             "links": {
		 *               "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2"
		 *               },
		 *               "html": {
		 *                 "href": "https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2"
		 *               }
		 *             }
		 *           }
		 *         ],
		 *         "date": "2016-05-01T04:21:17+00:00",
		 *         "message": "debian: alphabetize build deps",
		 *         "type": "commit"
		 *       }
		 *     }
		 *     ```
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The name of the tag. */
					readonly name: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The tag object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["tag"]
					}
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or tag does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a tag
		 * @description Delete a tag in the specified repository.
		 *
		 *     The tag name should not include any prefixes (e.g. refs/tags).
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The name of the tag. */
					readonly name: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates the specified tag was successfully deleted. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the repository is private and the authenticated user does not have
				 *     access to it.
				 *      */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The specified repository or tag does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/src": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the root directory of the main branch
		 * @description This endpoint redirects the client to the directory listing of the
		 *     root directory on the main branch.
		 *
		 *     This is equivalent to directly hitting
		 *     [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D)
		 *     without having to know the name or SHA1 of the repo's main branch.
		 *
		 *     To create new commits, [POST to this endpoint](#post)
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Instead of returning the file's contents, return the (json) meta data for it. */
					readonly format?: "meta"
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the path matches a file, then the raw contents of the file are
				 *     returned (unless the `format=meta` query parameter was provided,
				 *     in which case a json document containing the file's meta data is
				 *     returned). If the path matches a directory, then a paginated
				 *     list of file and directory entries is returned (if the
				 *     `format=meta` query parameter was provided, then the json document
				 *     containing the directory's meta data is returned).
				 *      */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_treeentries"]
					}
				}
				/** @description If the path or commit in the URL does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a commit by uploading a file
		 * @description This endpoint is used to create new commits in the repository by
		 *     uploading files.
		 *
		 *     To add a new file to a repository:
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \
		 *       -F /repo/path/to/image.png=@image.png
		 *     ```
		 *
		 *     This will create a new commit on top of the main branch, inheriting the
		 *     contents of the main branch, but adding (or overwriting) the
		 *     `image.png` file to the repository in the `/repo/path/to` directory.
		 *
		 *     To create a commit that deletes files, use the `files` parameter:
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \
		 *       -F files=/file/to/delete/1.txt \
		 *       -F files=/file/to/delete/2.txt
		 *     ```
		 *
		 *     You can add/modify/delete multiple files in a request. Rename/move a
		 *     file by deleting the old path and adding the content at the new path.
		 *
		 *     This endpoint accepts `multipart/form-data` (as in the examples above),
		 *     as well as `application/x-www-form-urlencoded`.
		 *
		 *     Note: `multipart/form-data` is currently not supported by Forge apps
		 *     for this API.
		 *
		 *     #### multipart/form-data
		 *
		 *     A `multipart/form-data` post contains a series of "form fields" that
		 *     identify both the individual files that are being uploaded, as well as
		 *     additional, optional meta data.
		 *
		 *     Files are uploaded in file form fields (those that have a
		 *     `Content-Disposition` parameter) whose field names point to the remote
		 *     path in the repository where the file should be stored. Path field
		 *     names are always interpreted to be absolute from the root of the
		 *     repository, regardless whether the client uses a leading slash (as the
		 *     above `curl` example did).
		 *
		 *     File contents are treated as bytes and are not decoded as text.
		 *
		 *     The commit message, as well as other non-file meta data for the
		 *     request, is sent along as normal form field elements. Meta data fields
		 *     share the same namespace as the file objects. For `multipart/form-data`
		 *     bodies that should not lead to any ambiguity, as the
		 *     `Content-Disposition` header will contain the `filename` parameter to
		 *     distinguish between a file named "message" and the commit message field.
		 *
		 *     #### application/x-www-form-urlencoded
		 *
		 *     It is also possible to upload new files using a simple
		 *     `application/x-www-form-urlencoded` POST. This can be convenient when
		 *     uploading pure text files:
		 *
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \
		 *       --data-urlencode "/path/to/me.txt=Lorem ipsum." \
		 *       --data-urlencode "message=Initial commit" \
		 *       --data-urlencode "author=Erik van Zijst <erik.van.zijst@gmail.com>"
		 *     ```
		 *
		 *     There could be a field name clash if a client were to upload a file
		 *     named "message", as this filename clashes with the meta data property
		 *     for the commit message. To avoid this and to upload files whose names
		 *     clash with the meta data properties, use a leading slash for the files,
		 *     e.g. `curl --data-urlencode "/message=file contents"`.
		 *
		 *     When an explicit slash is omitted for a file whose path matches that of
		 *     a meta data parameter, then it is interpreted as meta data, not as a
		 *     file.
		 *
		 *     #### Executables and links
		 *
		 *     While this API aims to facilitate the most common use cases, it is
		 *     possible to perform some more advanced operations like creating a new
		 *     symlink in the repository, or creating an executable file.
		 *
		 *     Files can be supplied with a `x-attributes` value in the
		 *     `Content-Disposition` header. For example, to upload an executable
		 *     file, as well as create a symlink from `README.txt` to `README`:
		 *
		 *     ```
		 *     --===============1438169132528273974==
		 *     Content-Type: text/plain; charset="us-ascii"
		 *     MIME-Version: 1.0
		 *     Content-Transfer-Encoding: 7bit
		 *     Content-ID: "bin/shutdown.sh"
		 *     Content-Disposition: attachment; filename="shutdown.sh"; x-attributes:"executable"
		 *
		 *     #!/bin/sh
		 *     halt
		 *
		 *     --===============1438169132528273974==
		 *     Content-Type: text/plain; charset="us-ascii"
		 *     MIME-Version: 1.0
		 *     Content-Transfer-Encoding: 7bit
		 *     Content-ID: "/README.txt"
		 *     Content-Disposition: attachment; filename="README.txt"; x-attributes:"link"
		 *
		 *     README
		 *     --===============1438169132528273974==--
		 *     ```
		 *
		 *     Links are files that contain the target path and have
		 *     `x-attributes:"link"` set.
		 *
		 *     When overwriting links with files, or vice versa, the newly uploaded
		 *     file determines both the new contents, as well as the attributes. That
		 *     means uploading a file without specifying `x-attributes="link"` will
		 *     create a regular file, even if the parent commit hosted a symlink at
		 *     the same path.
		 *
		 *     The same applies to executables. When modifying an existing executable
		 *     file, the form-data file element must include
		 *     `x-attributes="executable"` in order to preserve the executable status
		 *     of the file.
		 *
		 *     Note that this API does not support the creation or manipulation of
		 *     subrepos / submodules.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     The raw string to be used as the new commit's author.
					 *     This string follows the format
					 *     `Erik van Zijst <evzijst@atlassian.com>`.
					 *
					 *     When omitted, Bitbucket uses the authenticated user's
					 *     full/display name and primary email address. Commits cannot
					 *     be created anonymously. */
					readonly author?: string
					/** @description
					 *     The name of the branch that the new commit should be
					 *     created on. When omitted, the commit will be created on top
					 *     of the main branch and will become the main branch's new
					 *     head.
					 *
					 *     When a branch name is provided that already exists in the
					 *     repo, then the commit will be created on top of that
					 *     branch. In this case, *if* a parent SHA1 was also provided,
					 *     then it is asserted that the parent is the branch's
					 *     tip/HEAD at the time the request is made. When this is not
					 *     the case, a 409 is returned.
					 *
					 *     When a new branch name is specified (that does not already
					 *     exist in the repo), and no parent SHA1s are provided, then
					 *     the new commit will inherit from the current main branch's
					 *     tip/HEAD commit, but not advance the main branch. The new
					 *     commit will be the new branch. When the request *also*
					 *     specifies a parent SHA1, then the new commit and branch
					 *     are created directly on top of the parent commit,
					 *     regardless of the state of the main branch.
					 *
					 *     When a branch name is not specified, but a parent SHA1 is
					 *     provided, then Bitbucket asserts that it represents the
					 *     main branch's current HEAD/tip, or a 409 is returned.
					 *
					 *     When a branch name is not specified and the repo is empty,
					 *     the new commit will become the repo's root commit and will
					 *     be on the main branch.
					 *
					 *     When a branch name is specified and the repo is empty, the
					 *     new commit will become the repo's root commit and also
					 *     define the repo's main branch going forward.
					 *
					 *     This API cannot be used to create additional root commits
					 *     in non-empty repos.
					 *
					 *     The branch field cannot be repeated.
					 *
					 *     As a side effect, this API can be used to create a new
					 *     branch without modifying any files, by specifying a new
					 *     branch name in this field, together with `parents`, but
					 *     omitting the `files` fields, while not sending any files.
					 *     This will create a new commit and branch with the same
					 *     contents as the first parent. The diff of this commit
					 *     against its first parent will be empty.
					 *      */
					readonly branch?: string
					/** @description
					 *     Optional field that declares the files that the request is
					 *     manipulating. When adding a new file to a repo, or when
					 *     overwriting an existing file, the client can just upload
					 *     the full contents of the file in a normal form field and
					 *     the use of this `files` meta data field is redundant.
					 *     However, when the `files` field contains a file path that
					 *     does not have a corresponding, identically-named form
					 *     field, then Bitbucket interprets that as the client wanting
					 *     to replace the named file with the null set and the file is
					 *     deleted instead.
					 *
					 *     Paths in the repo that are referenced in neither files nor
					 *     an individual file field, remain unchanged and carry over
					 *     from the parent to the new commit.
					 *
					 *     This API does not support renaming as an explicit feature.
					 *     To rename a file, simply delete it and recreate it under
					 *     the new name in the same commit.
					 *      */
					readonly files?: string
					/** @description The commit message. When omitted, Bitbucket uses a canned string. */
					readonly message?: string
					/** @description
					 *     A comma-separated list of SHA1s of the commits that should
					 *     be the parents of the newly created commit.
					 *
					 *     When omitted, the new commit will inherit from and become
					 *     a child of the main branch's tip/HEAD commit.
					 *
					 *     When more than one SHA1 is provided, the first SHA1
					 *     identifies the commit from which the content will be
					 *     inherited.". */
					readonly parents?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description
				 *      */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have write or admin access */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the repository does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/src/{commit}/{path}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit's SHA1. */
				readonly commit: string
				/** @description Path to the file. */
				readonly path: string
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get file or directory contents
		 * @description This endpoints is used to retrieve the contents of a single file,
		 *     or the contents of a directory at a specified revision.
		 *
		 *     #### Raw file contents
		 *
		 *     When `path` points to a file, this endpoint returns the raw contents.
		 *     The response's Content-Type is derived from the filename
		 *     extension (not from the contents). The file contents are not processed
		 *     and no character encoding/recoding is performed and as a result no
		 *     character encoding is included as part of the Content-Type.
		 *
		 *     The `Content-Disposition` header will be "attachment" to prevent
		 *     browsers from running executable files.
		 *
		 *     If the file is managed by LFS, then a 301 redirect pointing to
		 *     Atlassian's media services platform is returned.
		 *
		 *     The response includes an ETag that is based on the contents of the file
		 *     and its attributes. This means that an empty `__init__.py` always
		 *     returns the same ETag, regardless on the directory it lives in, or the
		 *     commit it is on.
		 *
		 *     #### File meta data
		 *
		 *     When the request for a file path includes the query parameter
		 *     `?format=meta`, instead of returning the file's raw contents, Bitbucket
		 *     instead returns the JSON object describing the file's properties:
		 *
		 *     ```javascript
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta
		 *     {
		 *       "links": {
		 *         "self": {
		 *           "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py"
		 *         },
		 *         "meta": {
		 *           "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta"
		 *         }
		 *       },
		 *       "path": "tests/__init__.py",
		 *       "commit": {
		 *         "type": "commit",
		 *         "hash": "eefd5ef5d3df01aed629f650959d6706d54cd335",
		 *         "links": {
		 *           "self": {
		 *             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335"
		 *           },
		 *           "html": {
		 *             "href": "https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335"
		 *           }
		 *         }
		 *       },
		 *       "attributes": [],
		 *       "type": "commit_file",
		 *       "size": 0
		 *     }
		 *     ```
		 *
		 *     File objects contain an `attributes` element that contains a list of
		 *     possible modifiers. Currently defined values are:
		 *
		 *     * `link` -- indicates that the entry is a symbolic link. The contents
		 *         of the file represent the path the link points to.
		 *     * `executable` -- indicates that the file has the executable bit set.
		 *     * `subrepository` -- indicates that the entry points to a submodule or
		 *         subrepo. The contents of the file is the SHA1 of the repository
		 *         pointed to.
		 *     * `binary` -- indicates whether Bitbucket thinks the file is binary.
		 *
		 *     This endpoint can provide an alternative to how a HEAD request can be
		 *     used to check for the existence of a file, or a file's size without
		 *     incurring the overhead of receiving its full contents.
		 *
		 *
		 *     #### Directory listings
		 *
		 *     When `path` points to a directory instead of a file, the response is a
		 *     paginated list of directory and file objects in the same order as the
		 *     underlying SCM system would return them.
		 *
		 *     For example:
		 *
		 *     ```javascript
		 *     $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests
		 *     {
		 *       "pagelen": 10,
		 *       "values": [
		 *         {
		 *           "path": "tests/test_project",
		 *           "type": "commit_directory",
		 *           "links": {
		 *             "self": {
		 *               "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/"
		 *             },
		 *             "meta": {
		 *               "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta"
		 *             }
		 *           },
		 *           "commit": {
		 *             "type": "commit",
		 *             "hash": "eefd5ef5d3df01aed629f650959d6706d54cd335",
		 *             "links": {
		 *               "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335"
		 *               },
		 *               "html": {
		 *                 "href": "https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335"
		 *               }
		 *             }
		 *           }
		 *         },
		 *         {
		 *           "links": {
		 *             "self": {
		 *               "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py"
		 *             },
		 *             "meta": {
		 *               "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta"
		 *             }
		 *           },
		 *           "path": "tests/__init__.py",
		 *           "commit": {
		 *             "type": "commit",
		 *             "hash": "eefd5ef5d3df01aed629f650959d6706d54cd335",
		 *             "links": {
		 *               "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335"
		 *               },
		 *               "html": {
		 *                 "href": "https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335"
		 *               }
		 *             }
		 *           },
		 *           "attributes": [],
		 *           "type": "commit_file",
		 *           "size": 0
		 *         }
		 *       ],
		 *       "page": 1,
		 *       "size": 2
		 *     }
		 *     ```
		 *
		 *     When listing the contents of the repo's root directory, the use of a
		 *     trailing slash at the end of the URL is required.
		 *
		 *     The response by default is not recursive, meaning that only the direct contents of
		 *     a path are returned. The response does not recurse down into
		 *     subdirectories. In order to "walk" the entire directory tree, the
		 *     client can either parse each response and follow the `self` links of each
		 *     `commit_directory` object, or can specify a `max_depth` to recurse to.
		 *
		 *     The max_depth parameter will do a breadth-first search to return the contents of the subdirectories
		 *     up to the depth specified. Breadth-first search was chosen as it leads to the least amount of
		 *     file system operations for git. If the `max_depth` parameter is specified to be too
		 *     large, the call will time out and return a 555.
		 *
		 *     Each returned object is either a `commit_file`, or a `commit_directory`,
		 *     both of which contain a `path` element. This path is the absolute path
		 *     from the root of the repository. Each object also contains a `commit`
		 *     object which embeds the commit the file is on. Note that this is merely
		 *     the commit that was used in the URL. It is *not* the commit that last
		 *     modified the file.
		 *
		 *     Directory objects have 2 representations. Their `self` link returns the
		 *     paginated contents of the directory. The `meta` link on the other hand
		 *     returns the actual `directory` object itself, e.g.:
		 *
		 *     ```javascript
		 *     {
		 *       "path": "tests/test_project",
		 *       "type": "commit_directory",
		 *       "links": {
		 *         "self": {
		 *           "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/"
		 *         },
		 *         "meta": {
		 *           "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta"
		 *         }
		 *       },
		 *       "commit": { ... }
		 *     }
		 *     ```
		 *
		 *     #### Querying, filtering and sorting
		 *
		 *     Like most API endpoints, this API supports the Bitbucket
		 *     querying/filtering syntax and so you could filter a directory listing
		 *     to only include entries that match certain criteria. For instance, to
		 *     list all binary files over 1kb use the expression:
		 *
		 *     `size > 1024 and attributes = "binary"`
		 *
		 *     which after urlencoding yields the query string:
		 *
		 *     `?q=size%3E1024+and+attributes%3D%22binary%22`
		 *
		 *     To change the ordering of the response, use the `?sort` parameter:
		 *
		 *     `.../src/eefd5ef/?sort=-size`
		 *
		 *     See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more
		 *     details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description If 'meta' is provided, returns the (json) meta data for the contents of the file.  If 'rendered' is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. The 'rendered' option only supports these filetypes: `.md`, `.markdown`, `.mkd`, `.mkdn`, `.mdown`, `.text`, `.rst`, and `.textile`. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file's actual contents. */
					readonly format?: "meta" | "rendered"
					/** @description If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1. */
					readonly max_depth?: number
					/** @description Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The commit's SHA1. */
					readonly commit: string
					/** @description Path to the file. */
					readonly path: string
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the path matches a file, then the raw contents of the file are
				 *     returned.  If the `format=meta` query parameter is provided,
				 *     a json document containing the file's meta data is
				 *     returned.  If the `format=rendered` query parameter is provided,
				 *     the contents of the file in HTML-formated rendered markup is returned.
				 *     If the path matches a directory, then a paginated
				 *     list of file and directory entries is returned (if the
				 *     `format=meta` query parameter was provided, then the json document
				 *     containing the directory's meta data is returned.)
				 *      */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_treeentries"]
					}
				}
				/** @description If the path or commit in the URL does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the call times out, possibly because the specified recursion depth is too large. */
				readonly 555: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/versions": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List defined versions for issues
		 * @description Returns the versions that have been defined in the issue tracker.
		 *
		 *     This resource is only available on repositories that have the issue
		 *     tracker enabled.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The versions that have been defined in the issue tracker. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_versions"]
					}
				}
				/** @description The specified repository does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/versions/{version_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description The version's id */
				readonly version_id: number
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a defined version for issues
		 * @description Returns the specified issue tracker version object.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description The version's id */
					readonly version_id: number
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified version object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["version"]
					}
				}
				/** @description The specified repository or version does not exist or does not have the issue tracker enabled. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/repositories/{workspace}/{repo_slug}/watchers": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List repositories watchers
		 * @description Returns a paginated list of all the watchers on the specified
		 *     repository.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of all the watchers on the specified repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_accounts"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List snippets
		 * @description Returns all snippets. Like pull requests, repositories and workspaces, the
		 *     full set of snippets is defined by what the current user has access to.
		 *
		 *     This includes all snippets owned by any of the workspaces the user is a member of,
		 *     or snippets by other users that the current user is either watching or has collaborated
		 *     on (for instance by commenting on it).
		 *
		 *     To limit the set of returned snippets, apply the
		 *     `?role=[owner|contributor|member]` query parameter where the roles are
		 *     defined as follows:
		 *
		 *     * `owner`: all snippets owned by the current user
		 *     * `contributor`: all snippets owned by, or watched by the current user
		 *     * `member`: created in a workspaces or watched by the current user
		 *
		 *     When no role is specified, all public snippets are returned, as well as all
		 *     privately owned snippets watched or commented on.
		 *
		 *     The returned response is a normal paginated JSON list. This endpoint
		 *     only supports `application/json` responses and no
		 *     `multipart/form-data` or `multipart/related`. As a result, it is not
		 *     possible to include the file contents.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Filter down the result based on the authenticated user's role (`owner`, `contributor`, or `member`). */
					readonly role?: "contributor" | "member" | "owner"
				}
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of snippets. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_snippets"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a snippet
		 * @description Creates a new snippet under the authenticated user's account.
		 *
		 *     Snippets can contain multiple files. Both text and binary files are
		 *     supported.
		 *
		 *     The simplest way to create a new snippet from a local file:
		 *
		 *         $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file=@image.png
		 *
		 *     Creating snippets through curl has a few limitations and so let's look
		 *     at a more complicated scenario.
		 *
		 *     Snippets are created with a multipart POST. Both `multipart/form-data`
		 *     and `multipart/related` are supported. Both allow the creation of
		 *     snippets with both meta data (title, etc), as well as multiple text
		 *     and binary files.
		 *
		 *     The main difference is that `multipart/related` can use rich encoding
		 *     for the meta data (currently JSON).
		 *
		 *
		 *     multipart/related (RFC-2387)
		 *     ----------------------------
		 *
		 *     This is the most advanced and efficient way to create a paste.
		 *
		 *         POST /2.0/snippets/evzijst HTTP/1.1
		 *         Content-Length: 1188
		 *         Content-Type: multipart/related; start="snippet"; boundary="===============1438169132528273974=="
		 *         MIME-Version: 1.0
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: application/json; charset="utf-8"
		 *         MIME-Version: 1.0
		 *         Content-ID: snippet
		 *
		 *         {
		 *           "title": "My snippet",
		 *           "is_private": true,
		 *           "scm": "git",
		 *           "files": {
		 *               "foo.txt": {},
		 *               "image.png": {}
		 *             }
		 *         }
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: text/plain; charset="us-ascii"
		 *         MIME-Version: 1.0
		 *         Content-Transfer-Encoding: 7bit
		 *         Content-ID: "foo.txt"
		 *         Content-Disposition: attachment; filename="foo.txt"
		 *
		 *         foo
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: image/png
		 *         MIME-Version: 1.0
		 *         Content-Transfer-Encoding: base64
		 *         Content-ID: "image.png"
		 *         Content-Disposition: attachment; filename="image.png"
		 *
		 *         iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m
		 *         TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB
		 *         cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5
		 *         EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ
		 *         73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN
		 *         AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==
		 *         --===============1438169132528273974==--
		 *
		 *     The request contains multiple parts and is structured as follows.
		 *
		 *     The first part is the JSON document that describes the snippet's
		 *     properties or meta data. It either has to be the first part, or the
		 *     request's `Content-Type` header must contain the `start` parameter to
		 *     point to it.
		 *
		 *     The remaining parts are the files of which there can be zero or more.
		 *     Each file part should contain the `Content-ID` MIME header through
		 *     which the JSON meta data's `files` element addresses it. The value
		 *     should be the name of the file.
		 *
		 *     `Content-Disposition` is an optional MIME header. The header's
		 *     optional `filename` parameter can be used to specify the file name
		 *     that Bitbucket should use when writing the file to disk. When present,
		 *     `filename` takes precedence over the value of `Content-ID`.
		 *
		 *     When the JSON body omits the `files` element, the remaining parts are
		 *     not ignored. Instead, each file is added to the new snippet as if its
		 *     name was explicitly linked (the use of the `files` elements is
		 *     mandatory for some operations like deleting or renaming files).
		 *
		 *
		 *     multipart/form-data
		 *     -------------------
		 *
		 *     The use of JSON for the snippet's meta data is optional. Meta data can
		 *     also be supplied as regular form fields in a more conventional
		 *     `multipart/form-data` request:
		 *
		 *         $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title="My snippet"               -F file=@foo.txt -F file=@image.png
		 *
		 *         POST /2.0/snippets HTTP/1.1
		 *         Content-Length: 951
		 *         Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f
		 *
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: form-data; name="file"; filename="foo.txt"
		 *         Content-Type: text/plain
		 *
		 *         foo
		 *
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: form-data; name="file"; filename="image.png"
		 *         Content-Type: application/octet-stream
		 *
		 *         ?PNG
		 *
		 *         IHDR?1??I.....
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: form-data; name="title"
		 *
		 *         My snippet
		 *         ------------------------------63a4b224c59f--
		 *
		 *     Here the meta data properties are included as flat, top-level form
		 *     fields. The file attachments use the `file` field name. To attach
		 *     multiple files, simply repeat the field.
		 *
		 *     The advantage of `multipart/form-data` over `multipart/related` is
		 *     that it can be easier to build clients.
		 *
		 *     Essentially all properties are optional, `title` and `files` included.
		 *
		 *
		 *     Sharing and Visibility
		 *     ----------------------
		 *
		 *     Snippets can be either public (visible to anyone on Bitbucket, as well
		 *     as anonymous users), or private (visible only to members of the workspace).
		 *     This is controlled through the snippet's `is_private` element:
		 *
		 *     * **is_private=false** -- everyone, including anonymous users can view
		 *       the snippet
		 *     * **is_private=true** -- only workspace members can view the snippet
		 *
		 *     To create the snippet under a workspace, just append the workspace ID
		 *     to the URL. See [`/2.0/snippets/{workspace}`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["snippet"]
			readonly responses: {
				/** @description The newly created snippet object. */
				readonly 201: {
					headers: {
						/** @description The URL of the newly created snippet. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["snippet"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List snippets in a workspace
		 * @description Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered
		 *     by the snippet owner and only those that are owned by `{workspace}` are
		 *     returned.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Filter down the result based on the authenticated user's role (`owner`, `contributor`, or `member`). */
					readonly role?: "contributor" | "member" | "owner"
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of snippets. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_snippets"]
					}
				}
				/** @description If the user does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a snippet for a workspace
		 * @description Identical to [`/snippets`](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be
		 *     created under the workspace specified in the path parameter
		 *     `{workspace}`.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["snippet"]
			readonly responses: {
				/** @description The newly created snippet object. */
				readonly 201: {
					headers: {
						/** @description The URL of the newly created snippet. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["snippet"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have permission to create snippets in the specified workspace. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a snippet
		 * @description Retrieves a single snippet.
		 *
		 *     Snippets support multiple content types:
		 *
		 *     * application/json
		 *     * multipart/related
		 *     * multipart/form-data
		 *
		 *
		 *     application/json
		 *     ----------------
		 *
		 *     The default content type of the response is `application/json`.
		 *     Since JSON is always `utf-8`, it cannot reliably contain file contents
		 *     for files that are not text. Therefore, JSON snippet documents only
		 *     contain the filename and links to the file contents.
		 *
		 *     This means that in order to retrieve all parts of a snippet, N+1
		 *     requests need to be made (where N is the number of files in the
		 *     snippet).
		 *
		 *
		 *     multipart/related
		 *     -----------------
		 *
		 *     To retrieve an entire snippet in a single response, use the
		 *     `Accept: multipart/related` HTTP request header.
		 *
		 *         $ curl -H "Accept: multipart/related" https://api.bitbucket.org/2.0/snippets/evzijst/1
		 *
		 *     Response:
		 *
		 *         HTTP/1.1 200 OK
		 *         Content-Length: 2214
		 *         Content-Type: multipart/related; start="snippet"; boundary="===============1438169132528273974=="
		 *         MIME-Version: 1.0
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: application/json; charset="utf-8"
		 *         MIME-Version: 1.0
		 *         Content-ID: snippet
		 *
		 *         {
		 *           "links": {
		 *             "self": {
		 *               "href": "https://api.bitbucket.org/2.0/snippets/evzijst/kypj"
		 *             },
		 *             "html": {
		 *               "href": "https://bitbucket.org/snippets/evzijst/kypj"
		 *             },
		 *             "comments": {
		 *               "href": "https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments"
		 *             },
		 *             "watchers": {
		 *               "href": "https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers"
		 *             },
		 *             "commits": {
		 *               "href": "https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits"
		 *             }
		 *           },
		 *           "id": kypj,
		 *           "title": "My snippet",
		 *           "created_on": "2014-12-29T22:22:04.790331+00:00",
		 *           "updated_on": "2014-12-29T22:22:04.790331+00:00",
		 *           "is_private": false,
		 *           "files": {
		 *             "foo.txt": {
		 *               "links": {
		 *                 "self": {
		 *                   "href": "https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt"
		 *                 },
		 *                 "html": {
		 *                   "href": "https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt"
		 *                 }
		 *               }
		 *             },
		 *             "image.png": {
		 *               "links": {
		 *                 "self": {
		 *                   "href": "https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png"
		 *                 },
		 *                 "html": {
		 *                   "href": "https://bitbucket.org/snippets/evzijst/kypj#file-image.png"
		 *                 }
		 *               }
		 *             }
		 *           ],
		 *           "owner": {
		 *             "username": "evzijst",
		 *             "nickname": "evzijst",
		 *             "display_name": "Erik van Zijst",
		 *             "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}",
		 *             "links": {
		 *               "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/users/evzijst"
		 *               },
		 *               "html": {
		 *                 "href": "https://bitbucket.org/evzijst"
		 *               },
		 *               "avatar": {
		 *                 "href": "https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png"
		 *               }
		 *             }
		 *           },
		 *           "creator": {
		 *             "username": "evzijst",
		 *             "nickname": "evzijst",
		 *             "display_name": "Erik van Zijst",
		 *             "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}",
		 *             "links": {
		 *               "self": {
		 *                 "href": "https://api.bitbucket.org/2.0/users/evzijst"
		 *               },
		 *               "html": {
		 *                 "href": "https://bitbucket.org/evzijst"
		 *               },
		 *               "avatar": {
		 *                 "href": "https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png"
		 *               }
		 *             }
		 *           }
		 *         }
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: text/plain; charset="us-ascii"
		 *         MIME-Version: 1.0
		 *         Content-Transfer-Encoding: 7bit
		 *         Content-ID: "foo.txt"
		 *         Content-Disposition: attachment; filename="foo.txt"
		 *
		 *         foo
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: image/png
		 *         MIME-Version: 1.0
		 *         Content-Transfer-Encoding: base64
		 *         Content-ID: "image.png"
		 *         Content-Disposition: attachment; filename="image.png"
		 *
		 *         iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m
		 *         TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB
		 *         cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5
		 *         EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ
		 *         73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN
		 *         AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==
		 *         --===============1438169132528273974==--
		 *
		 *     multipart/form-data
		 *     -------------------
		 *
		 *     As with creating new snippets, `multipart/form-data` can be used as an
		 *     alternative to `multipart/related`. However, the inherently flat
		 *     structure of form-data means that only basic, root-level properties
		 *     can be returned, while nested elements like `links` are omitted:
		 *
		 *         $ curl -H "Accept: multipart/form-data" https://api.bitbucket.org/2.0/snippets/evzijst/kypj
		 *
		 *     Response:
		 *
		 *         HTTP/1.1 200 OK
		 *         Content-Length: 951
		 *         Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f
		 *
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: form-data; name="title"
		 *         Content-Type: text/plain; charset="utf-8"
		 *
		 *         My snippet
		 *         ------------------------------63a4b224c59f--
		 *         Content-Disposition: attachment; name="file"; filename="foo.txt"
		 *         Content-Type: text/plain
		 *
		 *         foo
		 *
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: attachment; name="file"; filename="image.png"
		 *         Content-Transfer-Encoding: base64
		 *         Content-Type: application/octet-stream
		 *
		 *         iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m
		 *         TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB
		 *         cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5
		 *         EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ
		 *         73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN
		 *         AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg==
		 *         ------------------------------5957323a6b76--
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The snippet object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet"]
						readonly "multipart/form-data": components["schemas"]["snippet"]
						readonly "multipart/related": components["schemas"]["snippet"]
					}
				}
				/** @description If the snippet is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If authenticated user does not have access to the private snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If the snippet marked as spam. */
				readonly 410: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a snippet
		 * @description Used to update a snippet. Use this to add and delete files and to
		 *     change a snippet's title.
		 *
		 *     To update a snippet, one can either PUT a full snapshot, or only the
		 *     parts that need to be changed.
		 *
		 *     The contract for PUT on this API is that properties missing from the
		 *     request remain untouched so that snippets can be efficiently
		 *     manipulated with differential payloads.
		 *
		 *     To delete a property (e.g. the title, or a file), include its name in
		 *     the request, but omit its value (use `null`).
		 *
		 *     As in Git, explicit renaming of files is not supported. Instead, to
		 *     rename a file, delete it and add it again under another name. This can
		 *     be done atomically in a single request. Rename detection is left to
		 *     the SCM.
		 *
		 *     PUT supports three different content types for both request and
		 *     response bodies:
		 *
		 *     * `application/json`
		 *     * `multipart/related`
		 *     * `multipart/form-data`
		 *
		 *     The content type used for the request body can be different than that
		 *     used for the response. Content types are specified using standard HTTP
		 *     headers.
		 *
		 *     Use the `Content-Type` and `Accept` headers to select the desired
		 *     request and response format.
		 *
		 *
		 *     application/json
		 *     ----------------
		 *
		 *     As with creation and retrieval, the content type determines what
		 *     properties can be manipulated. `application/json` does not support
		 *     file contents and is therefore limited to a snippet's meta data.
		 *
		 *     To update the title, without changing any of its files:
		 *
		 *         $ curl -X POST -H "Content-Type: application/json" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d '{"title": "Updated title"}'
		 *
		 *
		 *     To delete the title:
		 *
		 *         $ curl -X POST -H "Content-Type: application/json" https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d '{"title": null}'
		 *
		 *     Not all parts of a snippet can be manipulated. The owner and creator
		 *     for instance are immutable.
		 *
		 *
		 *     multipart/related
		 *     -----------------
		 *
		 *     `multipart/related` can be used to manipulate all of a snippet's
		 *     properties. The body is identical to a POST. properties omitted from
		 *     the request are left unchanged. Since the `start` part contains JSON,
		 *     the mechanism for manipulating the snippet's meta data is identical
		 *     to `application/json` requests.
		 *
		 *     To update one of a snippet's file contents, while also changing its
		 *     title:
		 *
		 *         PUT /2.0/snippets/evzijst/kypj HTTP/1.1
		 *         Content-Length: 288
		 *         Content-Type: multipart/related; start="snippet"; boundary="===============1438169132528273974=="
		 *         MIME-Version: 1.0
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: application/json; charset="utf-8"
		 *         MIME-Version: 1.0
		 *         Content-ID: snippet
		 *
		 *         {
		 *           "title": "My updated snippet",
		 *           "files": {
		 *               "foo.txt": {}
		 *             }
		 *         }
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: text/plain; charset="us-ascii"
		 *         MIME-Version: 1.0
		 *         Content-Transfer-Encoding: 7bit
		 *         Content-ID: "foo.txt"
		 *         Content-Disposition: attachment; filename="foo.txt"
		 *
		 *         Updated file contents.
		 *
		 *         --===============1438169132528273974==--
		 *
		 *     Here only the parts that are changed are included in the body. The
		 *     other files remain untouched.
		 *
		 *     Note the use of the `files` list in the JSON part. This list contains
		 *     the files that are being manipulated. This list should have
		 *     corresponding multiparts in the request that contain the new contents
		 *     of these files.
		 *
		 *     If a filename in the `files` list does not have a corresponding part,
		 *     it will be deleted from the snippet, as shown below:
		 *
		 *         PUT /2.0/snippets/evzijst/kypj HTTP/1.1
		 *         Content-Length: 188
		 *         Content-Type: multipart/related; start="snippet"; boundary="===============1438169132528273974=="
		 *         MIME-Version: 1.0
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: application/json; charset="utf-8"
		 *         MIME-Version: 1.0
		 *         Content-ID: snippet
		 *
		 *         {
		 *           "files": {
		 *             "image.png": {}
		 *           }
		 *         }
		 *
		 *         --===============1438169132528273974==--
		 *
		 *     To simulate a rename, delete a file and add the same file under
		 *     another name:
		 *
		 *         PUT /2.0/snippets/evzijst/kypj HTTP/1.1
		 *         Content-Length: 212
		 *         Content-Type: multipart/related; start="snippet"; boundary="===============1438169132528273974=="
		 *         MIME-Version: 1.0
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: application/json; charset="utf-8"
		 *         MIME-Version: 1.0
		 *         Content-ID: snippet
		 *
		 *         {
		 *             "files": {
		 *               "foo.txt": {},
		 *               "bar.txt": {}
		 *             }
		 *         }
		 *
		 *         --===============1438169132528273974==
		 *         Content-Type: text/plain; charset="us-ascii"
		 *         MIME-Version: 1.0
		 *         Content-Transfer-Encoding: 7bit
		 *         Content-ID: "bar.txt"
		 *         Content-Disposition: attachment; filename="bar.txt"
		 *
		 *         foo
		 *
		 *         --===============1438169132528273974==--
		 *
		 *
		 *     multipart/form-data
		 *     -----------------
		 *
		 *     Again, one can also use `multipart/form-data` to manipulate file
		 *     contents and meta data atomically.
		 *
		 *         $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title="My updated snippet" -F file=@foo.txt
		 *
		 *         PUT /2.0/snippets/evzijst/kypj HTTP/1.1
		 *         Content-Length: 351
		 *         Content-Type: multipart/form-data; boundary=----------------------------63a4b224c59f
		 *
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: form-data; name="file"; filename="foo.txt"
		 *         Content-Type: text/plain
		 *
		 *         foo
		 *
		 *         ------------------------------63a4b224c59f
		 *         Content-Disposition: form-data; name="title"
		 *
		 *         My updated snippet
		 *         ------------------------------63a4b224c59f
		 *
		 *     To delete a file, omit its contents while including its name in the
		 *     `files` field:
		 *
		 *         $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files=image.png
		 *
		 *         PUT /2.0/snippets/evzijst/kypj HTTP/1.1
		 *         Content-Length: 149
		 *         Content-Type: multipart/form-data; boundary=----------------------------ef8871065a86
		 *
		 *         ------------------------------ef8871065a86
		 *         Content-Disposition: form-data; name="files"
		 *
		 *         image.png
		 *         ------------------------------ef8871065a86--
		 *
		 *     The explicit use of the `files` element in `multipart/related` and
		 *     `multipart/form-data` is only required when deleting files.
		 *     The default mode of operation is for file parts to be processed,
		 *     regardless of whether or not they are listed in `files`, as a
		 *     convenience to the client.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The updated snippet object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet"]
						readonly "multipart/form-data": components["schemas"]["snippet"]
						readonly "multipart/related": components["schemas"]["snippet"]
					}
				}
				/** @description If the snippet is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If authenticated user does not have permission to update the private snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a snippet
		 * @description Deletes a snippet and returns an empty response.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the snippet was deleted successfully. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the snippet is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If authenticated user does not have permission to delete the private snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/{node_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description A commit revision (SHA1). */
				readonly node_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a previous revision of a snippet
		 * @description Identical to `GET /snippets/encoded_id`, except that this endpoint
		 *     can be used to retrieve the contents of the snippet as it was at an
		 *     older revision, while `/snippets/encoded_id` always returns the
		 *     snippet's current revision.
		 *
		 *     Note that only the snippet's file contents are versioned, not its
		 *     meta data properties like the title.
		 *
		 *     Other than that, the two endpoints are identical in behavior.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description A commit revision (SHA1). */
					readonly node_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The snippet object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet"]
						readonly "multipart/form-data": components["schemas"]["snippet"]
						readonly "multipart/related": components["schemas"]["snippet"]
					}
				}
				/** @description If the snippet is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If authenticated user does not have access to the private snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If the snippet, or the revision does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a previous revision of a snippet
		 * @description Identical to `UPDATE /snippets/encoded_id`, except that this endpoint
		 *     takes an explicit commit revision. Only the snippet's "HEAD"/"tip"
		 *     (most recent) version can be updated and requests on all other,
		 *     older revisions fail by returning a 405 status.
		 *
		 *     Usage of this endpoint over the unrestricted `/snippets/encoded_id`
		 *     could be desired if the caller wants to be sure no concurrent
		 *     modifications have taken place between the moment of the UPDATE
		 *     request and the original GET.
		 *
		 *     This can be considered a so-called "Compare And Swap", or CAS
		 *     operation.
		 *
		 *     Other than that, the two endpoints are identical in behavior.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description A commit revision (SHA1). */
					readonly node_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The updated snippet object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet"]
						readonly "multipart/form-data": components["schemas"]["snippet"]
						readonly "multipart/related": components["schemas"]["snippet"]
					}
				}
				/** @description If the snippet is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If authenticated user does not have permission to update the private snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If the snippet or the revision does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
				/** @description If `{node_id}` is not the latest revision. */
				readonly 405: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
						readonly "multipart/form-data": components["schemas"]["error"]
						readonly "multipart/related": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a previous revision of a snippet
		 * @description Deletes the snippet.
		 *
		 *     Note that this only works for versioned URLs that point to the latest
		 *     commit of the snippet. Pointing to an older commit results in a 405
		 *     status code.
		 *
		 *     To delete a snippet, regardless of whether or not concurrent changes
		 *     are being made to it, use `DELETE /snippets/{encoded_id}` instead.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description A commit revision (SHA1). */
					readonly node_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the snippet was deleted successfully. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the snippet is private and the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If authenticated user does not have permission to delete the private snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If `{node_id}` is not the latest revision. */
				readonly 405: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/{node_id}/files/{path}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description A commit revision (SHA1). */
				readonly node_id: string
				/** @description Path to the file. */
				readonly path: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a snippet's raw file
		 * @description Retrieves the raw contents of a specific file in the snippet. The
		 *     `Content-Disposition` header will be "attachment" to avoid issues with
		 *     malevolent executable files.
		 *
		 *     The file's mime type is derived from its filename and returned in the
		 *     `Content-Type` header.
		 *
		 *     Note that for text files, no character encoding is included as part of
		 *     the content type.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description A commit revision (SHA1). */
					readonly node_id: string
					/** @description Path to the file. */
					readonly path: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Returns the contents of the specified file. */
				readonly 200: {
					headers: {
						/** @description attachment */
						readonly "Content-Disposition"?: string
						/** @description The mime type as derived from the filename */
						readonly "Content-Type"?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the file or snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/{revision}/diff": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`. */
				readonly revision: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get snippet changes between versions
		 * @description Returns the diff of the specified commit against its first parent.
		 *
		 *     Note that this resource is different in functionality from the `patch`
		 *     resource.
		 *
		 *     The differences between a diff and a patch are:
		 *
		 *     * patches have a commit header with the username, message, etc
		 *     * diffs support the optional `path=foo/bar.py` query param to filter the
		 *       diff to just that one file diff (not supported for patches)
		 *     * for a merge, the diff will show the diff between the merge commit and
		 *       its first parent (identical to how PRs work), while patch returns a
		 *       response containing separate patches for each commit on the second
		 *       parent's ancestry, up to the oldest common ancestor (identical to
		 *       its reachability).
		 *
		 *     Note that the character encoding of the contents of the diff is
		 *     unspecified as Git does not track this, making it hard for
		 *     Bitbucket to reliably determine this.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description When used, only one the diff of the specified file will be returned. */
					readonly path?: string
				}
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`. */
					readonly revision: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The raw diff contents. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/{revision}/patch": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`. */
				readonly revision: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get snippet patch between versions
		 * @description Returns the patch of the specified commit against its first
		 *     parent.
		 *
		 *     Note that this resource is different in functionality from the `diff`
		 *     resource.
		 *
		 *     The differences between a diff and a patch are:
		 *
		 *     * patches have a commit header with the username, message, etc
		 *     * diffs support the optional `path=foo/bar.py` query param to filter the
		 *       diff to just that one file diff (not supported for patches)
		 *     * for a merge, the diff will show the diff between the merge commit and
		 *       its first parent (identical to how PRs work), while patch returns a
		 *       response containing separate patches for each commit on the second
		 *       parent's ancestry, up to the oldest common ancestor (identical to
		 *       its reachability).
		 *
		 *     Note that the character encoding of the contents of the patch is
		 *     unspecified as Git does not track this, making it hard for
		 *     Bitbucket to reliably determine this.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`. */
					readonly revision: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The raw patch contents. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/comments": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List comments on a snippet
		 * @description Used to retrieve a paginated list of all comments for a specific
		 *     snippet.
		 *
		 *     This resource works identical to commit and pull request comments.
		 *
		 *     The default sorting is oldest to newest and can be overridden with
		 *     the `sort` query parameter.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A paginated list of snippet comments, ordered by creation date. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_snippet_comments"]
					}
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a comment on a snippet
		 * @description Creates a new comment.
		 *
		 *     The only required field in the body is `content.raw`.
		 *
		 *     To create a threaded reply to an existing comment, include `parent.id`.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The contents of the new comment. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["snippet_comment"]
				}
			}
			readonly responses: {
				/** @description The newly created comment. */
				readonly 201: {
					headers: {
						/** @description The URL of the new comment */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["snippet_comment"]
					}
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/comments/{comment_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The id of the comment. */
				readonly comment_id: number
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a comment on a snippet
		 * @description Returns the specific snippet comment.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified comment. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet_comment"]
					}
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment or snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a comment on a snippet
		 * @description Updates a comment.
		 *
		 *     The only required field in the body is `content.raw`.
		 *
		 *     Comments can only be updated by their author.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			/** @description The contents to update the comment to. */
			readonly requestBody: {
				readonly content: {
					readonly "application/json": components["schemas"]["snippet_comment"]
				}
			}
			readonly responses: {
				/** @description The updated comment object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet_comment"]
					}
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment or snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a comment on a snippet
		 * @description Deletes a snippet comment.
		 *
		 *     Comments can only be removed by the comment author, snippet creator, or workspace admin.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The id of the comment. */
					readonly comment_id: number
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates the comment was deleted successfully. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user is not the author of the comment. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the comment or the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/commits": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List snippet changes
		 * @description Returns the changes (commits) made on this snippet.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The paginated list of snippet commits. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_snippet_commit"]
					}
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/commits/{revision}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description The commit's SHA1. */
				readonly revision: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a previous snippet change
		 * @description Returns the changes made on this snippet in this commit.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description The commit's SHA1. */
					readonly revision: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified snippet commit. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["snippet_commit"]
					}
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the commit or the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/files/{path}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description Path to the file. */
				readonly path: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a snippet's raw file at HEAD
		 * @description Convenience resource for getting to a snippet's raw files without the
		 *     need for first having to retrieve the snippet itself and having to pull
		 *     out the versioned file links.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description Path to the file. */
					readonly path: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A redirect to the most recent revision of the specified file. */
				readonly 302: {
					headers: {
						/** @description The URL of the most recent file revision. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content?: never
				}
				/** @description If the authenticated user does not have access to the snippet. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/watch": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Check if the current user is watching a snippet
		 * @description Used to check if the current user is watching a specific snippet.
		 *
		 *     Returns 204 (No Content) if the user is watching the snippet and 404 if
		 *     not.
		 *
		 *     Hitting this endpoint anonymously always returns a 404.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the authenticated user is watching the snippet. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the snippet does not exist, or if the authenticated user is not watching the snippet. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Watch a snippet
		 * @description Used to start watching a specific snippet. Returns 204 (No Content).
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates the authenticated user is now watching the snippet. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Stop watching a snippet
		 * @description Used to stop watching a specific snippet. Returns 204 (No Content)
		 *     to indicate success.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Indicates the user stopped watching the snippet successfully. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the request was not authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/snippets/{workspace}/{encoded_id}/watchers": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The snippet id. */
				readonly encoded_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List users watching a snippet
		 * @deprecated
		 * @description Returns a paginated list of all users watching a specific snippet.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The snippet id. */
					readonly encoded_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The paginated list of users watching this snippet */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_accounts"]
					}
				}
				/** @description If the snippet does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/teams/{username}/pipelines_config/variables": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List variables for an account
		 * @deprecated
		 * @description Find account level variables.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly get: operations["getPipelineVariablesForTeam"]
		readonly put?: never
		/**
		 * Create a variable for a user
		 * @deprecated
		 * @description Create an account level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly post: operations["createPipelineVariableForTeam"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/teams/{username}/pipelines_config/variables/{variable_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a variable for a team
		 * @deprecated
		 * @description Retrieve a team level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly get: operations["getPipelineVariableForTeam"]
		/**
		 * Update a variable for a team
		 * @deprecated
		 * @description Update a team level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly put: operations["updatePipelineVariableForTeam"]
		readonly post?: never
		/**
		 * Delete a variable for a team
		 * @deprecated
		 * @description Delete a team level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly delete: operations["deletePipelineVariableForTeam"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/teams/{username}/search/code": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Search for code in a team's repositories
		 * @description Search for code in the repositories of the specified team.
		 *
		 *     Note that searches can match in the file's text (`content_matches`),
		 *     the path (`path_matches`), or both.
		 *
		 *     You can use the same syntax for the search query as in the UI.
		 *     E.g. to search for "foo" only within the repository "demo",
		 *     use the query parameter `search_query=foo+repo:demo`.
		 *
		 *     Similar to other APIs, you can request more fields using a
		 *     `fields` query parameter. E.g. to get some more information about
		 *     the repository of matched files, use the query parameter
		 *     `search_query=foo&fields=%2Bvalues.file.commit.repository`
		 *     (the `%2B` is a URL-encoded `+`).
		 *
		 *     Try `fields=%2Bvalues.*.*.*.*` to get an idea what's possible.
		 *
		 */
		readonly get: operations["searchTeam"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/user": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get current user
		 * @description Returns the currently logged in user.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The current user. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["account"]
					}
				}
				/** @description When the request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/user/emails": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List email addresses for current user
		 * @description Returns all the authenticated user's email addresses. Both
		 *     confirmed and unconfirmed.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Unexpected error. */
				readonly default: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/user/emails/{email}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Email address of the user. */
				readonly email: string
			}
			readonly cookie?: never
		}
		/**
		 * Get an email address for current user
		 * @description Returns details about a specific one of the authenticated user's
		 *     email addresses.
		 *
		 *     Details describe whether the address has been confirmed by the user and
		 *     whether it is the user's primary address or not.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Email address of the user. */
					readonly email: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Unexpected error. */
				readonly default: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/user/permissions/repositories": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List repository permissions for a user
		 * @description Returns an object for each repository the caller has explicit access
		 *     to and their effective permission  the highest level of permission the
		 *     caller has. This does not return public repositories that the user was
		 *     not granted any specific permission in, and does not distinguish between
		 *     explicit and implicit privileges.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 *
		 *     Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by
		 *     repository or permission by adding the following query string
		 *     parameters:
		 *
		 *     * `q=repository.name="geordi"` or `q=permission>"read"`
		 *     * `sort=repository.name`
		 *
		 *     Note that the query parameter values need to be URL escaped so that `=`
		 *     would become `%3D`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     Name of a response property sort the result by as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly sort?: string
				}
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Repository permissions for the repositories a caller has explicit access to. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repository_permissions"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/user/permissions/workspaces": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List workspaces for the current user
		 * @description Returns an object for each workspace the caller is a member of, and
		 *     their effective role - the highest level of privilege the caller has.
		 *     If a user is a member of multiple groups with distinct roles, only the
		 *     highest level is returned.
		 *
		 *     Permissions can be:
		 *
		 *     * `owner`
		 *     * `collaborator`
		 *     * `member`
		 *
		 *     **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information,
		 *     see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**
		 *
		 *     **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on
		 *     `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the
		 *     [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**
		 *
		 *     Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by
		 *     workspace or permission by adding the following query string parameters:
		 *
		 *     * `q=workspace.slug="bbworkspace1"` or `q=permission="owner"`
		 *     * `sort=workspace.slug`
		 *
		 *     Note that the query parameter values need to be URL escaped so that `=`
		 *     would become `%3D`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details. */
					readonly q?: string
					/** @description
					 *     Name of a response property to sort results. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results)
					 *     for details.
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description All of the workspace memberships for the authenticated user. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_workspace_memberships"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be an Atlassian Account ID OR the UUID of the account,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a user
		 * @description Gets the public information associated with a user account.
		 *
		 *     If the user's profile is private, `location`, `website` and
		 *     `created_on` elements are omitted.
		 *
		 *     Note that the user object returned by this operation is changing significantly, due to privacy changes.
		 *     See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The user object */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["account"]
					}
				}
				/** @description If no user exists for the specified UUID, or if the specified account is a team account, not a personal account. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/gpg-keys": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be an Atlassian Account ID OR the UUID of the account,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		/**
		 * List GPG keys
		 * @description Returns a paginated list of the user's GPG public keys.
		 *     The `key` and `subkeys` fields can also be requested from the endpoint.
		 *     See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A list of the GPG keys associated with the account. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_gpg_user_keys"]
					}
				}
				/** @description If the specified user's keys are not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Add a new GPG key
		 * @description Adds a new GPG public key to the specified user account and returns the resulting key.
		 *
		 *     Example:
		 *
		 *     ```
		 *     $ curl -X POST -H "Content-Type: application/json" -d
		 *     '{"key": "<insert GPG Key>"}'
		 *     https://api.bitbucket.org/2.0/users/{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}/gpg-keys
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			/** @description The new GPG key object. */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["GPG_account_key"]
				}
			}
			readonly responses: {
				/** @description The newly created GPG key. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["GPG_account_key"]
					}
				}
				/** @description If the submitted key or related value is invalid */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the current user does not have permission to add a key for the specified user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/gpg-keys/{fingerprint}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description A GPG key fingerprint.
				 *      */
				readonly fingerprint: string
				/** @description This can either be an Atlassian Account ID OR the UUID of the account,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a GPG key
		 * @description Returns a specific GPG public key belonging to a user.
		 *     The `key` and `subkeys` fields can also be requested from the endpoint.
		 *     See [Partial Responses](/cloud/bitbucket/rest/intro/#partial-response) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description A GPG key fingerprint.
					 *      */
					readonly fingerprint: string
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specific GPG key matching the user and fingerprint. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["GPG_account_key"]
					}
				}
				/** @description If the specified user's keys are not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a GPG key
		 * @description Deletes a specific GPG public key from a user's account.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description A GPG key fingerprint.
					 *      */
					readonly fingerprint: string
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The key has been deleted */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the submitted key or related value is invalid */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the current user does not have permission to delete a key for the specified user, or the submitted key is a subkey */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/pipelines_config/variables": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List variables for a user
		 * @deprecated
		 * @description Find user level variables.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly get: operations["getPipelineVariablesForUser"]
		readonly put?: never
		/**
		 * Create a variable for a user
		 * @deprecated
		 * @description Create a user level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly post: operations["createPipelineVariableForUser"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/pipelines_config/variables/{variable_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a variable for a user
		 * @deprecated
		 * @description Retrieve a user level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly get: operations["getPipelineVariableForUser"]
		/**
		 * Update a variable for a user
		 * @deprecated
		 * @description Update a user level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly put: operations["updatePipelineVariableForUser"]
		readonly post?: never
		/**
		 * Delete a variable for a user
		 * @deprecated
		 * @description Delete an account level variable.
		 *     This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
		 */
		readonly delete: operations["deletePipelineVariableForUser"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/properties/{app_key}/{property_name}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get a user application property
		 * @description Retrieve an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
		 */
		readonly get: operations["retrieveUserHostedPropertyValue"]
		/**
		 * Update a user application property
		 * @description Update an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
		 */
		readonly put: operations["updateUserHostedPropertyValue"]
		readonly post?: never
		/**
		 * Delete a user application property
		 * @description Delete an [application property](/cloud/bitbucket/application-properties/) value stored against a user.
		 */
		readonly delete: operations["deleteUserHostedPropertyValue"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/search/code": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Search for code in a user's repositories
		 * @description Search for code in the repositories of the specified user.
		 *
		 *     Note that searches can match in the file's text (`content_matches`),
		 *     the path (`path_matches`), or both.
		 *
		 *     You can use the same syntax for the search query as in the UI.
		 *     E.g. to search for "foo" only within the repository "demo",
		 *     use the query parameter `search_query=foo+repo:demo`.
		 *
		 *     Similar to other APIs, you can request more fields using a
		 *     `fields` query parameter. E.g. to get some more information about
		 *     the repository of matched files, use the query parameter
		 *     `search_query=foo&fields=%2Bvalues.file.commit.repository`
		 *     (the `%2B` is a URL-encoded `+`).
		 *
		 */
		readonly get: operations["searchAccount"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/ssh-keys": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be an Atlassian Account ID OR the UUID of the account,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		/**
		 * List SSH keys
		 * @description Returns a paginated list of the user's SSH public keys.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description A list of the SSH keys associated with the account. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_ssh_user_keys"]
					}
				}
				/** @description If the specified user's keys are not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Add a new SSH key
		 * @description Adds a new SSH public key to the specified user account and returns the resulting key.
		 *
		 *     Example:
		 *
		 *     ```
		 *     $ curl -X POST -H "Content-Type: application/json" -d '{"key": "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost"}' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			/** @description The new SSH key object. Note that the username property has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["ssh_account_key"]
				}
			}
			readonly responses: {
				/** @description The newly created SSH key. */
				readonly 201: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["ssh_account_key"]
					}
				}
				/** @description If the submitted key or related value is invalid */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the current user does not have permission to add a key for the specified user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/users/{selected_user}/ssh-keys/{key_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The SSH key's UUID value. */
				readonly key_id: string
				/** @description This can either be an Atlassian Account ID OR the UUID of the account,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a SSH key
		 * @description Returns a specific SSH public key belonging to a user.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The SSH key's UUID value. */
					readonly key_id: string
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specific SSH key matching the user and UUID */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["ssh_account_key"]
					}
				}
				/** @description If the specified user or key is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user or key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a SSH key
		 * @description Updates a specific SSH public key on a user's account
		 *
		 *     Note: Only the 'comment' field can be updated using this API. To modify the key or comment values, you must delete and add the key again.
		 *
		 *     Example:
		 *
		 *     ```
		 *     $ curl -X PUT -H "Content-Type: application/json" -d '{"label": "Work key"}' https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a}
		 *     ```
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The SSH key's UUID value. */
					readonly key_id: string
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			/** @description The updated SSH key object */
			readonly requestBody?: {
				readonly content: {
					readonly "application/json": components["schemas"]["ssh_account_key"]
				}
			}
			readonly responses: {
				/** @description The newly updated SSH key. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["ssh_account_key"]
					}
				}
				/** @description If the submitted key or related value is invalid */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the current user does not have permission to add a key for the specified user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a SSH key
		 * @description Deletes a specific SSH public key from a user's account.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The SSH key's UUID value. */
					readonly key_id: string
					/** @description This can either be an Atlassian Account ID OR the UUID of the account,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The key has been deleted */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the submitted key or related value is invalid */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the current user does not have permission to add a key for the specified user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List workspaces for user
		 * @description Returns a list of workspaces accessible by the authenticated user.
		 *
		 *     Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by
		 *     workspace or permission by adding the following query string parameters:
		 *
		 *     * `q=slug="bbworkspace1"` or `q=is_private=true`
		 *     * `sort=created_on`
		 *
		 *     Note that the query parameter values need to be URL escaped so that `=`
		 *     would become `%3D`.
		 *
		 *     **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information,
		 *     see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for details. */
					readonly q?: string
					/** @description
					 *                 Filters the workspaces based on the authenticated user's role on each workspace.
					 *
					 *                 * **member**: returns a list of all the workspaces which the caller is a member of
					 *                     at least one workspace group or repository
					 *                 * **collaborator**: returns a list of workspaces which the caller has write access
					 *                     to at least one repository in the workspace
					 *                 * **owner**: returns a list of workspaces which the caller has administrator access
					 *                  */
					readonly role?: "collaborator" | "member" | "owner"
					/** @description
					 *     Name of a response property to sort results. See
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results)
					 *     for details.
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path?: never
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The list of workspaces accessible by the authenticated user. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_workspaces"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a workspace
		 * @description Returns the requested workspace.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The workspace. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["workspace"]
					}
				}
				/** @description If no workspace exists for the specified name or UUID. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/hooks": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List webhooks for a workspace
		 * @description Returns a paginated list of webhooks installed on this workspace.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The paginated list of installed webhooks. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_webhook_subscriptions"]
					}
				}
				/** @description If the authenticated user is not an owner on the specified workspace. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a webhook for a workspace
		 * @description Creates a new webhook on the specified workspace.
		 *
		 *     Workspace webhooks are fired for events from all repositories contained
		 *     by that workspace.
		 *
		 *     Example:
		 *
		 *     ```
		 *     $ curl -X POST -u credentials -H 'Content-Type: application/json'
		 *       https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks
		 *       -d '
		 *         {
		 *           "description": "Webhook Description",
		 *           "url": "https://example.com/",
		 *           "active": true,
		 *           "secret": "this is a really bad secret",
		 *           "events": [
		 *             "repo:push",
		 *             "issue:created",
		 *             "issue:updated"
		 *           ]
		 *         }'
		 *     ```
		 *
		 *     When the `secret` is provided it will be used as the key to generate a HMAC
		 *     digest value sent in the `X-Hub-Signature` header at delivery time. Passing
		 *     a `null` or empty `secret` or not passing a `secret` will leave the webhook's
		 *     secret unset. Bitbucket only generates the `X-Hub-Signature` when the webhook's
		 *     secret is set.
		 *
		 *     This call requires the webhook scope, as well as any scope
		 *     that applies to the events that the webhook subscribes to. In the
		 *     example above that means: `webhook`, `repository` and `issue`.
		 *
		 *     The `url` must properly resolve and cannot be an internal, non-routed address.
		 *
		 *     Only workspace owners can install webhooks on workspaces.
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description If the webhook was registered successfully. */
				readonly 201: {
					headers: {
						/** @description The URL of new newly created webhook. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["webhook_subscription"]
					}
				}
				/** @description If the authenticated user does not have permission to install webhooks on the specified workspace. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/hooks/{uid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Installed webhook's ID */
				readonly uid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a webhook for a workspace
		 * @description Returns the webhook with the specified id installed on the given
		 *     workspace.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Installed webhook's ID */
					readonly uid: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The webhook subscription object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["webhook_subscription"]
					}
				}
				/** @description If the webhook or workspace does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a webhook for a workspace
		 * @description Updates the specified webhook subscription.
		 *
		 *     The following properties can be mutated:
		 *
		 *     * `description`
		 *     * `url`
		 *     * `secret`
		 *     * `active`
		 *     * `events`
		 *
		 *     The hook's secret is used as a key to generate the HMAC hex digest sent in the
		 *     `X-Hub-Signature` header at delivery time. This signature is only generated
		 *     when the hook has a secret.
		 *
		 *     Set the hook's secret by passing the new value in the `secret` field. Passing a
		 *     `null` value in the `secret` field will remove the secret from the hook. The
		 *     hook's secret can be left unchanged by not passing the `secret` field in the
		 *     request.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Installed webhook's ID */
					readonly uid: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The webhook subscription object. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["webhook_subscription"]
					}
				}
				/** @description If the authenticated user does not have permission to update the webhook. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the webhook or workspace does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a webhook for a workspace
		 * @description Deletes the specified webhook subscription from the given workspace.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Installed webhook's ID */
					readonly uid: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description When the webhook was deleted successfully */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the authenticated user does not have permission to delete the webhook. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the webhook or workspace does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/members": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List users in a workspace
		 * @description Returns all members of the requested workspace.
		 *
		 *     This endpoint additionally supports [filtering](/cloud/bitbucket/rest/intro/#filtering) by
		 *     email address, if called by a workspace administrator, integration or workspace access
		 *     token. This is done by adding the following query string parameter:
		 *
		 *     * `q=user.email IN ("user1@org.com","user2@org.com")`
		 *
		 *     When filtering by email, you can query up to 90 addresses at a time.
		 *     Note that the query parameter values need to be URL escaped, so the final query string
		 *     should be:
		 *
		 *     * `q=user.email%20IN%20(%22user1@org.com%22,%22user2@org.com%22)`
		 *
		 *     Email addresses that you filter by (and only these email addresses) can be included in the
		 *     response using the `fields` query parameter:
		 *
		 *     * `&fields=+values.user.email` - add the `email` field to the default `user` response object
		 *     * `&fields=values.user.email,values.user.account_id` - only return user email addresses and
		 *     account IDs
		 *
		 *     Once again, all query parameter values must be URL escaped.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The list of users that are part of a workspace. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_workspace_memberships"]
					}
				}
				/** @description When more than 90 emails were provided when querying by email. */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/members/{member}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Member's UUID or Atlassian ID. */
				readonly member: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get user membership for a workspace
		 * @description Returns the workspace membership, which includes
		 *     a `User` object for the member and a `Workspace` object
		 *     for the requested workspace.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Member's UUID or Atlassian ID. */
					readonly member: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The user that is part of a workspace. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["workspace_membership"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description A workspace cannot be found, or a user cannot be found, or the user is not a a member of the workspace. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/permissions": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List user permissions in a workspace
		 * @description Returns the list of members in a workspace
		 *     and their permission levels.
		 *     Permission can be:
		 *     * `owner`
		 *     * `collaborator`
		 *     * `member`
		 *
		 *     **The `collaborator` role is being removed from the Bitbucket Cloud API. For more information,
		 *     see the [deprecation announcement](/cloud/bitbucket/deprecation-notice-collaborator-role/).**
		 *
		 *     **When you move your administration from Bitbucket Cloud to admin.atlassian.com, the following fields on
		 *     `workspace_membership` will no longer be present: `last_accessed` and `added_on`. See the
		 *     [deprecation announcement](/cloud/bitbucket/announcement-breaking-change-workspace-membership/).**
		 *
		 *     Results may be further [filtered](/cloud/bitbucket/rest/intro/#filtering) by
		 *     permission by adding the following query string parameters:
		 *
		 *     * `q=permission="owner"`
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The list of users that are part of a workspace, along with their permission. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_workspace_memberships"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/permissions/repositories": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List all repository permissions for a workspace
		 * @description Returns an object for each repository permission for all of a
		 *     workspace's repositories.
		 *
		 *     Permissions returned are effective permissions: the highest level of
		 *     permission the user has. This does not distinguish between direct and
		 *     indirect (group) privileges.
		 *
		 *     Only users with admin permission for the team may access this resource.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 *
		 *     Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering)
		 *     by repository, user, or permission by adding the following query string
		 *     parameters:
		 *
		 *     * `q=repository.name="geordi"` or `q=permission>"read"`
		 *     * `sort=user.display_name`
		 *
		 *     Note that the query parameter values need to be URL escaped so that `=`
		 *     would become `%3D`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     Name of a response property sort the result by as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description List of workspace's repository permissions. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repository_permissions"]
					}
				}
				/** @description The requesting user isn't an admin of the workspace. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/permissions/repositories/{repo_slug}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the repository slug or the UUID of the repository,
				 *     surrounded by curly-braces, for example: `{repository UUID}`.
				 *      */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List a repository permissions for a workspace
		 * @description Returns an object for the repository permission of each user in the
		 *     requested repository.
		 *
		 *     Permissions returned are effective permissions: the highest level of
		 *     permission the user has. This does not distinguish between direct and
		 *     indirect (group) privileges.
		 *
		 *     Only users with admin permission for the repository may access this resource.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `write`
		 *     * `read`
		 *
		 *     Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering)
		 *     by user, or permission by adding the following query string parameters:
		 *
		 *     * `q=permission>"read"`
		 *     * `sort=user.display_name`
		 *
		 *     Note that the query parameter values need to be URL escaped so that `=`
		 *     would become `%3D`.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description
					 *     Query string to narrow down the response as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). */
					readonly q?: string
					/** @description
					 *     Name of a response property sort the result by as per
					 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).
					 *      */
					readonly sort?: string
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the repository slug or the UUID of the repository,
					 *     surrounded by curly-braces, for example: `{repository UUID}`.
					 *      */
					readonly repo_slug: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The repository permission for all users in this repository. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_repository_permissions"]
					}
				}
				/** @description The requesting user isn't an admin of the repository. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/pipelines-config/identity/oidc/.well-known/openid-configuration": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get OpenID configuration for OIDC in Pipelines
		 * @description This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
		 */
		readonly get: operations["getOIDCConfiguration"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/pipelines-config/identity/oidc/keys.json": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get keys for OIDC in Pipelines
		 * @description This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
		 */
		readonly get: operations["getOIDCKeys"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/pipelines-config/variables": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * List variables for a workspace
		 * @description Find workspace level variables.
		 */
		readonly get: operations["getPipelineVariablesForWorkspace"]
		readonly put?: never
		/**
		 * Create a variable for a workspace
		 * @description Create a workspace level variable.
		 */
		readonly post: operations["createPipelineVariableForWorkspace"]
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Get variable for a workspace
		 * @description Retrieve a workspace level variable.
		 */
		readonly get: operations["getPipelineVariableForWorkspace"]
		/**
		 * Update variable for a workspace
		 * @description Update a workspace level variable.
		 */
		readonly put: operations["updatePipelineVariableForWorkspace"]
		readonly post?: never
		/**
		 * Delete a variable for a workspace
		 * @description Delete a workspace level variable.
		 */
		readonly delete: operations["deletePipelineVariableForWorkspace"]
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List projects in a workspace
		 * @description Returns the list of projects in this workspace.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The list of projects in this workspace. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_projects"]
					}
				}
				/** @description A workspace doesn't exist at this location. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a project in a workspace
		 * @description Creates a new project.
		 *
		 *     Note that the avatar has to be embedded as either a data-url
		 *     or a URL to an external image as shown in the examples below:
		 *
		 *     ```
		 *     $ body=$(cat << EOF
		 *     {
		 *         "name": "Mars Project",
		 *         "key": "MARS",
		 *         "description": "Software for colonizing mars.",
		 *         "links": {
		 *             "avatar": {
		 *                 "href": "data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/..."
		 *             }
		 *         },
		 *         "is_private": false
		 *     }
		 *     EOF
		 *     )
		 *     $ curl -H "Content-Type: application/json" \
		 *            -X POST \
		 *            -d "$body" \
		 *            https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq .
		 *     {
		 *       // Serialized project document
		 *     }
		 *     ```
		 *
		 *     or even:
		 *
		 *     ```
		 *     $ body=$(cat << EOF
		 *     {
		 *         "name": "Mars Project",
		 *         "key": "MARS",
		 *         "description": "Software for colonizing mars.",
		 *         "links": {
		 *             "avatar": {
		 *                 "href": "http://i.imgur.com/72tRx4w.gif"
		 *             }
		 *         },
		 *         "is_private": false
		 *     }
		 *     EOF
		 *     )
		 *     $ curl -H "Content-Type: application/json" \
		 *            -X POST \
		 *            -d "$body" \
		 *            https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq .
		 *     {
		 *       // Serialized project document
		 *     }
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["project"]
			readonly responses: {
				/** @description A new project has been created. */
				readonly 201: {
					headers: {
						/** @description The location of the newly created project */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["project"]
					}
				}
				/** @description The user requesting to create a project does not have the necessary permissions. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description A workspace doesn't exist at this location. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual `key` assigned
				 *     to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a project for a workspace
		 * @description Returns the requested project.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The project that is part of a workspace. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project"]
					}
				}
				/** @description The request wasn't authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't authorized to access the project. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description A project isn't hosted at this location. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update a project for a workspace
		 * @description Since this endpoint can be used to both update and to create a
		 *     project, the request body depends on the intent.
		 *
		 *     #### Creation
		 *
		 *     See the POST documentation for the project collection for an
		 *     example of the request body.
		 *
		 *     Note: The `key` should not be specified in the body of request
		 *     (since it is already present in the URL). The `name` is required,
		 *     everything else is optional.
		 *
		 *     #### Update
		 *
		 *     See the POST documentation for the project collection for an
		 *     example of the request body.
		 *
		 *     Note: The key is not required in the body (since it is already in
		 *     the URL). The key may be specified in the body, if the intent is
		 *     to change the key itself. In such a scenario, the location of the
		 *     project is changed and is returned in the `Location` header of the
		 *     response.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["project"]
			readonly responses: {
				/** @description The existing project is has been updated. */
				readonly 200: {
					headers: {
						/** @description The location of the project. This header is only provided
						 *     when the project key is updated. */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["project"]
					}
				}
				/** @description A new project has been created. */
				readonly 201: {
					headers: {
						/** @description The location of the newly created project */
						readonly Location?: string
						readonly [name: string]: unknown
					}
					content: {
						readonly "application/json": components["schemas"]["project"]
					}
				}
				/** @description The requesting user isn't authorized to update or create the project. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description A workspace doesn't exist at the location. Note that the project's absence from this location doesn't raise a 404, since a PUT at a non-existent location can be used to create a new project. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete a project for a workspace
		 * @description Deletes this project. This is an irreversible operation.
		 *
		 *     You cannot delete a project that still contains repositories.
		 *     To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete)
		 *     or transfer the repositories first.
		 *
		 *     Example:
		 *     ```
		 *     $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ
		 *     ```
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Successful deletion. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The requesting user isn't authorized to delete the project or the project isn't empty. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description A project isn't hosted at this location. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/branching-model": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual `key` assigned
				 *     to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the branching model for a project
		 * @description Return the branching model set at the project level. This view is
		 *     read-only. The branching model settings can be changed using the
		 *     [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get)
		 *     API.
		 *
		 *     The returned object:
		 *
		 *     1. Always has a `development` property. `development.name` is
		 *        the user-specified branch that can be inherited by an individual repository's
		 *        branching model.
		 *     2. Might have a `production` property. `production` will not
		 *        be present when `production` is disabled.
		 *        `production.name` is the user-specified branch that can be
		 *        inherited by an individual repository's branching model.
		 *     3. Always has a `branch_types` array which contains all enabled branch
		 *        types.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The branching model object */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_branching_model"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have read access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the project does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/branching-model/settings": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual `key` assigned
				 *     to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get the branching model config for a project
		 * @description Return the branching model configuration for a project. The returned
		 *     object:
		 *
		 *     1. Always has a `development` property for the development branch.
		 *     2. Always a `production` property for the production branch. The
		 *        production branch can be disabled.
		 *     3. The `branch_types` contains all the branch types.
		 *
		 *
		 *     This is the raw configuration for the branching model. A client
		 *     wishing to see the branching model with its actual current branches may find the
		 *     [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get)
		 *     more useful.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The branching model configuration */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branching_model_settings"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the project does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update the branching model config for a project
		 * @description Update the branching model configuration for a project.
		 *
		 *     The `development` branch can be configured to a specific branch or to
		 *     track the main branch. Any branch name can be supplied, but will only
		 *     successfully be applied to a repository via inheritance if that branch
		 *     exists for that repository. Only the passed properties will be updated. The
		 *     properties not passed will be left unchanged. A request without a
		 *     `development` property will leave the development branch unchanged.
		 *
		 *     The `production` branch can be a specific branch, the main
		 *     branch or disabled. Any branch name can be supplied, but will only
		 *     successfully be applied to a repository via inheritance if that branch
		 *     exists for that repository. The `enabled` property can be used to enable (`true`)
		 *     or disable (`false`) it. Only the passed properties will be updated. The
		 *     properties not passed will be left unchanged. A request without a
		 *     `production` property will leave the production branch unchanged.
		 *
		 *     The `branch_types` property contains the branch types to be updated.
		 *     Only the branch types passed will be updated. All updates will be
		 *     rejected if it would leave the branching model in an invalid state.
		 *     For branch types this means that:
		 *
		 *     1. The prefixes for all enabled branch types are valid. For example,
		 *        it is not possible to use '*' inside a Git prefix.
		 *     2. A prefix of an enabled branch type must not be a prefix of another
		 *        enabled branch type. This is to ensure that a branch can be easily
		 *        classified by its prefix unambiguously.
		 *
		 *     It is possible to store an invalid prefix if that branch type would be
		 *     left disabled. Only the passed properties will be updated. The
		 *     properties not passed will be left unchanged. Each branch type must
		 *     have a `kind` property to identify it.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The updated branching model configuration */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["branching_model_settings"]
					}
				}
				/** @description If the request contains an invalid branching model configuration */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the request was not authenticated */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the project does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/default-reviewers": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual `key` assigned
				 *     to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List the default reviewers in a project
		 * @description Return a list of all default reviewers for a project. This is a list of users that will be added as default
		 *     reviewers to pull requests for any repository within the project.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The list of project default reviewers */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_default_reviewer_and_type"]
					}
				}
				/** @description If the authenticated user does not have admin access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the workspace or project does not exist at this location */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This can either be the actual `key` assigned
				 *     to the project or the `UUID` (surrounded by curly-braces (`{}`)).
				 *      */
				readonly project_key: string
				/** @description This can either be the username or the UUID of the default reviewer,
				 *     surrounded by curly-braces, for example: `{account UUID}`.
				 *      */
				readonly selected_user: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a default reviewer
		 * @description Returns the specified default reviewer.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This can either be the actual `key` assigned
					 *     to the project or the `UUID` (surrounded by curly-braces (`{}`)).
					 *      */
					readonly project_key: string
					/** @description This can either be the username or the UUID of the default reviewer,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified user that is a default reviewer */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["user"]
					}
				}
				/** @description If the specified user is not a default reviewer for the project */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified user, project, or workspace does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Add the specific user as a default reviewer for the project
		 * @description Adds the specified user to the project's list of default reviewers. The method is
		 *     idempotent. Accepts an optional body containing the `uuid` of the user to be added.
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This can either be the actual `key` assigned
					 *     to the project or the `UUID` (surrounded by curly-braces (`{}`)).
					 *      */
					readonly project_key: string
					/** @description This can either be the username or the UUID of the default reviewer,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified user was added as a project default reviewer */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["user"]
					}
				}
				/** @description If the specified user cannot be added as a default reviewer for the project */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified user, project, or workspace does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Remove the specific user from the project's default reviewers
		 * @description Removes a default reviewer from the project.
		 *
		 *     Example:
		 *     ```
		 *     $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D
		 *
		 *     HTTP/1.1 204
		 *     ```
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This can either be the actual `key` assigned
					 *     to the project or the `UUID` (surrounded by curly-braces (`{}`)).
					 *      */
					readonly project_key: string
					/** @description This can either be the username or the UUID of the default reviewer,
					 *     surrounded by curly-braces, for example: `{account UUID}`.
					 *      */
					readonly selected_user: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The specified user was removed from the list of project default reviewers */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the specified user is not a default reviewer for the project */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the authenticated user does not have admin access to the project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified user, project, or workspace does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/deploy-keys": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual `key` assigned
				 *     to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List project deploy keys
		 * @description Returns all deploy keys belonging to a project.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Deploy keys matching the project */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_project_deploy_keys"]
					}
				}
				/** @description If the specified workspace or project is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace or project does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		/**
		 * Create a project deploy key
		 * @description Create a new deploy key in a project.
		 *
		 *     Example:
		 *     ```
		 *     $ curl -X POST \
		 *     -H "Authorization <auth header>" \
		 *     -H "Content-type: application/json" \
		 *     https://api.bitbucket.org/2.0/workspaces/standard/projects/TEST_PROJECT/deploy-keys/ -d \
		 *     '{
		 *         "key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8",
		 *         "label": "mydeploykey"
		 *     }'
		 *     ```
		 */
		readonly post: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The project deploy key that was created */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_deploy_key"]
					}
				}
				/** @description Invalid deploy key inputs */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace or project is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace or project does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/deploy-keys/{key_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key ID matching the project deploy key. */
				readonly key_id: string
				/** @description The project in question. This is the actual `key` assigned
				 *     to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get a project deploy key
		 * @description Returns the deploy key belonging to a specific key ID.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The key ID matching the project deploy key. */
					readonly key_id: string
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Project deploy key matching the key ID */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_deploy_key"]
					}
				}
				/** @description If the specified workspace or project is not accessible to the current user */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace or project does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		/**
		 * Delete a deploy key from a project
		 * @description This deletes a deploy key from a project.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The key ID matching the project deploy key. */
					readonly key_id: string
					/** @description The project in question. This is the actual `key` assigned
					 *     to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The project deploy key has been deleted */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description If the current user does not have permission to delete a key for the specified project */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description If the specified workspace, project, or project deploy key does not exist */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/permissions-config/groups": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual key assigned to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List explicit group permissions for a project
		 * @description Returns a paginated list of explicit group permissions for the given project.
		 *     This endpoint does not support BBQL features.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Paginated list of project group permissions */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_project_group_permissions"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user doesn't have admin access to the project. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or both of the workspace and project don't exist for the given identifiers or the requesting user is not authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Slug of the requested group. */
				readonly group_slug: string
				/** @description The project in question. This is the actual key assigned to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get an explicit group permission for a project
		 * @description Returns the group permission for a given group and project.
		 *
		 *     Only users with admin permission for the project may access this resource.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `create-repo`
		 *     * `write`
		 *     * `read`
		 *     * `none`
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Slug of the requested group. */
					readonly group_slug: string
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Project group permission */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_group_permission"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user doesn't have admin access to the project. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, project, and group doesn't exist                               for the given identifiers or the requesting user is not                               authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update an explicit group permission for a project
		 * @description Updates the group permission, or grants a new permission if one does not already exist.
		 *
		 *     Only users with admin permission for the project may access this resource.
		 *
		 *     Due to security concerns, the JWT and OAuth authentication methods are unsupported.
		 *     This is to ensure integrations and add-ons are not allowed to change permissions.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `create-repo`
		 *     * `write`
		 *     * `read`
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Slug of the requested group. */
					readonly group_slug: string
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema"]
			readonly responses: {
				/** @description Project group permission updated. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_group_permission"]
					}
				}
				/** @description No permission value was provided or the value is invalid(not one of read, write, create-repo, or admin). */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description You have reached your plan's user limit and must upgrade before giving access to additional users. */
				readonly 402: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the project, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, project, and group doesn't exist                               for the given identifiers or the requesting user is not                               authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete an explicit group permission for a project
		 * @description Deletes the project group permission between the requested project and group, if one exists.
		 *
		 *     Only users with admin permission for the project may access this resource.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description Slug of the requested group. */
					readonly group_slug: string
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The project group permission was deleted and no content returned. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the project, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, project, and group doesn't exist                               for the given identifiers or the requesting user is not                               authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/permissions-config/users": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual key assigned to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List explicit user permissions for a project
		 * @description Returns a paginated list of explicit user permissions for the given project.
		 *     This endpoint does not support BBQL features.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Paginated list of explicit user permissions. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_project_user_permissions"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user doesn't have admin access to the project. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or both of the workspace and project don't exist for the given identifiers or the requesting user is not authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The project in question. This is the actual key assigned to the project.
				 *      */
				readonly project_key: string
				/** @description This can either be the username, the user's UUID surrounded by curly-braces,
				 *     for example: {account UUID}, or the user's Atlassian ID.
				 *      */
				readonly selected_user_id: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * Get an explicit user permission for a project
		 * @description Returns the explicit user permission for a given user and project.
		 *
		 *     Only users with admin permission for the project may access this resource.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `create-repo`
		 *     * `write`
		 *     * `read`
		 *     * `none`
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the username, the user's UUID surrounded by curly-braces,
					 *     for example: {account UUID}, or the user's Atlassian ID.
					 *      */
					readonly selected_user_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description Explicit user permission for user and project */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_user_permission"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the project. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, project, and selected user doesn't exist for the given identifiers or the requesting user is not authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		/**
		 * Update an explicit user permission for a project
		 * @description Updates the explicit user permission for a given user and project. The selected
		 *     user must be a member of the workspace, and cannot be the workspace owner.
		 *
		 *     Only users with admin permission for the project may access this resource.
		 *
		 *     Due to security concerns, the JWT and OAuth authentication methods are unsupported.
		 *     This is to ensure integrations and add-ons are not allowed to change permissions.
		 *
		 *     Permissions can be:
		 *
		 *     * `admin`
		 *     * `create-repo`
		 *     * `write`
		 *     * `read`
		 */
		readonly put: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the username, the user's UUID surrounded by curly-braces,
					 *     for example: {account UUID}, or the user's Atlassian ID.
					 *      */
					readonly selected_user_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody: components["requestBodies"]["bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema"]
			readonly responses: {
				/** @description Explicit user permission updated */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["project_user_permission"]
					}
				}
				/** @description No permission value was provided or the value is invalid (not one of read, write, create-repo, or admin) */
				readonly 400: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description You have reached your plan's user limit and must upgrade before giving access to additional users. */
				readonly 402: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the project, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, project, and selected user doesn't exist for the given identifiers or the requesting user is not authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly post?: never
		/**
		 * Delete an explicit user permission for a project
		 * @description Deletes the project user permission between the requested project and user, if one exists.
		 *
		 *     Only users with admin permission for the project may access this resource.
		 *
		 *     Due to security concerns, the JWT and OAuth authentication methods are unsupported.
		 *     This is to ensure integrations and add-ons are not allowed to change permissions.
		 */
		readonly delete: {
			readonly parameters: {
				readonly query?: never
				readonly header?: never
				readonly path: {
					/** @description The project in question. This is the actual key assigned to the project.
					 *      */
					readonly project_key: string
					/** @description This can either be the username, the user's UUID surrounded by curly-braces,
					 *     for example: {account UUID}, or the user's Atlassian ID.
					 *      */
					readonly selected_user_id: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description The project user permission was deleted and no content returned. */
				readonly 204: {
					headers: Readonly<Record<string, unknown>>
					content?: never
				}
				/** @description The user couldn't be authenticated. */
				readonly 401: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description The requesting user isn't an admin of the project, or the authentication method was not via app password. */
				readonly 403: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
				/** @description One or more of the workspace, project, and selected user doesn't exist for the given identifiers or the requesting user is not authenticated */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/pullrequests/{selected_user}": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the username of the pull request author, the author's UUID
				 *     surrounded by curly-braces, for example: `{account UUID}`, or the author's Atlassian ID.
				 *      */
				readonly selected_user: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID
				 *     surrounded by curly-braces, for example: `{workspace UUID}`.
				 *      */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/**
		 * List workspace pull requests for a user
		 * @description Returns all workspace pull requests authored by the specified user.
		 *
		 *     By default only open pull requests are returned. This can be controlled
		 *     using the `state` query parameter. To retrieve pull requests that are
		 *     in one of multiple states, repeat the `state` parameter for each
		 *     individual state.
		 *
		 *     This endpoint also supports filtering and sorting of the results. See
		 *     [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
		 */
		readonly get: {
			readonly parameters: {
				readonly query?: {
					/** @description Only return pull requests that are in this state. This parameter can be repeated. */
					readonly state?: "DECLINED" | "MERGED" | "OPEN" | "SUPERSEDED"
				}
				readonly header?: never
				readonly path: {
					/** @description This can either be the username of the pull request author, the author's UUID
					 *     surrounded by curly-braces, for example: `{account UUID}`, or the author's Atlassian ID.
					 *      */
					readonly selected_user: string
					/** @description This can either be the workspace ID (slug) or the workspace UUID
					 *     surrounded by curly-braces, for example: `{workspace UUID}`.
					 *      */
					readonly workspace: string
				}
				readonly cookie?: never
			}
			readonly requestBody?: never
			readonly responses: {
				/** @description All pull requests authored by the specified user. */
				readonly 200: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["paginated_pullrequests"]
					}
				}
				/** @description If the specified user does not exist. */
				readonly 404: {
					headers: Readonly<Record<string, unknown>>
					content: {
						readonly "application/json": components["schemas"]["error"]
					}
				}
			}
		}
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
	readonly "/workspaces/{workspace}/search/code": {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path?: never
			readonly cookie?: never
		}
		/**
		 * Search for code in a workspace
		 * @description Search for code in the repositories of the specified workspace.
		 *
		 *     Note that searches can match in the file's text (`content_matches`),
		 *     the path (`path_matches`), or both.
		 *
		 *     You can use the same syntax for the search query as in the UI.
		 *     E.g. to search for "foo" only within the repository "demo",
		 *     use the query parameter `search_query=foo+repo:demo`.
		 *
		 *     Similar to other APIs, you can request more fields using a
		 *     `fields` query parameter. E.g. to get some more information about
		 *     the repository of matched files, use the query parameter
		 *     `search_query=foo&fields=%2Bvalues.file.commit.repository`
		 *     (the `%2B` is a URL-encoded `+`).
		 *
		 *     Try `fields=%2Bvalues.*.*.*.*` to get an idea what's possible.
		 *
		 */
		readonly get: operations["searchWorkspace"]
		readonly put?: never
		readonly post?: never
		readonly delete?: never
		readonly options?: never
		readonly head?: never
		readonly patch?: never
		readonly trace?: never
	}
}
export type webhooks = Record<string, never>
export interface components {
	schemas: {
		readonly account: {
			readonly type: "account"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly created_on?: string
				readonly display_name?: string
				readonly links?: components["schemas"]["account_links"]
				readonly uuid?: string
			}))
		/**
		 * Account Links
		 * @description Links related to an Account.
		 */
		readonly account_links: Readonly<Record<string, unknown>> & {
			readonly avatar?: components["schemas"]["link"]
		}
		readonly app_user: {
			readonly type: "app_user"
		} & (Omit<components["schemas"]["account"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The user's Atlassian account ID. */
				readonly account_id?: string
				/** @description The status of the account. Currently the only possible value is "active", but more values may be added in the future. */
				readonly account_status?: string
				/** @description The kind of App User. */
				readonly kind?: string
			}))
		/**
		 * Application Property
		 * @description An application property. It is a caller defined JSON object that Bitbucket will store and return.
		 *     The `_attributes` field at its top level can be used to control who is allowed to read and update the property.
		 *     The keys of the JSON object must match an allowed pattern. For details,
		 *     see [Application properties](/cloud/bitbucket/application-properties/).
		 *
		 */
		readonly application_property: Readonly<Record<string, unknown>> & {
			readonly _attributes?: readonly ("public" | "read_only")[]
		}
		readonly author: {
			readonly type: "author"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The raw author value from the repository. This may be the only value available if the author does not match a user in Bitbucket. */
				readonly raw?: string
				readonly user?: components["schemas"]["account"]
			}))
		readonly base_commit: {
			readonly type: "base_commit"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly author?: components["schemas"]["author"]
				readonly committer?: components["schemas"]["committer"]
				/** Format: date-time */
				readonly date?: string
				readonly hash?: string
				readonly message?: string
				readonly parents?: readonly components["schemas"]["base_commit"][]
				readonly summary?: {
					/** @description The user's content rendered as HTML. */
					readonly html?: string
					/**
					 * @description The type of markup language the raw content is to be interpreted in.
					 * @enum {string}
					 */
					readonly markup?: "creole" | "markdown" | "plaintext"
					/** @description The text as it was typed by a user. */
					readonly raw?: string
				}
			}))
		readonly "bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema": {
			/** @enum {string} */
			readonly permission: "admin" | "create-repo" | "read" | "write"
		}
		readonly "bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema": {
			/** @enum {string} */
			readonly permission: "admin" | "read" | "write"
		}
		readonly branch: components["schemas"]["ref"] &
			(Readonly<Record<string, unknown>> & {
				/** @description The default merge strategy for pull requests targeting this branch. */
				readonly default_merge_strategy?: string
				/** @description Available merge strategies for pull requests targeting this branch. */
				readonly merge_strategies?: readonly (
					| "fast_forward"
					| "merge_commit"
					| "rebase_fast_forward"
					| "rebase_merge"
					| "squash_fast_forward"
					| "squash"
				)[]
			})
		readonly branching_model: {
			readonly type: "branching_model"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The active branch types. */
				readonly branch_types?: readonly {
					/**
					 * @description The kind of branch.
					 * @enum {string}
					 */
					readonly kind: "bugfix" | "feature" | "hotfix" | "release"
					/** @description The prefix for this branch type. A branch with this prefix will be classified as per `kind`. The prefix must be a valid prefix for a branch and must always exist. It cannot be blank, empty or `null`. */
					readonly prefix: string
				}[]
				readonly development?: {
					readonly branch?: components["schemas"]["branch"]
					/** @description Name of the target branch. Will be listed here even when the target branch does not exist. Will be `null` if targeting the main branch and the repository is empty. */
					readonly name: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). */
					readonly use_mainbranch: boolean
				}
				readonly production?: {
					readonly branch?: components["schemas"]["branch"]
					/** @description Name of the target branch. Will be listed here even when the target branch does not exist. Will be `null` if targeting the main branch and the repository is empty. */
					readonly name: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). */
					readonly use_mainbranch: boolean
				}
			}))
		readonly branching_model_settings: {
			readonly type: "branching_model_settings"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly branch_types?: readonly {
					/** @description Whether the branch type is enabled or not. A disabled branch type may contain an invalid `prefix`. */
					readonly enabled?: boolean
					/**
					 * @description The kind of the branch type.
					 * @enum {string}
					 */
					readonly kind: "bugfix" | "feature" | "hotfix" | "release"
					/** @description The prefix for this branch type. A branch with this prefix will be classified as per `kind`. The `prefix` of an enabled branch type must be a valid branch prefix.Additionally, it cannot be blank, empty or `null`. The `prefix` for a disabled branch type can be empty or invalid. */
					readonly prefix?: string
				}[]
				readonly development?: {
					/** @description Indicates if the configured branch is valid, that is, if the configured branch actually exists currently. Is always `true` when `use_mainbranch` is `true` (even if the main branch does not exist). This field is read-only. This field is ignored when updating/creating settings. */
					readonly is_valid?: boolean
					/** @description The configured branch. It must be `null` when `use_mainbranch` is `true`. Otherwise it must be a non-empty value. It is possible for the configured branch to not exist (e.g. it was deleted after the settings are set). In this case `is_valid` will be `false`. The branch must exist when updating/setting the `name` or an error will occur. */
					readonly name?: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). When `true` the `name` must be `null` or not provided. When `false` the `name` must contain a non-empty branch name. */
					readonly use_mainbranch?: boolean
				}
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly production?: {
					/** @description Indicates if branch is enabled or not. */
					readonly enabled?: boolean
					/** @description Indicates if the configured branch is valid, that is, if the configured branch actually exists currently. Is always `true` when `use_mainbranch` is `true` (even if the main branch does not exist). This field is read-only. This field is ignored when updating/creating settings. */
					readonly is_valid?: boolean
					/** @description The configured branch. It must be `null` when `use_mainbranch` is `true`. Otherwise it must be a non-empty value. It is possible for the configured branch to not exist (e.g. it was deleted after the settings are set). In this case `is_valid` will be `false`. The branch must exist when updating/setting the `name` or an error will occur. */
					readonly name?: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). When `true` the `name` must be `null` or not provided. When `false` the `name` must contain a non-empty branch name. */
					readonly use_mainbranch?: boolean
				}
			}))
		readonly branchrestriction: {
			readonly type: "branchrestriction"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description Indicates how the restriction is matched against a branch. The default is `glob`.
				 * @enum {string}
				 */
				readonly branch_match_kind: "branching_model" | "glob"
				/**
				 * @description Apply the restriction to branches of this type. Active when `branch_match_kind` is `branching_model`. The branch type will be calculated using the branching model configured for the repository.
				 * @enum {string}
				 */
				readonly branch_type?:
					| "bugfix"
					| "development"
					| "feature"
					| "hotfix"
					| "production"
					| "release"
				readonly groups?: readonly components["schemas"]["group"][]
				/** @description The branch restriction status' id. */
				readonly id?: number
				/**
				 * @description The type of restriction that is being applied.
				 * @enum {string}
				 */
				readonly kind:
					| "allow_auto_merge_when_builds_pass"
					| "delete"
					| "enforce_merge_checks"
					| "force"
					| "push"
					| "require_all_comments_resolved"
					| "require_all_dependencies_merged"
					| "require_approvals_to_merge"
					| "require_commits_behind"
					| "require_default_reviewer_approvals_to_merge"
					| "require_no_changes_requested"
					| "require_passing_builds_to_merge"
					| "require_review_group_approvals_to_merge"
					| "require_tasks_to_be_completed"
					| "reset_pullrequest_approvals_on_change"
					| "reset_pullrequest_changes_requested_on_change"
					| "restrict_merges"
					| "smart_reset_pullrequest_approvals"
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** @description Apply the restriction to branches that match this pattern. Active when `branch_match_kind` is `glob`. Will be empty when `branch_match_kind` is `branching_model`. */
				readonly pattern: string
				readonly users?: readonly components["schemas"]["account"][]
				/** @description Value with kind-specific semantics:
				 *
				 *     * `require_approvals_to_merge` uses it to require a minimum number of approvals on a PR.
				 *
				 *     * `require_default_reviewer_approvals_to_merge` uses it to require a minimum number of approvals from default reviewers on a PR.
				 *
				 *     * `require_passing_builds_to_merge` uses it to require a minimum number of passing builds.
				 *
				 *     * `require_commits_behind` uses it to require the current branch is up to a maximum number of commits behind it destination. */
				readonly value?: number
			}))
		readonly comment: {
			readonly type: "comment"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly content?: {
					/** @description The user's content rendered as HTML. */
					readonly html?: string
					/**
					 * @description The type of markup language the raw content is to be interpreted in.
					 * @enum {string}
					 */
					readonly markup?: "creole" | "markdown" | "plaintext"
					/** @description The text as it was typed by a user. */
					readonly raw?: string
				}
				/** Format: date-time */
				readonly created_on?: string
				readonly deleted?: boolean
				readonly id?: number
				readonly inline?: {
					/** @description The comment's anchor line in the old version of the file. */
					readonly from?: number
					/** @description The path of the file this comment is anchored to. */
					readonly path: string
					/** @description The comment's anchor line in the new version of the file. If the 'from' line is also provided, this value will be removed. */
					readonly to?: number
				}
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly code?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly parent?: components["schemas"]["comment"]
				/** Format: date-time */
				readonly updated_on?: string
				readonly user?: components["schemas"]["account"]
			}))
		/**
		 * Comment Resolution
		 * @description The resolution object for a Comment.
		 */
		readonly comment_resolution: Readonly<Record<string, unknown>> & {
			/**
			 * Format: date-time
			 * @description The ISO8601 timestamp the resolution was created.
			 */
			readonly created_on?: string
			readonly type: string
			readonly user?: components["schemas"]["account"]
		}
		readonly commit: {
			readonly type: "commit"
		} & (Omit<components["schemas"]["base_commit"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly participants?: readonly components["schemas"]["participant"][]
				readonly repository?: components["schemas"]["repository"]
			}))
		readonly commit_comment: {
			readonly type: "commit_comment"
		} & (Omit<components["schemas"]["comment"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly commit?: components["schemas"]["commit"]
			}))
		/**
		 * Commit File
		 * @description A file object, representing a file at a commit in a repository
		 */
		readonly commit_file: Readonly<Record<string, unknown>> & {
			/** @enum {string} */
			readonly attributes?:
				| "binary"
				| "executable"
				| "lfs"
				| "link"
				| "subrepository"
			readonly commit?: components["schemas"]["commit"]
			/** @description The escaped version of the path as it appears in a diff. If the path does not require escaping this will be the same as path. */
			readonly escaped_path?: string
			/** @description The path in the repository */
			readonly path?: string
			readonly type: string
		}
		readonly commitstatus: {
			readonly type: "commitstatus"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly created_on?: string
				/** @description A description of the build (e.g. "Unit tests in Bamboo") */
				readonly description?: string
				/** @description An identifier for the status that's unique to
				 *             its type (current "build" is the only supported type) and the vendor,
				 *             e.g. BB-DEPLOY */
				readonly key?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly commit?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** @description An identifier for the build itself, e.g. BB-DEPLOY-1 */
				readonly name?: string
				/** @description
				 *     The name of the ref that pointed to this commit at the time the status
				 *     object was created. Note that this the ref may since have moved off of
				 *     the commit. This optional field can be useful for build systems whose
				 *     build triggers and configuration are branch-dependent (e.g. a Pipeline
				 *     build).
				 *     It is legitimate for this field to not be set, or even apply (e.g. a
				 *     static linting job). */
				readonly refname?: string
				/**
				 * @description Provides some indication of the status of this commit
				 * @enum {string}
				 */
				readonly state?: "FAILED" | "INPROGRESS" | "STOPPED" | "SUCCESSFUL"
				/** Format: date-time */
				readonly updated_on?: string
				/** @description A URL linking back to the vendor or build system, for providing more information about whatever process produced this status. Accepts context variables `repository` and `commit` that Bitbucket will evaluate at runtime whenever at runtime. For example, one could use https://foo.com/builds/{repository.full_name} which Bitbucket will turn into https://foo.com/builds/foo/bar at render time. */
				readonly url?: string
				/** @description The commit status' id. */
				readonly uuid?: string
			}))
		readonly committer: {
			readonly type: "committer"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The raw committer value from the repository. This may be the only value available if the committer does not match a user in Bitbucket. */
				readonly raw?: string
				readonly user?: components["schemas"]["account"]
			}))
		readonly component: {
			readonly type: "component"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly id?: number
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly name?: string
			}))
		/**
		 * Default Reviewer and Type
		 * @description Object containing a user that is a default reviewer and the type of reviewer
		 */
		readonly default_reviewer_and_type: Readonly<Record<string, unknown>> & {
			readonly reviewer_type?: string
			readonly type: string
			readonly user?: components["schemas"]["user"]
		}
		readonly deploy_key: {
			readonly type: "deploy_key"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly added_on?: string
				/** @description The comment parsed from the deploy key (if present) */
				readonly comment?: string
				/** @description The deploy key value. */
				readonly key?: string
				/** @description The user-defined label for the deploy key */
				readonly label?: string
				/** Format: date-time */
				readonly last_used?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly owner?: components["schemas"]["account"]
				readonly repository?: components["schemas"]["repository"]
			}))
		readonly deployment: {
			readonly type: "deployment"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly environment?: components["schemas"]["deployment_environment"]
				readonly release?: components["schemas"]["deployment_release"]
				readonly state?: components["schemas"]["deployment_state"]
				/** @description The UUID identifying the deployment. */
				readonly uuid?: string
			}))
		readonly deployment_environment: {
			readonly type: "deployment_environment"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The name of the environment. */
				readonly name?: string
				/** @description The UUID identifying the environment. */
				readonly uuid?: string
			}))
		readonly deployment_release: {
			readonly type: "deployment_release"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly commit?: components["schemas"]["commit"]
				/**
				 * Format: date-time
				 * @description The timestamp when the release was created.
				 */
				readonly created_on?: string
				/** @description The name of the release. */
				readonly name?: string
				/**
				 * Format: uri
				 * @description Link to the pipeline that produced the release.
				 */
				readonly url?: string
				/** @description The UUID identifying the release. */
				readonly uuid?: string
			}))
		readonly deployment_state: {
			readonly type: "deployment_state"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly deployment_state_completed: {
			readonly type: "deployment_state_completed"
		} & (Omit<components["schemas"]["deployment_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: date-time
				 * @description The timestamp when the deployment completed.
				 */
				readonly completion_date?: string
				readonly deployer?: components["schemas"]["account"]
				/**
				 * @description The name of deployment state (COMPLETED).
				 * @enum {string}
				 */
				readonly name?: "COMPLETED"
				/**
				 * Format: date-time
				 * @description The timestamp when the deployment was started.
				 */
				readonly start_date?: string
				readonly status?: components["schemas"]["deployment_state_completed_status"]
				/**
				 * Format: uri
				 * @description Link to the deployment result.
				 */
				readonly url?: string
			}))
		readonly deployment_state_completed_status: {
			readonly type: "deployment_state_completed_status"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly deployment_state_completed_status_failed: {
			readonly type: "deployment_state_completed_status_failed"
		} & (Omit<
			components["schemas"]["deployment_state_completed_status"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the completed deployment status (FAILED).
				 * @enum {string}
				 */
				readonly name?: "FAILED"
			}))
		readonly deployment_state_completed_status_stopped: {
			readonly type: "deployment_state_completed_status_stopped"
		} & (Omit<
			components["schemas"]["deployment_state_completed_status"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the completed deployment status (STOPPED).
				 * @enum {string}
				 */
				readonly name?: "STOPPED"
			}))
		readonly deployment_state_completed_status_successful: {
			readonly type: "deployment_state_completed_status_successful"
		} & (Omit<
			components["schemas"]["deployment_state_completed_status"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the completed deployment status (SUCCESSFUL).
				 * @enum {string}
				 */
				readonly name?: "SUCCESSFUL"
			}))
		readonly deployment_state_in_progress: {
			readonly type: "deployment_state_in_progress"
		} & (Omit<components["schemas"]["deployment_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly deployer?: components["schemas"]["account"]
				/**
				 * @description The name of deployment state (IN_PROGRESS).
				 * @enum {string}
				 */
				readonly name?: "IN_PROGRESS"
				/**
				 * Format: date-time
				 * @description The timestamp when the deployment was started.
				 */
				readonly start_date?: string
				/**
				 * Format: uri
				 * @description Link to the deployment result.
				 */
				readonly url?: string
			}))
		readonly deployment_state_undeployed: {
			readonly type: "deployment_state_undeployed"
		} & (Omit<components["schemas"]["deployment_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of deployment state (UNDEPLOYED).
				 * @enum {string}
				 */
				readonly name?: "UNDEPLOYED"
				/**
				 * Format: uri
				 * @description Link to trigger the deployment.
				 */
				readonly trigger_url?: string
			}))
		readonly deployment_variable: {
			readonly type: "deployment_variable"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The unique name of the variable. */
				readonly key?: string
				/** @description If true, this variable will be treated as secured. The value will never be exposed in the logs or the REST API. */
				readonly secured?: boolean
				/** @description The UUID identifying the variable. */
				readonly uuid?: string
				/** @description The value of the variable. If the variable is secured, this will be empty. */
				readonly value?: string
			}))
		/**
		 * Diff Stat
		 * @description A diffstat object that includes a summary of changes made to a file between two commits.
		 */
		readonly diffstat: Readonly<Record<string, unknown>> & {
			readonly lines_added?: number
			readonly lines_removed?: number
			readonly new?: components["schemas"]["commit_file"]
			readonly old?: components["schemas"]["commit_file"]
			/** @enum {string} */
			readonly status?: "added" | "modified" | "removed" | "renamed"
			readonly type: string
		}
		readonly effective_repo_branching_model: {
			readonly type: "effective_repo_branching_model"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The active branch types. */
				readonly branch_types?: readonly {
					/**
					 * @description The kind of branch.
					 * @enum {string}
					 */
					readonly kind: "bugfix" | "feature" | "hotfix" | "release"
					/** @description The prefix for this branch type. A branch with this prefix will be classified as per `kind`. The prefix must be a valid prefix for a branch and must always exist. It cannot be blank, empty or `null`. */
					readonly prefix: string
				}[]
				readonly development?: {
					readonly branch?: components["schemas"]["branch"]
					/** @description Name of the target branch. Will be listed here even when the target branch does not exist. Will be `null` if targeting the main branch and the repository is empty. */
					readonly name: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). */
					readonly use_mainbranch: boolean
				}
				readonly production?: {
					readonly branch?: components["schemas"]["branch"]
					/** @description Name of the target branch. Will be listed here even when the target branch does not exist. Will be `null` if targeting the main branch and the repository is empty. */
					readonly name: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). */
					readonly use_mainbranch: boolean
				}
			}))
		/**
		 * Error
		 * @description Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
		 */
		readonly error: Readonly<Record<string, unknown>> & {
			readonly error?: {
				/** @description Optional structured data that is endpoint-specific. */
				readonly data?: Readonly<Record<string, unknown>>
				readonly detail?: string
				readonly message: string
			}
			readonly type: string
		}
		/**
		 * Export Options
		 * @description Options for issue export.
		 */
		readonly export_options: Readonly<Record<string, unknown>> & {
			readonly include_attachments?: boolean
			readonly project_key?: string
			readonly project_name?: string
			readonly send_email?: boolean
			readonly type: string
		}
		readonly GPG_account_key: {
			readonly type: "GPG_account_key"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly added_on?: string
				/** @description The comment parsed from the GPG key (if present) */
				readonly comment?: string
				/** Format: date-time */
				readonly created_on?: string
				/** Format: date-time */
				readonly expires_on?: string
				/** @description The GPG key fingerprint. */
				readonly fingerprint?: string
				/** @description The GPG key value in X format. */
				readonly key?: string
				/** @description The unique identifier for the GPG key */
				readonly key_id?: string
				/** Format: date-time */
				readonly last_used?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** @description The user-defined label for the GPG key */
				readonly name?: string
				readonly owner?: components["schemas"]["account"]
				/** @description The fingerprint of the parent key. This value is null unless the current key is a subkey. */
				readonly parent_fingerprint?: string
				readonly subkeys?: readonly components["schemas"]["GPG_account_key"][]
			}))
		readonly group: {
			readonly type: "group"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The concatenation of the workspace's slug and the group's slug,
				 *     separated with a colon (e.g. `acme:developers`)
				 *      */
				readonly full_slug?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly name?: string
				readonly owner?: components["schemas"]["account"]
				/** @description The "sluggified" version of the group's name. This contains only ASCII
				 *     characters and can therefore be slightly different than the name */
				readonly slug?: string
				readonly workspace?: components["schemas"]["workspace"]
			}))
		/**
		 * Hook Event
		 * @description An event, associated with a resource or subject type.
		 */
		readonly hook_event: {
			/** @description The category this event belongs to. */
			readonly category?: string
			/** @description More detailed description of the webhook event type. */
			readonly description?: string
			/**
			 * @description The event identifier.
			 * @enum {string}
			 */
			readonly event?:
				| "issue:comment_created"
				| "issue:created"
				| "issue:updated"
				| "project:updated"
				| "pullrequest:approved"
				| "pullrequest:changes_request_created"
				| "pullrequest:changes_request_removed"
				| "pullrequest:comment_created"
				| "pullrequest:comment_deleted"
				| "pullrequest:comment_reopened"
				| "pullrequest:comment_resolved"
				| "pullrequest:comment_updated"
				| "pullrequest:created"
				| "pullrequest:fulfilled"
				| "pullrequest:push"
				| "pullrequest:rejected"
				| "pullrequest:unapproved"
				| "pullrequest:updated"
				| "repo:commit_comment_created"
				| "repo:commit_status_created"
				| "repo:commit_status_updated"
				| "repo:created"
				| "repo:deleted"
				| "repo:fork"
				| "repo:imported"
				| "repo:push"
				| "repo:transfer"
				| "repo:updated"
			/** @description Summary of the webhook event type. */
			readonly label?: string
		}
		readonly issue: {
			readonly type: "issue"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly assignee?: components["schemas"]["account"]
				readonly component?: components["schemas"]["component"]
				readonly content?: {
					/** @description The user's content rendered as HTML. */
					readonly html?: string
					/**
					 * @description The type of markup language the raw content is to be interpreted in.
					 * @enum {string}
					 */
					readonly markup?: "creole" | "markdown" | "plaintext"
					/** @description The text as it was typed by a user. */
					readonly raw?: string
				}
				/** Format: date-time */
				readonly created_on?: string
				/** Format: date-time */
				readonly edited_on?: string
				readonly id?: number
				/** @enum {string} */
				readonly kind?: "bug" | "enhancement" | "proposal" | "task"
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly attachments?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly comments?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly vote?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly watch?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly milestone?: components["schemas"]["milestone"]
				/** @enum {string} */
				readonly priority?:
					| "blocker"
					| "critical"
					| "major"
					| "minor"
					| "trivial"
				readonly reporter?: components["schemas"]["account"]
				readonly repository?: components["schemas"]["repository"]
				/** @enum {string} */
				readonly state?:
					| "closed"
					| "duplicate"
					| "invalid"
					| "new"
					| "on hold"
					| "open"
					| "resolved"
					| "submitted"
					| "wontfix"
				readonly title?: string
				/** Format: date-time */
				readonly updated_on?: string
				readonly version?: components["schemas"]["version"]
				readonly votes?: number
			}))
		readonly issue_attachment: {
			readonly type: "issue_attachment"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly name?: string
			}))
		/**
		 * Issue Change
		 * @description An issue change.
		 */
		readonly issue_change: Readonly<Record<string, unknown>> & {
			readonly changes?: {
				readonly assignee?: {
					readonly new?: string
					readonly old?: string
				}
				readonly component?: {
					readonly new?: string
					readonly old?: string
				}
				readonly content?: {
					readonly new?: string
					readonly old?: string
				}
				readonly kind?: {
					readonly new?: string
					readonly old?: string
				}
				readonly milestone?: {
					readonly new?: string
					readonly old?: string
				}
				readonly priority?: {
					readonly new?: string
					readonly old?: string
				}
				readonly state?: {
					readonly new?: string
					readonly old?: string
				}
				readonly title?: {
					readonly new?: string
					readonly old?: string
				}
				readonly version?: {
					readonly new?: string
					readonly old?: string
				}
			}
			/** Format: date-time */
			readonly created_on?: string
			readonly issue?: components["schemas"]["issue"]
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly issue?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			readonly message?: {
				/** @description The user's content rendered as HTML. */
				readonly html?: string
				/**
				 * @description The type of markup language the raw content is to be interpreted in.
				 * @enum {string}
				 */
				readonly markup?: "creole" | "markdown" | "plaintext"
				/** @description The text as it was typed by a user. */
				readonly raw?: string
			}
			readonly name?: string
			readonly type: string
			readonly user?: components["schemas"]["account"]
		}
		readonly issue_comment: {
			readonly type: "issue_comment"
		} & (Omit<components["schemas"]["comment"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly issue?: components["schemas"]["issue"]
			}))
		/**
		 * Issue Job Status
		 * @description The status of an import or export job
		 */
		readonly issue_job_status: {
			/** @description The total number of issues already imported/exported */
			readonly count?: number
			/** @description The percentage of issues already imported/exported */
			readonly pct?: number
			/** @description The phase of the import/export job */
			readonly phase?: string
			/**
			 * @description The status of the import/export job
			 * @enum {string}
			 */
			readonly status?: "ACCEPTED" | "FAILURE" | "RUNNING" | "STARTED"
			/** @description The total number of issues being imported/exported */
			readonly total?: number
			readonly type?: string
		}
		/**
		 * Link
		 * @description A link to a resource related to this object.
		 */
		readonly link: {
			/** Format: uri */
			readonly href?: string
			readonly name?: string
		}
		readonly milestone: {
			readonly type: "milestone"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly id?: number
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly name?: string
			}))
		/** @description Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`. */
		readonly object: Readonly<Record<string, unknown>> & {
			readonly type: string
		}
		/**
		 * Paginated Accounts
		 * @description A paginated list of accounts.
		 */
		readonly paginated_accounts: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["account"][]
		}
		/**
		 * Paginated Annotations
		 * @description A paginated list of annotations.
		 */
		readonly paginated_annotations: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["report_annotation"][]
		}
		/**
		 * Paginated Branches
		 * @description A paginated list of branches.
		 */
		readonly paginated_branches: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["branch"][]
		}
		/**
		 * Paginated Branch Restrictions
		 * @description A paginated list of branch restriction rules.
		 */
		readonly paginated_branchrestrictions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["branchrestriction"][]
		}
		/**
		 * Page
		 * @description A paginated list of commits.
		 */
		readonly paginated_changeset: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["base_commit"][]
		}
		/**
		 * Paginated Commit Comments
		 * @description A paginated list of commit comments.
		 */
		readonly paginated_commit_comments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["commit_comment"][]
		}
		/**
		 * Paginated Commit Statuses
		 * @description A paginated list of commit status objects.
		 */
		readonly paginated_commitstatuses: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["commitstatus"][]
		}
		/**
		 * Paginated Components
		 * @description A paginated list of issue tracker components.
		 */
		readonly paginated_components: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["component"][]
		}
		/**
		 * Paginated Default Reviewer and Type
		 * @description A paginated list of default reviewers with reviewer type.
		 */
		readonly paginated_default_reviewer_and_type: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["default_reviewer_and_type"][]
		}
		/**
		 * Paginated Deploy Keys
		 * @description A paginated list of deploy keys.
		 */
		readonly paginated_deploy_keys: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["deploy_key"][]
		}
		/**
		 * Paginated Deployment Variables
		 * @description A paged list of deployment variables.
		 */
		readonly paginated_deployment_variable: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["deployment_variable"][]
		}
		/**
		 * Paginated Deployments
		 * @description A paged list of deployments
		 */
		readonly paginated_deployments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["deployment"][]
		}
		/**
		 * Paginated Diff Stat
		 * @description A paginated list of diffstats.
		 */
		readonly paginated_diffstats: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 500 with 5000 being the maximum allowed value. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["diffstat"][]
		}
		/**
		 * Paginated Deployment Environments
		 * @description A paged list of environments
		 */
		readonly paginated_environments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["deployment_environment"][]
		}
		/**
		 * Paginated Files
		 * @description A paginated list of commit_file objects.
		 */
		readonly paginated_files: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["commit_file"][]
		}
		/**
		 * Paginated GPG User Keys
		 * @description A paginated list of GPG keys.
		 */
		readonly paginated_gpg_user_keys: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["GPG_account_key"][]
		}
		/**
		 * Paginated Hook Events
		 * @description A paginated list of webhook types available to subscribe on.
		 */
		readonly paginated_hook_events: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["hook_event"][]
		}
		/**
		 * Paginated Issue Attachment
		 * @description A paginated list of issue attachments.
		 */
		readonly paginated_issue_attachments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["issue_attachment"][]
		}
		/**
		 * Paginated Issue Comments
		 * @description A paginated list of issue comments.
		 */
		readonly paginated_issue_comments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["issue_comment"][]
		}
		/**
		 * Paginated Issues
		 * @description A paginated list of issues.
		 */
		readonly paginated_issues: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["issue"][]
		}
		/**
		 * Paginated Log Entries
		 * @description A paginated list of issue changes.
		 */
		readonly paginated_log_entries: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["issue_change"][]
		}
		/**
		 * Paginated Milestones
		 * @description A paginated list of issue tracker milestones.
		 */
		readonly paginated_milestones: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["milestone"][]
		}
		/**
		 * Paginated Pipeline Cache
		 * @description A paged list of pipeline caches
		 */
		readonly paginated_pipeline_caches: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline_cache"][]
		}
		/**
		 * Paginated Pipeline Known Hosts
		 * @description A paged list of known hosts.
		 */
		readonly paginated_pipeline_known_hosts: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline_known_host"][]
		}
		/**
		 * Paginated Pipeline Schedule Executions
		 * @description A paged list of the executions of a schedule.
		 */
		readonly paginated_pipeline_schedule_executions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline_schedule_execution"][]
		}
		/**
		 * Paginated Pipeline Schedule
		 * @description A paged list of schedules
		 */
		readonly paginated_pipeline_schedules: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline_schedule"][]
		}
		/**
		 * Paginated Pipeline Steps
		 * @description A paged list of pipeline steps.
		 */
		readonly paginated_pipeline_steps: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline_step"][]
		}
		/**
		 * Paginated Pipeline Variables
		 * @description A paged list of variables.
		 */
		readonly paginated_pipeline_variables: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline_variable"][]
		}
		/**
		 * Paginated Pipelines
		 * @description A paged list of pipelines
		 */
		readonly paginated_pipelines: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["pipeline"][]
		}
		/**
		 * Paginated Project Deploy Keys
		 * @description A paginated list of project deploy keys.
		 */
		readonly paginated_project_deploy_keys: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["project_deploy_key"][]
		}
		/**
		 * Paginated Project Group Permissions
		 * @description A paginated list of project group permissions.
		 */
		readonly paginated_project_group_permissions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["project_group_permission"][]
		}
		/**
		 * Paginated Project User Permissions
		 * @description A paginated list of project user permissions.
		 */
		readonly paginated_project_user_permissions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["project_user_permission"][]
		}
		/**
		 * Paginated Projects
		 * @description A paginated list of projects
		 */
		readonly paginated_projects: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["project"][]
		}
		/**
		 * Paginated Pull Request Comments
		 * @description A paginated list of pullrequest comments.
		 */
		readonly paginated_pullrequest_comments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["pullrequest_comment"][]
		}
		/**
		 * Paginated Pull Requests
		 * @description A paginated list of pullrequests.
		 */
		readonly paginated_pullrequests: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["pullrequest"][]
		}
		/**
		 * Paginated Refs
		 * @description A paginated list of refs.
		 */
		readonly paginated_refs: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["ref"][]
		}
		/**
		 * Paginated Reports
		 * @description A paginated list of reports.
		 */
		readonly paginated_reports: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			/** @description The values of the current page. */
			readonly values?: readonly components["schemas"]["report"][]
		}
		/**
		 * Paginated Repositories
		 * @description A paginated list of repositories.
		 */
		readonly paginated_repositories: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["repository"][]
		}
		/**
		 * Paginated Repository Group Permissions
		 * @description A paginated list of repository group permissions.
		 */
		readonly paginated_repository_group_permissions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["repository_group_permission"][]
		}
		/**
		 * Paginated Repository Permissions
		 * @description A paginated list of repository permissions.
		 */
		readonly paginated_repository_permissions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["repository_permission"][]
		}
		/**
		 * Paginated Repository User Permissions
		 * @description A paginated list of repository user permissions.
		 */
		readonly paginated_repository_user_permissions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["repository_user_permission"][]
		}
		/**
		 * Paginated Snippet Comments
		 * @description A paginated list of snippet comments.
		 */
		readonly paginated_snippet_comments: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["snippet_comment"][]
		}
		/**
		 * Paginated Snippet Commits
		 * @description A paginated list of snippet commits.
		 */
		readonly paginated_snippet_commit: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["snippet_commit"][]
		}
		/**
		 * Paginated Snippets
		 * @description A paginated list of snippets.
		 */
		readonly paginated_snippets: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["snippet"][]
		}
		/**
		 * Paginated SSH User Keys
		 * @description A paginated list of SSH keys.
		 */
		readonly paginated_ssh_user_keys: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["ssh_account_key"][]
		}
		/**
		 * Paginated Tags
		 * @description A paginated list of tags.
		 */
		readonly paginated_tags: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["tag"][]
		}
		/**
		 * Paginated Tasks
		 * @description A paginated list of tasks.
		 */
		readonly paginated_tasks: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["pullrequest_comment_task"][]
		}
		/**
		 * Paginated Tree Entry
		 * @description A paginated list of commit_file and/or commit_directory objects.
		 */
		readonly paginated_treeentries: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["treeentry"][]
		}
		/**
		 * Paginated Versions
		 * @description A paginated list of issue tracker versions.
		 */
		readonly paginated_versions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["version"][]
		}
		/**
		 * Paginated Webhook Subscriptions
		 * @description A paginated list of webhook subscriptions
		 */
		readonly paginated_webhook_subscriptions: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["webhook_subscription"][]
		}
		/**
		 * Paginated Workspace Memberships
		 * @description A paginated list of workspace memberships.
		 */
		readonly paginated_workspace_memberships: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["workspace_membership"][]
		}
		/**
		 * Paginated Workspaces
		 * @description A paginated list of workspaces.
		 */
		readonly paginated_workspaces: {
			/**
			 * Format: uri
			 * @description Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly next?: string
			/** @description Page number of the current results. This is an optional element that is not provided in all responses. */
			readonly page?: number
			/** @description Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values. */
			readonly pagelen?: number
			/**
			 * Format: uri
			 * @description Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
			 */
			readonly previous?: string
			/** @description Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute. */
			readonly size?: number
			readonly values?: readonly components["schemas"]["workspace"][]
		}
		readonly participant: {
			readonly type: "participant"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly approved?: boolean
				/**
				 * Format: date-time
				 * @description The ISO8601 timestamp of the participant's action. For approvers, this is the time of their approval. For commenters and pull request reviewers who are not approvers, this is the time they last commented, or null if they have not commented.
				 */
				readonly participated_on?: string
				/** @enum {string} */
				readonly role?: "PARTICIPANT" | "REVIEWER"
				/** @enum {string} */
				readonly state?: "approved" | "changes_requested" | null
				readonly user?: components["schemas"]["account"]
			}))
		readonly pipeline: {
			readonly type: "pipeline"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The build number of the pipeline. */
				readonly build_number?: number
				/** @description The number of build seconds used by this pipeline. */
				readonly build_seconds_used?: number
				/**
				 * Format: date-time
				 * @description The timestamp when the Pipeline was completed. This is not set if the pipeline is still in progress.
				 */
				readonly completed_on?: string
				/** @description An ordered list of sources of the pipeline configuration */
				readonly configuration_sources?: readonly components["schemas"]["pipeline_configuration_source"][]
				/**
				 * Format: date-time
				 * @description The timestamp when the pipeline was created.
				 */
				readonly created_on?: string
				readonly creator?: components["schemas"]["account"]
				readonly links?: components["schemas"]["pipelines_pipeline_links"]
				readonly repository?: components["schemas"]["repository"]
				readonly state?: components["schemas"]["pipeline_state"]
				readonly target?: components["schemas"]["pipeline_target"]
				readonly trigger?: components["schemas"]["pipeline_trigger"]
				/** @description The UUID identifying the pipeline. */
				readonly uuid?: string
				/** @description The variables for the pipeline. */
				readonly variables?: readonly components["schemas"]["pipeline_variable"][]
			}))
		readonly pipeline_build_number: {
			readonly type: "pipeline_build_number"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The next number that will be used as build number. */
				readonly next?: number
			}))
		readonly pipeline_cache: {
			readonly type: "pipeline_cache"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: date-time
				 * @description The timestamp when the cache was created.
				 */
				readonly created_on?: string
				/** @description The size of the file containing the archive of the cache. */
				readonly file_size_bytes?: number
				/** @description The key hash of the cache version. */
				readonly key_hash?: string
				/** @description The name of the cache. */
				readonly name?: string
				/** @description The path where the cache contents were retrieved from. */
				readonly path?: string
				/** @description The UUID of the pipeline that created the cache. */
				readonly pipeline_uuid?: string
				/** @description The uuid of the step that created the cache. */
				readonly step_uuid?: string
				/** @description The UUID identifying the pipeline cache. */
				readonly uuid?: string
			}))
		/**
		 * Pipeline Cache Content URI
		 * @description A representation of the location of pipeline cache content.
		 */
		readonly pipeline_cache_content_uri: {
			/**
			 * Format: uri
			 * @description The uri for pipeline cache content.
			 */
			readonly uri?: string
		}
		/**
		 * Pipeline Command
		 * @description An executable pipeline command.
		 */
		readonly pipeline_command: {
			/** @description The executable command. */
			readonly command?: string
			/** @description The name of the command. */
			readonly name?: string
		}
		readonly pipeline_commit_target: {
			readonly type: "pipeline_commit_target"
		} & (Omit<components["schemas"]["pipeline_target"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly commit?: components["schemas"]["commit"]
				readonly selector?: components["schemas"]["pipeline_selector"]
			}))
		/** @description Information about the source of the pipeline configuration */
		readonly pipeline_configuration_source: {
			/** @description Identifier of the configuration source */
			readonly source: string
			/**
			 * Format: uri
			 * @description Link to the configuration source view or its immediate content
			 */
			readonly uri: string
		}
		readonly pipeline_error: {
			readonly type: "pipeline_error"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The error key. */
				readonly key?: string
				/** @description The error message. */
				readonly message?: string
			}))
		/**
		 * Pipeline Image
		 * @description The definition of a Docker image that can be used for a Bitbucket Pipelines step execution context.
		 */
		readonly pipeline_image: {
			/** @description The email needed to authenticate with the Docker registry. Only required when using a private Docker image. */
			readonly email?: string
			/** @description The name of the image. If the image is hosted on DockerHub the short name can be used, otherwise the fully qualified name is required here. */
			readonly name?: string
			/** @description The password needed to authenticate with the Docker registry. Only required when using a private Docker image. */
			readonly password?: string
			/** @description The username needed to authenticate with the Docker registry. Only required when using a private Docker image. */
			readonly username?: string
		}
		readonly pipeline_known_host: {
			readonly type: "pipeline_known_host"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The hostname of the known host. */
				readonly hostname?: string
				readonly public_key?: components["schemas"]["pipeline_ssh_public_key"]
				/** @description The UUID identifying the known host. */
				readonly uuid?: string
			}))
		readonly pipeline_ref_target: {
			readonly type: "pipeline_ref_target"
		} & (Omit<components["schemas"]["pipeline_target"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly commit?: components["schemas"]["commit"]
				/** @description The name of the reference. */
				readonly ref_name?: string
				/**
				 * @description The type of reference (branch/tag).
				 * @enum {string}
				 */
				readonly ref_type?: "bookmark" | "branch" | "named_branch" | "tag"
				readonly selector?: components["schemas"]["pipeline_selector"]
			}))
		readonly pipeline_schedule: {
			readonly type: "pipeline_schedule"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: date-time
				 * @description The timestamp when the schedule was created.
				 */
				readonly created_on?: string
				/** @description The cron expression with second precision (7 fields) that the schedule applies. For example, for expression: 0 0 12 * * ? *, will execute at 12pm UTC every day. */
				readonly cron_pattern?: string
				/** @description Whether the schedule is enabled. */
				readonly enabled?: boolean
				readonly target?: components["schemas"]["pipeline_ref_target"]
				/**
				 * Format: date-time
				 * @description The timestamp when the schedule was updated.
				 */
				readonly updated_on?: string
				/** @description The UUID identifying the schedule. */
				readonly uuid?: string
			}))
		readonly pipeline_schedule_execution: {
			readonly type: "pipeline_schedule_execution"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_schedule_execution_errored: {
			readonly type: "pipeline_schedule_execution_errored"
		} & (Omit<components["schemas"]["pipeline_schedule_execution"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly error?: components["schemas"]["pipeline_error"]
			}))
		readonly pipeline_schedule_execution_executed: {
			readonly type: "pipeline_schedule_execution_executed"
		} & (Omit<components["schemas"]["pipeline_schedule_execution"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly pipeline?: components["schemas"]["pipeline"]
			}))
		readonly pipeline_schedule_post_request_body: {
			readonly type: "pipeline_schedule_post_request_body"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The cron expression with second precision (7 fields) that the schedule applies. For example, for expression: 0 0 12 * * ? *, will execute at 12pm UTC every day. */
				readonly cron_pattern: string
				/** @description Whether the schedule is enabled. */
				readonly enabled?: boolean
				/** @description The target on which the schedule will be executed. */
				readonly target: {
					/** @description The name of the reference. */
					readonly ref_name: string
					/**
					 * @description The type of reference (branch only).
					 * @enum {string}
					 */
					readonly ref_type: "branch"
					readonly selector: components["schemas"]["pipeline_selector"]
				}
			}))
		readonly pipeline_schedule_put_request_body: {
			readonly type: "pipeline_schedule_put_request_body"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description Whether the schedule is enabled. */
				readonly enabled?: boolean
			}))
		readonly pipeline_selector: {
			readonly type: "pipeline_selector"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The name of the matching pipeline definition. */
				readonly pattern?: string
				/**
				 * @description The type of selector.
				 * @enum {string}
				 */
				readonly type?: "bookmarks" | "branches" | "custom" | "default" | "tags"
			}))
		readonly pipeline_ssh_key_pair: {
			readonly type: "pipeline_ssh_key_pair"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The SSH private key. This value will be empty when retrieving the SSH key pair. */
				readonly private_key?: string
				/** @description The SSH public key. */
				readonly public_key?: string
			}))
		readonly pipeline_ssh_public_key: {
			readonly type: "pipeline_ssh_public_key"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The base64 encoded public key. */
				readonly key?: string
				/** @description The type of the public key. */
				readonly key_type?: string
				/** @description The MD5 fingerprint of the public key. */
				readonly md5_fingerprint?: string
				/** @description The SHA-256 fingerprint of the public key. */
				readonly sha256_fingerprint?: string
			}))
		readonly pipeline_state: {
			readonly type: "pipeline_state"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_state_completed: {
			readonly type: "pipeline_state_completed"
		} & (Omit<components["schemas"]["pipeline_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline state (COMPLETED).
				 * @enum {string}
				 */
				readonly name?: "COMPLETED"
				readonly result?: components["schemas"]["pipeline_state_completed_result"]
			}))
		readonly pipeline_state_completed_error: {
			readonly type: "pipeline_state_completed_error"
		} & (Omit<
			components["schemas"]["pipeline_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				readonly error?: components["schemas"]["pipeline_error"]
				/**
				 * @description The name of the result (ERROR)
				 * @enum {string}
				 */
				readonly name?: "ERROR"
			}))
		readonly pipeline_state_completed_expired: {
			readonly type: "pipeline_state_completed_expired"
		} & (Omit<
			components["schemas"]["pipeline_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the stopped result (EXPIRED).
				 * @enum {string}
				 */
				readonly name?: "EXPIRED"
			}))
		readonly pipeline_state_completed_failed: {
			readonly type: "pipeline_state_completed_failed"
		} & (Omit<
			components["schemas"]["pipeline_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the failed result (FAILED).
				 * @enum {string}
				 */
				readonly name?: "FAILED"
			}))
		readonly pipeline_state_completed_result: {
			readonly type: "pipeline_state_completed_result"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_state_completed_stopped: {
			readonly type: "pipeline_state_completed_stopped"
		} & (Omit<
			components["schemas"]["pipeline_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the stopped result (STOPPED).
				 * @enum {string}
				 */
				readonly name?: "STOPPED"
			}))
		readonly pipeline_state_completed_successful: {
			readonly type: "pipeline_state_completed_successful"
		} & (Omit<
			components["schemas"]["pipeline_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the successful result (SUCCESSFUL).
				 * @enum {string}
				 */
				readonly name?: "SUCCESSFUL"
			}))
		readonly pipeline_state_in_progress: {
			readonly type: "pipeline_state_in_progress"
		} & (Omit<components["schemas"]["pipeline_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline state (IN_PROGRESS).
				 * @enum {string}
				 */
				readonly name?: "IN_PROGRESS"
				readonly stage?: components["schemas"]["pipeline_state_in_progress_stage"]
			}))
		readonly pipeline_state_in_progress_paused: {
			readonly type: "pipeline_state_in_progress_paused"
		} & (Omit<
			components["schemas"]["pipeline_state_in_progress_stage"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the stage (PAUSED)
				 * @enum {string}
				 */
				readonly name?: "PAUSED"
			}))
		readonly pipeline_state_in_progress_running: {
			readonly type: "pipeline_state_in_progress_running"
		} & (Omit<
			components["schemas"]["pipeline_state_in_progress_stage"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the stage (RUNNING)
				 * @enum {string}
				 */
				readonly name?: "RUNNING"
			}))
		readonly pipeline_state_in_progress_stage: {
			readonly type: "pipeline_state_in_progress_stage"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_state_pending: {
			readonly type: "pipeline_state_pending"
		} & (Omit<components["schemas"]["pipeline_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline state (PENDING).
				 * @enum {string}
				 */
				readonly name?: "PENDING"
			}))
		readonly pipeline_step: {
			readonly type: "pipeline_step"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: date-time
				 * @description The timestamp when the step execution was completed. This is not set if the step is still in progress.
				 */
				readonly completed_on?: string
				readonly image?: components["schemas"]["pipeline_image"]
				/** @description The list of build commands. These commands are executed in the build container. */
				readonly script_commands?: readonly components["schemas"]["pipeline_command"][]
				/** @description The list of commands that are executed as part of the setup phase of the build. These commands are executed outside the build container. */
				readonly setup_commands?: readonly components["schemas"]["pipeline_command"][]
				/**
				 * Format: date-time
				 * @description The timestamp when the step execution was started. This is not set when the step hasn't executed yet.
				 */
				readonly started_on?: string
				readonly state?: components["schemas"]["pipeline_step_state"]
				/** @description The UUID identifying the step. */
				readonly uuid?: string
			}))
		readonly pipeline_step_error: {
			readonly type: "pipeline_step_error"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The error key. */
				readonly key?: string
				/** @description The error message. */
				readonly message?: string
			}))
		readonly pipeline_step_state: {
			readonly type: "pipeline_step_state"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_step_state_completed: {
			readonly type: "pipeline_step_state_completed"
		} & (Omit<components["schemas"]["pipeline_step_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline step state (COMPLETED).
				 * @enum {string}
				 */
				readonly name?: "COMPLETED"
				readonly result?: components["schemas"]["pipeline_step_state_completed_result"]
			}))
		readonly pipeline_step_state_completed_error: {
			readonly type: "pipeline_step_state_completed_error"
		} & (Omit<
			components["schemas"]["pipeline_step_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				readonly error?: components["schemas"]["pipeline_step_error"]
				/**
				 * @description The name of the result (ERROR)
				 * @enum {string}
				 */
				readonly name?: "ERROR"
			}))
		readonly pipeline_step_state_completed_expired: {
			readonly type: "pipeline_step_state_completed_expired"
		} & (Omit<
			components["schemas"]["pipeline_step_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the result (EXPIRED)
				 * @enum {string}
				 */
				readonly name?: "EXPIRED"
			}))
		readonly pipeline_step_state_completed_failed: {
			readonly type: "pipeline_step_state_completed_failed"
		} & (Omit<
			components["schemas"]["pipeline_step_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the result (FAILED)
				 * @enum {string}
				 */
				readonly name?: "FAILED"
			}))
		readonly pipeline_step_state_completed_not_run: {
			readonly type: "pipeline_step_state_completed_not_run"
		} & (Omit<
			components["schemas"]["pipeline_step_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the result (NOT_RUN)
				 * @enum {string}
				 */
				readonly name?: "NOT_RUN"
			}))
		readonly pipeline_step_state_completed_result: {
			readonly type: "pipeline_step_state_completed_result"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_step_state_completed_stopped: {
			readonly type: "pipeline_step_state_completed_stopped"
		} & (Omit<
			components["schemas"]["pipeline_step_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the result (STOPPED)
				 * @enum {string}
				 */
				readonly name?: "STOPPED"
			}))
		readonly pipeline_step_state_completed_successful: {
			readonly type: "pipeline_step_state_completed_successful"
		} & (Omit<
			components["schemas"]["pipeline_step_state_completed_result"],
			"type"
		> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of the result (SUCCESSFUL)
				 * @enum {string}
				 */
				readonly name?: "SUCCESSFUL"
			}))
		readonly pipeline_step_state_in_progress: {
			readonly type: "pipeline_step_state_in_progress"
		} & (Omit<components["schemas"]["pipeline_step_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline step state (IN_PROGRESS).
				 * @enum {string}
				 */
				readonly name?: "IN_PROGRESS"
			}))
		readonly pipeline_step_state_pending: {
			readonly type: "pipeline_step_state_pending"
		} & (Omit<components["schemas"]["pipeline_step_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline step state (PENDING).
				 * @enum {string}
				 */
				readonly name?: "PENDING"
			}))
		readonly pipeline_step_state_ready: {
			readonly type: "pipeline_step_state_ready"
		} & (Omit<components["schemas"]["pipeline_step_state"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The name of pipeline step state (READY).
				 * @enum {string}
				 */
				readonly name?: "READY"
			}))
		readonly pipeline_target: {
			readonly type: "pipeline_target"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_trigger: {
			readonly type: "pipeline_trigger"
		} & (Omit<components["schemas"]["object"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_trigger_manual: {
			readonly type: "pipeline_trigger_manual"
		} & (Omit<components["schemas"]["pipeline_trigger"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_trigger_push: {
			readonly type: "pipeline_trigger_push"
		} & (Omit<components["schemas"]["pipeline_trigger"], "type"> &
			Readonly<Record<string, unknown>>)
		readonly pipeline_variable: {
			readonly type: "pipeline_variable"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The unique name of the variable. */
				readonly key?: string
				/** @description If true, this variable will be treated as secured. The value will never be exposed in the logs or the REST API. */
				readonly secured?: boolean
				/** @description The UUID identifying the variable. */
				readonly uuid?: string
				/** @description The value of the variable. If the variable is secured, this will be empty. */
				readonly value?: string
			}))
		readonly pipelines_config: {
			readonly type: "pipelines_config"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description Whether Pipelines is enabled for the repository. */
				readonly enabled?: boolean
				readonly repository?: components["schemas"]["repository"]
			}))
		readonly pipelines_links_section_href: {
			readonly type: "pipelines_links_section_href"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: uri
				 * @description A link
				 */
				readonly href?: string
			}))
		readonly pipelines_pipeline_links: {
			readonly type: "pipelines_pipeline_links"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly self?: components["schemas"]["pipelines_links_section_href"]
				readonly steps?: components["schemas"]["pipelines_links_section_href"]
			}))
		readonly project: {
			readonly type: "project"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly created_on?: string
				readonly description?: string
				/** @description
				 *     Indicates whether the project contains publicly visible repositories.
				 *     Note that private projects cannot contain public repositories. */
				readonly has_publicly_visible_repos?: boolean
				/** @description
				 *     Indicates whether the project is publicly accessible, or whether it is
				 *     private to the team and consequently only visible to team members.
				 *     Note that private projects cannot contain public repositories. */
				readonly is_private?: boolean
				/** @description The project's key. */
				readonly key?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly avatar?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** @description The name of the project. */
				readonly name?: string
				readonly owner?: components["schemas"]["team"]
				/** Format: date-time */
				readonly updated_on?: string
				/** @description The project's immutable id. */
				readonly uuid?: string
			}))
		readonly project_branching_model: {
			readonly type: "project_branching_model"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The active branch types. */
				readonly branch_types?: readonly {
					/**
					 * @description The kind of branch.
					 * @enum {string}
					 */
					readonly kind: "bugfix" | "feature" | "hotfix" | "release"
					/** @description The prefix for this branch type. A branch with this prefix will be classified as per `kind`. The prefix must be a valid prefix for a branch and must always exist. It cannot be blank, empty or `null`. */
					readonly prefix: string
				}[]
				readonly development?: {
					/** @description Name of the target branch. If inherited by a repository, it will default to the main branch if the specified branch does not exist. */
					readonly name: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). */
					readonly use_mainbranch: boolean
				}
				readonly production?: {
					/** @description Name of the target branch. If inherited by a repository, it will default to the main branch if the specified branch does not exist. */
					readonly name: string
					/** @description Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). */
					readonly use_mainbranch: boolean
				}
			}))
		readonly project_deploy_key: {
			readonly type: "project_deploy_key"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly added_on?: string
				/** @description The comment parsed from the deploy key (if present) */
				readonly comment?: string
				readonly created_by?: components["schemas"]["account"]
				/** @description The deploy key value. */
				readonly key?: string
				/** @description The user-defined label for the deploy key */
				readonly label?: string
				/** Format: date-time */
				readonly last_used?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly project?: components["schemas"]["project"]
			}))
		/**
		 * Project Group Permission
		 * @description A group's permission for a given project.
		 */
		readonly project_group_permission: Readonly<Record<string, unknown>> & {
			readonly group?: components["schemas"]["group"]
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			/** @enum {string} */
			readonly permission?: "admin" | "create-repo" | "none" | "read" | "write"
			readonly project?: components["schemas"]["project"]
			readonly type: string
		}
		/**
		 * Project User Permission
		 * @description A user's direct permission for a given project.
		 */
		readonly project_user_permission: Readonly<Record<string, unknown>> & {
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			/** @enum {string} */
			readonly permission?: "admin" | "create-repo" | "none" | "read" | "write"
			readonly project?: components["schemas"]["project"]
			readonly type: string
			readonly user?: components["schemas"]["user"]
		}
		readonly pullrequest: {
			readonly type: "pullrequest"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly author?: components["schemas"]["account"]
				/** @description A boolean flag indicating if merging the pull request closes the source branch. */
				readonly close_source_branch?: boolean
				readonly closed_by?: components["schemas"]["account"]
				/** @description The number of comments for a specific pull request. */
				readonly comment_count?: number
				/**
				 * Format: date-time
				 * @description The ISO8601 timestamp the request was created.
				 */
				readonly created_on?: string
				readonly destination?: components["schemas"]["pullrequest_endpoint"]
				/** @description The pull request's unique ID. Note that pull request IDs are only unique within their associated repository. */
				readonly id?: number
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly activity?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly approve?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly comments?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly commits?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly decline?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly diff?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly diffstat?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly merge?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** Pull Request Commit */
				readonly merge_commit?: {
					readonly hash?: string
				}
				/** @description         The list of users that are collaborating on this pull request.
				 *             Collaborators are user that:
				 *
				 *             * are added to the pull request as a reviewer (part of the reviewers
				 *               list)
				 *             * are not explicit reviewers, but have commented on the pull request
				 *             * are not explicit reviewers, but have approved the pull request
				 *
				 *             Each user is wrapped in an object that indicates the user's role and
				 *             whether they have approved the pull request. For performance reasons,
				 *             the API only returns this list when an API requests a pull request by
				 *             id.
				 *              */
				readonly participants?: readonly components["schemas"]["participant"][]
				/** @description Explains why a pull request was declined. This field is only applicable to pull requests in rejected state. */
				readonly reason?: string
				/**
				 * Rendered Pull Request Markup
				 * @description User provided pull request text, interpreted in a markup language and rendered in HTML
				 */
				readonly rendered?: {
					readonly description?: {
						/** @description The user's content rendered as HTML. */
						readonly html?: string
						/**
						 * @description The type of markup language the raw content is to be interpreted in.
						 * @enum {string}
						 */
						readonly markup?: "creole" | "markdown" | "plaintext"
						/** @description The text as it was typed by a user. */
						readonly raw?: string
					}
					readonly reason?: {
						/** @description The user's content rendered as HTML. */
						readonly html?: string
						/**
						 * @description The type of markup language the raw content is to be interpreted in.
						 * @enum {string}
						 */
						readonly markup?: "creole" | "markdown" | "plaintext"
						/** @description The text as it was typed by a user. */
						readonly raw?: string
					}
					readonly title?: {
						/** @description The user's content rendered as HTML. */
						readonly html?: string
						/**
						 * @description The type of markup language the raw content is to be interpreted in.
						 * @enum {string}
						 */
						readonly markup?: "creole" | "markdown" | "plaintext"
						/** @description The text as it was typed by a user. */
						readonly raw?: string
					}
				}
				/** @description The list of users that were added as reviewers on this pull request when it was created. For performance reasons, the API only includes this list on a pull request's `self` URL. */
				readonly reviewers?: readonly components["schemas"]["account"][]
				readonly source?: components["schemas"]["pullrequest_endpoint"]
				/**
				 * @description The pull request's current status.
				 * @enum {string}
				 */
				readonly state?: "DECLINED" | "MERGED" | "OPEN" | "SUPERSEDED"
				readonly summary?: {
					/** @description The user's content rendered as HTML. */
					readonly html?: string
					/**
					 * @description The type of markup language the raw content is to be interpreted in.
					 * @enum {string}
					 */
					readonly markup?: "creole" | "markdown" | "plaintext"
					/** @description The text as it was typed by a user. */
					readonly raw?: string
				}
				/** @description The number of open tasks for a specific pull request. */
				readonly task_count?: number
				/** @description Title of the pull request. */
				readonly title?: string
				/**
				 * Format: date-time
				 * @description The ISO8601 timestamp the request was last updated.
				 */
				readonly updated_on?: string
			}))
		readonly pullrequest_comment: {
			readonly type: "pullrequest_comment"
		} & (Omit<components["schemas"]["comment"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly pending?: boolean
				readonly pullrequest?: components["schemas"]["pullrequest"]
				readonly resolution?: components["schemas"]["comment_resolution"]
			}))
		readonly pullrequest_comment_task: components["schemas"]["pullrequest_task"] & {
			readonly comment?: components["schemas"]["comment"]
		}
		/** Pull Request Endpoint */
		readonly pullrequest_endpoint: {
			/** Pull Request Branch */
			readonly branch?: {
				/** @description The default merge strategy, when this endpoint is the destination of the pull request. */
				readonly default_merge_strategy?: string
				/** @description Available merge strategies, when this endpoint is the destination of the pull request. */
				readonly merge_strategies?: readonly (
					| "fast_forward"
					| "merge_commit"
					| "rebase_fast_forward"
					| "rebase_merge"
					| "squash_fast_forward"
					| "squash"
				)[]
				readonly name?: string
			}
			/** Pull Request Commit */
			readonly commit?: {
				readonly hash?: string
			}
			readonly repository?: components["schemas"]["repository"]
		}
		/**
		 * Pull Request Merge Parameters
		 * @description The metadata that describes a pull request merge.
		 */
		readonly pullrequest_merge_parameters: Readonly<Record<string, unknown>> & {
			/** @description Whether the source branch should be deleted. If this is not provided, we fallback to the value used when the pull request was created, which defaults to False */
			readonly close_source_branch?: boolean
			/**
			 * @description The merge strategy that will be used to merge the pull request.
			 * @default merge_commit
			 * @enum {string}
			 */
			readonly merge_strategy?:
				| "fast_forward"
				| "merge_commit"
				| "rebase_fast_forward"
				| "rebase_merge"
				| "squash_fast_forward"
				| "squash"
			/** @description The commit message that will be used on the resulting commit. Note that the size of the message is limited to 128 KiB. */
			readonly message?: string
			readonly type: string
		}
		readonly pullrequest_task: components["schemas"]["task"] & {
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly html?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
		}
		/**
		 * Pull Request Task Create
		 * @description A pullrequest task create
		 */
		readonly pullrequest_task_create: {
			readonly comment?: components["schemas"]["comment"]
			/**
			 * Task Raw Content
			 * @description task raw content
			 */
			readonly content: {
				/** @description The task contents */
				readonly raw: string
			}
			readonly pending?: boolean
		}
		/**
		 * Pull Request Task Update
		 * @description A pullrequest task update
		 */
		readonly pullrequest_task_update: {
			/**
			 * Task Raw Content
			 * @description task raw content
			 */
			readonly content?: {
				/** @description The task contents */
				readonly raw: string
			}
			/** @enum {string} */
			readonly state?: "RESOLVED" | "UNRESOLVED"
		}
		/**
		 * Ref
		 * @description A ref object, representing a branch or tag in a repository.
		 */
		readonly ref: Readonly<Record<string, unknown>> & {
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly commits?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly html?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			/** @description The name of the ref. */
			readonly name?: string
			readonly target?: components["schemas"]["commit"]
			readonly type: string
		}
		readonly report: {
			readonly type: "report"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: date-time
				 * @description The timestamp when the report was created.
				 */
				readonly created_on?: string
				/** @description An array of data fields to display information on the report. Maximum 10. */
				readonly data?: readonly components["schemas"]["report_data"][]
				/** @description A string to describe the purpose of the report. */
				readonly details?: string
				/** @description ID of the report provided by the report creator. It can be used to identify the report as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the report creator for updating or deleting this specific report. Needs to be unique. */
				readonly external_id?: string
				/**
				 * Format: uri
				 * @description A URL linking to the results of the report in an external tool.
				 */
				readonly link?: string
				/**
				 * Format: uri
				 * @description A URL to the report logo. If none is provided, the default insights logo will be used.
				 */
				readonly logo_url?: string
				/** @description If enabled, a remote link is created in Jira for the issue associated with the commit the report belongs to. */
				readonly remote_link_enabled?: boolean
				/**
				 * @description The type of the report.
				 * @enum {string}
				 */
				readonly report_type?: "BUG" | "COVERAGE" | "SECURITY" | "TEST"
				/** @description A string to describe the tool or company who created the report. */
				readonly reporter?: string
				/**
				 * @description The state of the report. May be set to PENDING and later updated.
				 * @enum {string}
				 */
				readonly result?: "FAILED" | "PASSED" | "PENDING"
				/** @description The title of the report. */
				readonly title?: string
				/**
				 * Format: date-time
				 * @description The timestamp when the report was updated.
				 */
				readonly updated_on?: string
				/** @description The UUID that can be used to identify the report. */
				readonly uuid?: string
			}))
		readonly report_annotation: {
			readonly type: "report_annotation"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/**
				 * @description The type of the report.
				 * @enum {string}
				 */
				readonly annotation_type?: "BUG" | "CODE_SMELL" | "VULNERABILITY"
				/**
				 * Format: date-time
				 * @description The timestamp when the report was created.
				 */
				readonly created_on?: string
				/** @description The details to show to users when clicking on the annotation. */
				readonly details?: string
				/** @description ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique. */
				readonly external_id?: string
				/** @description The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field. */
				readonly line?: number
				/**
				 * Format: uri
				 * @description A URL linking to the annotation in an external tool.
				 */
				readonly link?: string
				/** @description The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified. */
				readonly path?: string
				/**
				 * @description The state of the report. May be set to PENDING and later updated.
				 * @enum {string}
				 */
				readonly result?: "FAILED" | "IGNORED" | "PASSED" | "SKIPPED"
				/**
				 * @description The severity of the annotation.
				 * @enum {string}
				 */
				readonly severity?: "CRITICAL" | "HIGH" | "LOW" | "MEDIUM"
				/** @description The message to display to users. */
				readonly summary?: string
				/**
				 * Format: date-time
				 * @description The timestamp when the report was updated.
				 */
				readonly updated_on?: string
				/** @description The UUID that can be used to identify the annotation. */
				readonly uuid?: string
			}))
		/**
		 * Report Data
		 * @description A key-value element that will be displayed along with the report.
		 */
		readonly report_data: {
			/** @description A string describing what this data field represents. */
			readonly title?: string
			/**
			 * @description The type of data contained in the value field. If not provided, then the value will be detected as a boolean, number or string.
			 * @enum {string}
			 */
			readonly type?:
				| "BOOLEAN"
				| "DATE"
				| "DURATION"
				| "LINK"
				| "NUMBER"
				| "PERCENTAGE"
				| "TEXT"
			/** @description The value of the data element. */
			readonly value?: Record<string, unknown>
		}
		readonly repository: {
			readonly type: "repository"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly created_on?: string
				readonly description?: string
				/**
				 * @description
				 *     Controls the rules for forking this repository.
				 *
				 *     * **allow_forks**: unrestricted forking
				 *     * **no_public_forks**: restrict forking to private forks (forks cannot
				 *       be made public later)
				 *     * **no_forks**: deny all forking
				 *
				 * @enum {string}
				 */
				readonly fork_policy?: "allow_forks" | "no_forks" | "no_public_forks"
				/** @description The concatenation of the repository owner's username and the slugified name, e.g. "evzijst/interruptingcow". This is the same string used in Bitbucket URLs. */
				readonly full_name?: string
				/** @description
				 *     The issue tracker for this repository is enabled. Issue Tracker
				 *     features are not supported for repositories in workspaces
				 *     administered through admin.atlassian.com.
				 *      */
				readonly has_issues?: boolean
				/** @description
				 *     The wiki for this repository is enabled. Wiki
				 *     features are not supported for repositories in workspaces
				 *     administered through admin.atlassian.com.
				 *      */
				readonly has_wiki?: boolean
				readonly is_private?: boolean
				readonly language?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly avatar?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					readonly clone?: readonly {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}[]
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly commits?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly downloads?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly forks?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly hooks?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly pullrequests?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly watchers?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly mainbranch?: components["schemas"]["branch"]
				readonly name?: string
				readonly owner?: components["schemas"]["account"]
				readonly parent?: components["schemas"]["repository"]
				readonly project?: components["schemas"]["project"]
				/** @enum {string} */
				readonly scm?: "git"
				readonly size?: number
				/** Format: date-time */
				readonly updated_on?: string
				/** @description The repository's immutable id. This can be used as a substitute for the slug segment in URLs. Doing this guarantees your URLs will survive renaming of the repository by its owner, or even transfer of the repository to a different user. */
				readonly uuid?: string
			}))
		/**
		 * Repository Group Permission
		 * @description A group's permission for a given repository.
		 */
		readonly repository_group_permission: Readonly<Record<string, unknown>> & {
			readonly group?: components["schemas"]["group"]
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			/** @enum {string} */
			readonly permission?: "admin" | "none" | "read" | "write"
			readonly repository?: components["schemas"]["repository"]
			readonly type: string
		}
		/**
		 * Repository Inheritance State
		 * @description A json object representing the repository's inheritance state values
		 */
		readonly repository_inheritance_state: Readonly<Record<string, unknown>> & {
			readonly override_settings?: Record<string, unknown>
			readonly type: string
		}
		/**
		 * Repository Permission
		 * @description A user's permission for a given repository.
		 */
		readonly repository_permission: Readonly<Record<string, unknown>> & {
			/** @enum {string} */
			readonly permission?: "admin" | "none" | "read" | "write"
			readonly repository?: components["schemas"]["repository"]
			readonly type: string
			readonly user?: components["schemas"]["user"]
		}
		/**
		 * Repository User Permission
		 * @description A user's direct permission for a given repository.
		 */
		readonly repository_user_permission: Readonly<Record<string, unknown>> & {
			readonly links?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly self?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			/** @enum {string} */
			readonly permission?: "admin" | "none" | "read" | "write"
			readonly repository?: components["schemas"]["repository"]
			readonly type: string
			readonly user?: components["schemas"]["user"]
		}
		readonly search_code_search_result: {
			/** Format: int64 */
			readonly content_match_count?: number
			readonly content_matches?: readonly components["schemas"]["search_content_match"][]
			readonly file?: components["schemas"]["commit_file"]
			readonly path_matches?: readonly components["schemas"]["search_segment"][]
			readonly type?: string
		}
		readonly search_content_match: {
			readonly lines?: readonly components["schemas"]["search_line"][]
		}
		readonly search_line: {
			/** Format: int32 */
			readonly line?: number
			readonly segments?: readonly components["schemas"]["search_segment"][]
		}
		readonly search_result_page: {
			/** Format: uri */
			readonly next?: string
			/** Format: int32 */
			readonly page?: number
			/** Format: int32 */
			readonly pagelen?: number
			/** Format: uri */
			readonly previous?: string
			readonly query_substituted?: boolean
			/** Format: int64 */
			readonly size?: number
			readonly values?: readonly components["schemas"]["search_code_search_result"][]
		}
		readonly search_segment: {
			readonly match?: boolean
			readonly text?: string
		}
		readonly snippet: {
			readonly type: "snippet"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly created_on?: string
				readonly creator?: components["schemas"]["account"]
				readonly id?: number
				readonly is_private?: boolean
				readonly owner?: components["schemas"]["account"]
				/**
				 * @description The DVCS used to store the snippet.
				 * @enum {string}
				 */
				readonly scm?: "git"
				readonly title?: string
				/** Format: date-time */
				readonly updated_on?: string
			}))
		readonly snippet_comment: {
			readonly type: "snippet_comment"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly snippet?: components["schemas"]["snippet"]
			}))
		readonly snippet_commit: {
			readonly type: "snippet_commit"
		} & (Omit<components["schemas"]["base_commit"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly diff?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly snippet?: components["schemas"]["snippet"]
			}))
		readonly ssh_account_key: {
			readonly type: "ssh_account_key"
		} & (Omit<components["schemas"]["ssh_key"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly owner?: components["schemas"]["account"]
			}))
		readonly ssh_key: {
			readonly type: "ssh_key"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The comment parsed from the SSH key (if present) */
				readonly comment?: string
				/** Format: date-time */
				readonly created_on?: string
				/** @description The SSH public key value in OpenSSH format. */
				readonly key?: string
				/** @description The user-defined label for the SSH key */
				readonly label?: string
				/** Format: date-time */
				readonly last_used?: string
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** @description The SSH key's immutable ID. */
				readonly uuid?: string
			}))
		/**
		 * Subject Types
		 * @description The mapping of resource/subject types pointing to their individual event types.
		 */
		readonly subject_types: {
			readonly repository?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly events?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
			readonly workspace?: {
				/**
				 * Link
				 * @description A link to a resource related to this object.
				 */
				readonly events?: {
					/** Format: uri */
					readonly href?: string
					readonly name?: string
				}
			}
		}
		readonly tag: components["schemas"]["ref"] &
			(Readonly<Record<string, unknown>> & {
				/**
				 * Format: date-time
				 * @description The date that the tag was created, if available
				 */
				readonly date?: string
				/** @description The message associated with the tag, if available. */
				readonly message?: string
				readonly tagger?: components["schemas"]["author"]
			})
		/**
		 * Task
		 * @description A task object.
		 */
		readonly task: {
			readonly content: {
				/** @description The user's content rendered as HTML. */
				readonly html?: string
				/**
				 * @description The type of markup language the raw content is to be interpreted in.
				 * @enum {string}
				 */
				readonly markup?: "creole" | "markdown" | "plaintext"
				/** @description The text as it was typed by a user. */
				readonly raw?: string
			}
			/** Format: date-time */
			readonly created_on: string
			readonly creator: components["schemas"]["account"]
			readonly id?: number
			readonly pending?: boolean
			readonly resolved_by?: components["schemas"]["account"]
			/**
			 * Format: date-time
			 * @description The ISO8601 timestamp for when the task was resolved.
			 */
			readonly resolved_on?: string
			/** @enum {string} */
			readonly state: "RESOLVED" | "UNRESOLVED"
			/** Format: date-time */
			readonly updated_on: string
		}
		readonly team: {
			readonly type: "team"
		} & (Omit<components["schemas"]["account"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly links?: components["schemas"]["team_links"]
			}))
		readonly team_links: components["schemas"]["account_links"] &
			(Readonly<Record<string, unknown>> & {
				readonly html?: components["schemas"]["link"]
				readonly members?: components["schemas"]["link"]
				readonly projects?: components["schemas"]["link"]
				readonly repositories?: components["schemas"]["link"]
				readonly self?: components["schemas"]["link"]
			})
		/**
		 * Tree Entry
		 * @description Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
		 */
		readonly treeentry: Readonly<Record<string, unknown>> & {
			readonly commit?: components["schemas"]["commit"]
			/** @description The path in the repository */
			readonly path?: string
			readonly type: string
		}
		readonly user: {
			readonly type: "user"
		} & (Omit<components["schemas"]["account"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** @description The user's Atlassian account ID. */
				readonly account_id?: string
				/** @description The status of the account. Currently the only possible value is "active", but more values may be added in the future. */
				readonly account_status?: string
				readonly has_2fa_enabled?: boolean
				readonly is_staff?: boolean
				readonly links?: components["schemas"]["user_links"]
				/** @description Account name defined by the owner. Should be used instead of the "username" field. Note that "nickname" cannot be used in place of "username" in URLs and queries, as "nickname" is not guaranteed to be unique. */
				readonly nickname?: string
			}))
		readonly user_links: components["schemas"]["account_links"] &
			(Readonly<Record<string, unknown>> & {
				readonly html?: components["schemas"]["link"]
				readonly repositories?: components["schemas"]["link"]
				readonly self?: components["schemas"]["link"]
			})
		readonly version: {
			readonly type: "version"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly id?: number
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly name?: string
			}))
		readonly webhook_subscription: {
			readonly type: "webhook_subscription"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly active?: boolean
				/** Format: date-time */
				readonly created_at?: string
				/** @description A user-defined description of the webhook. */
				readonly description?: string
				/** @description The events this webhook is subscribed to. */
				readonly events?: readonly (
					| "issue:comment_created"
					| "issue:created"
					| "issue:updated"
					| "project:updated"
					| "pullrequest:approved"
					| "pullrequest:changes_request_created"
					| "pullrequest:changes_request_removed"
					| "pullrequest:comment_created"
					| "pullrequest:comment_deleted"
					| "pullrequest:comment_reopened"
					| "pullrequest:comment_resolved"
					| "pullrequest:comment_updated"
					| "pullrequest:created"
					| "pullrequest:fulfilled"
					| "pullrequest:push"
					| "pullrequest:rejected"
					| "pullrequest:unapproved"
					| "pullrequest:updated"
					| "repo:commit_comment_created"
					| "repo:commit_status_created"
					| "repo:commit_status_updated"
					| "repo:created"
					| "repo:deleted"
					| "repo:fork"
					| "repo:imported"
					| "repo:push"
					| "repo:transfer"
					| "repo:updated"
				)[]
				/** @description The secret to associate with the hook. The secret is never returned via the API. As such, this field is only used during updates. The secret can be set to `null` or "" to remove the secret (or create a hook with no secret). Leaving out the secret field during updates will leave the secret unchanged. Leaving out the secret during creation will create a hook with no secret. */
				readonly secret?: string
				/** @description Indicates whether or not the hook has an associated secret. It is not possible to see the hook's secret. This field is ignored during updates. */
				readonly secret_set?: boolean
				readonly subject?: components["schemas"]["object"]
				/**
				 * @description The type of entity. Set to either `repository` or `workspace` based on where the subscription is defined.
				 * @enum {string}
				 */
				readonly subject_type?: "repository" | "workspace"
				/**
				 * Format: uri
				 * @description The URL events get delivered to.
				 */
				readonly url?: string
				/** @description The webhook's id */
				readonly uuid?: string
			}))
		readonly workspace: {
			readonly type: "workspace"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				/** Format: date-time */
				readonly created_on?: string
				/**
				 * @description Controls the rules for forking repositories within this workspace.
				 *
				 *     * **allow_forks**: unrestricted forking
				 *     * **internal_only**: prevents forking of private repositories outside the workspace or to public repositories
				 *
				 * @enum {string}
				 */
				readonly forking_mode?: "allow_forks" | "internal_only"
				/** @description Indicates whether the workspace enforces private content, or whether it allows public content. */
				readonly is_privacy_enforced?: boolean
				/** @description Indicates whether the workspace is publicly accessible, or whether it is
				 *     private to the members and consequently only visible to members. */
				readonly is_private?: boolean
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly avatar?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly html?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly members?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly owners?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly projects?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly repositories?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly snippets?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				/** @description The name of the workspace. */
				readonly name?: string
				/** @description The short label that identifies this workspace. */
				readonly slug?: string
				/** Format: date-time */
				readonly updated_on?: string
				/** @description The workspace's immutable id. */
				readonly uuid?: string
			}))
		readonly workspace_membership: {
			readonly type: "workspace_membership"
		} & (Omit<components["schemas"]["object"], "type"> &
			(Readonly<Record<string, unknown>> & {
				readonly links?: {
					/**
					 * Link
					 * @description A link to a resource related to this object.
					 */
					readonly self?: {
						/** Format: uri */
						readonly href?: string
						readonly name?: string
					}
				}
				readonly user?: components["schemas"]["account"]
				readonly workspace?: components["schemas"]["workspace"]
			}))
	}
	responses: never
	parameters: never
	requestBodies: {
		/** @description The application property to create or update. */
		readonly application_property: {
			readonly content: {
				readonly "application/json": components["schemas"]["application_property"]
			}
		}
		/** @description The permission to grant */
		readonly "bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema": {
			readonly content: {
				readonly "application/json": components["schemas"]["bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema"]
			}
		}
		/** @description The permission to grant */
		readonly "bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema": {
			readonly content: {
				readonly "application/json": components["schemas"]["bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema"]
			}
		}
		/** @description The updated variable. */
		readonly pipeline_variable: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_variable"]
			}
		}
		/** @description The variable to create. */
		readonly pipeline_variable2: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_variable"]
			}
		}
		readonly project: {
			readonly content: {
				readonly "application/json": components["schemas"]["project"]
			}
		}
		/** @description The new snippet object. */
		readonly snippet: {
			readonly content: {
				readonly "application/json": components["schemas"]["snippet"]
			}
		}
	}
	headers: never
	pathItems: never
}
export type SchemaAccount = components["schemas"]["account"]
export type SchemaAccountLinks = components["schemas"]["account_links"]
export type SchemaAppUser = components["schemas"]["app_user"]
export type SchemaApplicationProperty =
	components["schemas"]["application_property"]
export type SchemaAuthor = components["schemas"]["author"]
export type SchemaBaseCommit = components["schemas"]["base_commit"]
export type SchemaBitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema =
	components["schemas"]["bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema"]
export type SchemaBitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema =
	components["schemas"]["bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema"]
export type SchemaBranch = components["schemas"]["branch"]
export type SchemaBranchingModel = components["schemas"]["branching_model"]
export type SchemaBranchingModelSettings =
	components["schemas"]["branching_model_settings"]
export type SchemaBranchrestriction = components["schemas"]["branchrestriction"]
export type SchemaComment = components["schemas"]["comment"]
export type SchemaCommentResolution =
	components["schemas"]["comment_resolution"]
export type SchemaCommit = components["schemas"]["commit"]
export type SchemaCommitComment = components["schemas"]["commit_comment"]
export type SchemaCommitFile = components["schemas"]["commit_file"]
export type SchemaCommitstatus = components["schemas"]["commitstatus"]
export type SchemaCommitter = components["schemas"]["committer"]
export type SchemaComponent = components["schemas"]["component"]
export type SchemaDefaultReviewerAndType =
	components["schemas"]["default_reviewer_and_type"]
export type SchemaDeployKey = components["schemas"]["deploy_key"]
export type SchemaDeployment = components["schemas"]["deployment"]
export type SchemaDeploymentEnvironment =
	components["schemas"]["deployment_environment"]
export type SchemaDeploymentRelease =
	components["schemas"]["deployment_release"]
export type SchemaDeploymentState = components["schemas"]["deployment_state"]
export type SchemaDeploymentStateCompleted =
	components["schemas"]["deployment_state_completed"]
export type SchemaDeploymentStateCompletedStatus =
	components["schemas"]["deployment_state_completed_status"]
export type SchemaDeploymentStateCompletedStatusFailed =
	components["schemas"]["deployment_state_completed_status_failed"]
export type SchemaDeploymentStateCompletedStatusStopped =
	components["schemas"]["deployment_state_completed_status_stopped"]
export type SchemaDeploymentStateCompletedStatusSuccessful =
	components["schemas"]["deployment_state_completed_status_successful"]
export type SchemaDeploymentStateInProgress =
	components["schemas"]["deployment_state_in_progress"]
export type SchemaDeploymentStateUndeployed =
	components["schemas"]["deployment_state_undeployed"]
export type SchemaDeploymentVariable =
	components["schemas"]["deployment_variable"]
export type SchemaDiffstat = components["schemas"]["diffstat"]
export type SchemaEffectiveRepoBranchingModel =
	components["schemas"]["effective_repo_branching_model"]
export type SchemaError = components["schemas"]["error"]
export type SchemaExportOptions = components["schemas"]["export_options"]
export type SchemaGpgAccountKey = components["schemas"]["GPG_account_key"]
export type SchemaGroup = components["schemas"]["group"]
export type SchemaHookEvent = components["schemas"]["hook_event"]
export type SchemaIssue = components["schemas"]["issue"]
export type SchemaIssueAttachment = components["schemas"]["issue_attachment"]
export type SchemaIssueChange = components["schemas"]["issue_change"]
export type SchemaIssueComment = components["schemas"]["issue_comment"]
export type SchemaIssueJobStatus = components["schemas"]["issue_job_status"]
export type SchemaLink = components["schemas"]["link"]
export type SchemaMilestone = components["schemas"]["milestone"]
export type SchemaObject = components["schemas"]["object"]
export type SchemaPaginatedAccounts =
	components["schemas"]["paginated_accounts"]
export type SchemaPaginatedAnnotations =
	components["schemas"]["paginated_annotations"]
export type SchemaPaginatedBranches =
	components["schemas"]["paginated_branches"]
export type SchemaPaginatedBranchrestrictions =
	components["schemas"]["paginated_branchrestrictions"]
export type SchemaPaginatedChangeset =
	components["schemas"]["paginated_changeset"]
export type SchemaPaginatedCommitComments =
	components["schemas"]["paginated_commit_comments"]
export type SchemaPaginatedCommitstatuses =
	components["schemas"]["paginated_commitstatuses"]
export type SchemaPaginatedComponents =
	components["schemas"]["paginated_components"]
export type SchemaPaginatedDefaultReviewerAndType =
	components["schemas"]["paginated_default_reviewer_and_type"]
export type SchemaPaginatedDeployKeys =
	components["schemas"]["paginated_deploy_keys"]
export type SchemaPaginatedDeploymentVariable =
	components["schemas"]["paginated_deployment_variable"]
export type SchemaPaginatedDeployments =
	components["schemas"]["paginated_deployments"]
export type SchemaPaginatedDiffstats =
	components["schemas"]["paginated_diffstats"]
export type SchemaPaginatedEnvironments =
	components["schemas"]["paginated_environments"]
export type SchemaPaginatedFiles = components["schemas"]["paginated_files"]
export type SchemaPaginatedGpgUserKeys =
	components["schemas"]["paginated_gpg_user_keys"]
export type SchemaPaginatedHookEvents =
	components["schemas"]["paginated_hook_events"]
export type SchemaPaginatedIssueAttachments =
	components["schemas"]["paginated_issue_attachments"]
export type SchemaPaginatedIssueComments =
	components["schemas"]["paginated_issue_comments"]
export type SchemaPaginatedIssues = components["schemas"]["paginated_issues"]
export type SchemaPaginatedLogEntries =
	components["schemas"]["paginated_log_entries"]
export type SchemaPaginatedMilestones =
	components["schemas"]["paginated_milestones"]
export type SchemaPaginatedPipelineCaches =
	components["schemas"]["paginated_pipeline_caches"]
export type SchemaPaginatedPipelineKnownHosts =
	components["schemas"]["paginated_pipeline_known_hosts"]
export type SchemaPaginatedPipelineScheduleExecutions =
	components["schemas"]["paginated_pipeline_schedule_executions"]
export type SchemaPaginatedPipelineSchedules =
	components["schemas"]["paginated_pipeline_schedules"]
export type SchemaPaginatedPipelineSteps =
	components["schemas"]["paginated_pipeline_steps"]
export type SchemaPaginatedPipelineVariables =
	components["schemas"]["paginated_pipeline_variables"]
export type SchemaPaginatedPipelines =
	components["schemas"]["paginated_pipelines"]
export type SchemaPaginatedProjectDeployKeys =
	components["schemas"]["paginated_project_deploy_keys"]
export type SchemaPaginatedProjectGroupPermissions =
	components["schemas"]["paginated_project_group_permissions"]
export type SchemaPaginatedProjectUserPermissions =
	components["schemas"]["paginated_project_user_permissions"]
export type SchemaPaginatedProjects =
	components["schemas"]["paginated_projects"]
export type SchemaPaginatedPullrequestComments =
	components["schemas"]["paginated_pullrequest_comments"]
export type SchemaPaginatedPullrequests =
	components["schemas"]["paginated_pullrequests"]
export type SchemaPaginatedRefs = components["schemas"]["paginated_refs"]
export type SchemaPaginatedReports = components["schemas"]["paginated_reports"]
export type SchemaPaginatedRepositories =
	components["schemas"]["paginated_repositories"]
export type SchemaPaginatedRepositoryGroupPermissions =
	components["schemas"]["paginated_repository_group_permissions"]
export type SchemaPaginatedRepositoryPermissions =
	components["schemas"]["paginated_repository_permissions"]
export type SchemaPaginatedRepositoryUserPermissions =
	components["schemas"]["paginated_repository_user_permissions"]
export type SchemaPaginatedSnippetComments =
	components["schemas"]["paginated_snippet_comments"]
export type SchemaPaginatedSnippetCommit =
	components["schemas"]["paginated_snippet_commit"]
export type SchemaPaginatedSnippets =
	components["schemas"]["paginated_snippets"]
export type SchemaPaginatedSshUserKeys =
	components["schemas"]["paginated_ssh_user_keys"]
export type SchemaPaginatedTags = components["schemas"]["paginated_tags"]
export type SchemaPaginatedTasks = components["schemas"]["paginated_tasks"]
export type SchemaPaginatedTreeentries =
	components["schemas"]["paginated_treeentries"]
export type SchemaPaginatedVersions =
	components["schemas"]["paginated_versions"]
export type SchemaPaginatedWebhookSubscriptions =
	components["schemas"]["paginated_webhook_subscriptions"]
export type SchemaPaginatedWorkspaceMemberships =
	components["schemas"]["paginated_workspace_memberships"]
export type SchemaPaginatedWorkspaces =
	components["schemas"]["paginated_workspaces"]
export type SchemaParticipant = components["schemas"]["participant"]
export type SchemaPipeline = components["schemas"]["pipeline"]
export type SchemaPipelineBuildNumber =
	components["schemas"]["pipeline_build_number"]
export type SchemaPipelineCache = components["schemas"]["pipeline_cache"]
export type SchemaPipelineCacheContentUri =
	components["schemas"]["pipeline_cache_content_uri"]
export type SchemaPipelineCommand = components["schemas"]["pipeline_command"]
export type SchemaPipelineCommitTarget =
	components["schemas"]["pipeline_commit_target"]
export type SchemaPipelineConfigurationSource =
	components["schemas"]["pipeline_configuration_source"]
export type SchemaPipelineError = components["schemas"]["pipeline_error"]
export type SchemaPipelineImage = components["schemas"]["pipeline_image"]
export type SchemaPipelineKnownHost =
	components["schemas"]["pipeline_known_host"]
export type SchemaPipelineRefTarget =
	components["schemas"]["pipeline_ref_target"]
export type SchemaPipelineSchedule = components["schemas"]["pipeline_schedule"]
export type SchemaPipelineScheduleExecution =
	components["schemas"]["pipeline_schedule_execution"]
export type SchemaPipelineScheduleExecutionErrored =
	components["schemas"]["pipeline_schedule_execution_errored"]
export type SchemaPipelineScheduleExecutionExecuted =
	components["schemas"]["pipeline_schedule_execution_executed"]
export type SchemaPipelineSchedulePostRequestBody =
	components["schemas"]["pipeline_schedule_post_request_body"]
export type SchemaPipelineSchedulePutRequestBody =
	components["schemas"]["pipeline_schedule_put_request_body"]
export type SchemaPipelineSelector = components["schemas"]["pipeline_selector"]
export type SchemaPipelineSshKeyPair =
	components["schemas"]["pipeline_ssh_key_pair"]
export type SchemaPipelineSshPublicKey =
	components["schemas"]["pipeline_ssh_public_key"]
export type SchemaPipelineState = components["schemas"]["pipeline_state"]
export type SchemaPipelineStateCompleted =
	components["schemas"]["pipeline_state_completed"]
export type SchemaPipelineStateCompletedError =
	components["schemas"]["pipeline_state_completed_error"]
export type SchemaPipelineStateCompletedExpired =
	components["schemas"]["pipeline_state_completed_expired"]
export type SchemaPipelineStateCompletedFailed =
	components["schemas"]["pipeline_state_completed_failed"]
export type SchemaPipelineStateCompletedResult =
	components["schemas"]["pipeline_state_completed_result"]
export type SchemaPipelineStateCompletedStopped =
	components["schemas"]["pipeline_state_completed_stopped"]
export type SchemaPipelineStateCompletedSuccessful =
	components["schemas"]["pipeline_state_completed_successful"]
export type SchemaPipelineStateInProgress =
	components["schemas"]["pipeline_state_in_progress"]
export type SchemaPipelineStateInProgressPaused =
	components["schemas"]["pipeline_state_in_progress_paused"]
export type SchemaPipelineStateInProgressRunning =
	components["schemas"]["pipeline_state_in_progress_running"]
export type SchemaPipelineStateInProgressStage =
	components["schemas"]["pipeline_state_in_progress_stage"]
export type SchemaPipelineStatePending =
	components["schemas"]["pipeline_state_pending"]
export type SchemaPipelineStep = components["schemas"]["pipeline_step"]
export type SchemaPipelineStepError =
	components["schemas"]["pipeline_step_error"]
export type SchemaPipelineStepState =
	components["schemas"]["pipeline_step_state"]
export type SchemaPipelineStepStateCompleted =
	components["schemas"]["pipeline_step_state_completed"]
export type SchemaPipelineStepStateCompletedError =
	components["schemas"]["pipeline_step_state_completed_error"]
export type SchemaPipelineStepStateCompletedExpired =
	components["schemas"]["pipeline_step_state_completed_expired"]
export type SchemaPipelineStepStateCompletedFailed =
	components["schemas"]["pipeline_step_state_completed_failed"]
export type SchemaPipelineStepStateCompletedNotRun =
	components["schemas"]["pipeline_step_state_completed_not_run"]
export type SchemaPipelineStepStateCompletedResult =
	components["schemas"]["pipeline_step_state_completed_result"]
export type SchemaPipelineStepStateCompletedStopped =
	components["schemas"]["pipeline_step_state_completed_stopped"]
export type SchemaPipelineStepStateCompletedSuccessful =
	components["schemas"]["pipeline_step_state_completed_successful"]
export type SchemaPipelineStepStateInProgress =
	components["schemas"]["pipeline_step_state_in_progress"]
export type SchemaPipelineStepStatePending =
	components["schemas"]["pipeline_step_state_pending"]
export type SchemaPipelineStepStateReady =
	components["schemas"]["pipeline_step_state_ready"]
export type SchemaPipelineTarget = components["schemas"]["pipeline_target"]
export type SchemaPipelineTrigger = components["schemas"]["pipeline_trigger"]
export type SchemaPipelineTriggerManual =
	components["schemas"]["pipeline_trigger_manual"]
export type SchemaPipelineTriggerPush =
	components["schemas"]["pipeline_trigger_push"]
export type SchemaPipelineVariable = components["schemas"]["pipeline_variable"]
export type SchemaPipelinesConfig = components["schemas"]["pipelines_config"]
export type SchemaPipelinesLinksSectionHref =
	components["schemas"]["pipelines_links_section_href"]
export type SchemaPipelinesPipelineLinks =
	components["schemas"]["pipelines_pipeline_links"]
export type SchemaProject = components["schemas"]["project"]
export type SchemaProjectBranchingModel =
	components["schemas"]["project_branching_model"]
export type SchemaProjectDeployKey = components["schemas"]["project_deploy_key"]
export type SchemaProjectGroupPermission =
	components["schemas"]["project_group_permission"]
export type SchemaProjectUserPermission =
	components["schemas"]["project_user_permission"]
export type SchemaPullrequest = components["schemas"]["pullrequest"]
export type SchemaPullrequestComment =
	components["schemas"]["pullrequest_comment"]
export type SchemaPullrequestCommentTask =
	components["schemas"]["pullrequest_comment_task"]
export type SchemaPullrequestEndpoint =
	components["schemas"]["pullrequest_endpoint"]
export type SchemaPullrequestMergeParameters =
	components["schemas"]["pullrequest_merge_parameters"]
export type SchemaPullrequestTask = components["schemas"]["pullrequest_task"]
export type SchemaPullrequestTaskCreate =
	components["schemas"]["pullrequest_task_create"]
export type SchemaPullrequestTaskUpdate =
	components["schemas"]["pullrequest_task_update"]
export type SchemaRef = components["schemas"]["ref"]
export type SchemaReport = components["schemas"]["report"]
export type SchemaReportAnnotation = components["schemas"]["report_annotation"]
export type SchemaReportData = components["schemas"]["report_data"]
export type SchemaRepository = components["schemas"]["repository"]
export type SchemaRepositoryGroupPermission =
	components["schemas"]["repository_group_permission"]
export type SchemaRepositoryInheritanceState =
	components["schemas"]["repository_inheritance_state"]
export type SchemaRepositoryPermission =
	components["schemas"]["repository_permission"]
export type SchemaRepositoryUserPermission =
	components["schemas"]["repository_user_permission"]
export type SchemaSearchCodeSearchResult =
	components["schemas"]["search_code_search_result"]
export type SchemaSearchContentMatch =
	components["schemas"]["search_content_match"]
export type SchemaSearchLine = components["schemas"]["search_line"]
export type SchemaSearchResultPage = components["schemas"]["search_result_page"]
export type SchemaSearchSegment = components["schemas"]["search_segment"]
export type SchemaSnippet = components["schemas"]["snippet"]
export type SchemaSnippetComment = components["schemas"]["snippet_comment"]
export type SchemaSnippetCommit = components["schemas"]["snippet_commit"]
export type SchemaSshAccountKey = components["schemas"]["ssh_account_key"]
export type SchemaSshKey = components["schemas"]["ssh_key"]
export type SchemaSubjectTypes = components["schemas"]["subject_types"]
export type SchemaTag = components["schemas"]["tag"]
export type SchemaTask = components["schemas"]["task"]
export type SchemaTeam = components["schemas"]["team"]
export type SchemaTeamLinks = components["schemas"]["team_links"]
export type SchemaTreeentry = components["schemas"]["treeentry"]
export type SchemaUser = components["schemas"]["user"]
export type SchemaUserLinks = components["schemas"]["user_links"]
export type SchemaVersion = components["schemas"]["version"]
export type SchemaWebhookSubscription =
	components["schemas"]["webhook_subscription"]
export type SchemaWorkspace = components["schemas"]["workspace"]
export type SchemaWorkspaceMembership =
	components["schemas"]["workspace_membership"]
export type RequestBodyApplicationProperty =
	components["requestBodies"]["application_property"]
export type RequestBodyBitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema =
	components["requestBodies"]["bitbucket.apps.permissions.serializers.ProjectPermissionUpdateSchema"]
export type RequestBodyBitbucketAppsPermissionsSerializersRepoPermissionUpdateSchema =
	components["requestBodies"]["bitbucket.apps.permissions.serializers.RepoPermissionUpdateSchema"]
export type RequestBodyPipelineVariable =
	components["requestBodies"]["pipeline_variable"]
export type RequestBodyPipelineVariable2 =
	components["requestBodies"]["pipeline_variable2"]
export type RequestBodyProject = components["requestBodies"]["project"]
export type RequestBodySnippet = components["requestBodies"]["snippet"]
export type $defs = Record<string, never>
export interface operations {
	readonly getCommitHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The commit. */
				readonly commit: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The value of the property. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["application_property"]
				}
			}
		}
	}
	readonly updateCommitHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The commit. */
				readonly commit: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["application_property"]
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly deleteCommitHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The commit. */
				readonly commit: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly getPullrequestsForCommit: {
		readonly parameters: {
			readonly query?: {
				/** @description Which page to retrieve */
				readonly page?: number
				/** @description How many pull requests to retrieve per page */
				readonly pagelen?: number
			}
			readonly header?: never
			readonly path: {
				/** @description The SHA1 of the commit */
				readonly commit: string
				/** @description The repository; either the UUID in curly braces, or the slug */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The paginated list of pull requests. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pullrequests"]
				}
			}
			/** @description The repository's pull requests are still being indexed. */
			readonly 202: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pullrequests"]
				}
			}
			/** @description Either the repository does not exist, or pull request commit links have not yet been indexed. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getReportsForCommit: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit for which to retrieve reports. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_reports"]
				}
			}
		}
	}
	readonly getReport: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit the report belongs to. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Either the uuid or external-id of the report. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["report"]
				}
			}
			/** @description The report with the given ID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly createOrUpdateReport: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit the report belongs to. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Either the uuid or external-id of the report. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The report to create or update */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["report"]
			}
		}
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["report"]
				}
			}
			/** @description The provided Report object is malformed or incomplete. */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteReport: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit the report belongs to. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Either the uuid or external-id of the report. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description No content */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly getAnnotationsForReport: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit for which to retrieve reports. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Uuid or external-if of the report for which to get annotations for. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_annotations"]
				}
			}
		}
	}
	readonly bulkCreateOrUpdateAnnotations: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The commit for which to retrieve reports. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Uuid or external-if of the report for which to get annotations for. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The annotations to create or update */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": readonly components["schemas"]["report_annotation"][]
			}
		}
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": readonly components["schemas"]["report_annotation"][]
				}
			}
		}
	}
	readonly getAnnotation: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the uuid or external-id of the annotation. */
				readonly annotationId: string
				/** @description The commit the report belongs to. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Either the uuid or external-id of the report. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["report_annotation"]
				}
			}
			/** @description The annotation with the given ID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly createOrUpdateAnnotation: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the uuid or external-id of the annotation. */
				readonly annotationId: string
				/** @description The commit the report belongs to. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Either the uuid or external-id of the report. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The annotation to create or update */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["report_annotation"]
			}
		}
		readonly responses: {
			/** @description OK */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["report_annotation"]
				}
			}
			/** @description The provided Annotation object is malformed or incomplete. */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteAnnotation: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the uuid or external-id of the annotation. */
				readonly annotationId: string
				/** @description The commit the annotation belongs to. */
				readonly commit: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description Either the uuid or external-id of the annotation. */
				readonly reportId: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description No content */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly getDeploymentsForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The matching deployments. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_deployments"]
				}
			}
		}
	}
	readonly getDeploymentVariables: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The retrieved deployment variables. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_deployment_variable"]
				}
			}
		}
	}
	readonly createDeploymentVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The variable to create */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["deployment_variable"]
			}
		}
		readonly responses: {
			/** @description The variable was created. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created variable. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["deployment_variable"]
				}
			}
			/** @description The account, repository, environment or variable with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description A variable with the provided key already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updateDeploymentVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the variable to update. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The updated deployment variable. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["deployment_variable"]
			}
		}
		readonly responses: {
			/** @description The deployment variable was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["deployment_variable"]
				}
			}
			/** @description The account, repository, environment or variable with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteDeploymentVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the variable to delete. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account, repository, environment or variable with given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getDeploymentForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The deployment UUID. */
				readonly deployment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The deployment. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["deployment"]
				}
			}
			/** @description No account, repository or deployment with the UUID provided exists. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getEnvironmentsForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The matching environments. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_environments"]
				}
			}
		}
	}
	readonly createEnvironment: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The environment to create. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["deployment_environment"]
			}
		}
		readonly responses: {
			/** @description The environment was created. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created environment. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["deployment_environment"]
				}
			}
			/** @description The account or repository does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description An environment host with the provided name already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getEnvironmentForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment UUID. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The environment. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["deployment_environment"]
				}
			}
			/** @description No account, repository or environment with the UUID provided exists. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteEnvironmentForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment UUID. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The environment was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description No account or repository with the UUID provided exists. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updateEnvironmentForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The environment UUID. */
				readonly environment_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The environment update request was accepted. */
			readonly 202: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description No account, repository or environment with the UUID provided exists. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelinesForRepository: {
		readonly parameters: {
			readonly query?: {
				/** @description The creation date to filter by. */
				readonly created_on?: string
				/** @description The UUID of the creator of the pipeline to filter by. */
				readonly "creator.uuid"?: string
				/** @description The page number of elements to retrieve. */
				readonly page?: number
				/** @description The maximum number of results to return. */
				readonly pagelen?: number
				/** @description The attribute name to sort on. */
				readonly sort?: "created_on" | "creator.uuid" | "run_creation_date"
				/** @description The pipeline status to filter by. */
				readonly status?:
					| "BUILDING"
					| "ERROR"
					| "FAILED"
					| "HALTED"
					| "PARSING"
					| "PASSED"
					| "PAUSED"
					| "PENDING"
					| "STOPPED"
					| "UNKNOWN"
				/** @description The name of the branch to filter by. */
				readonly "target.branch"?: string
				/** @description The revision to filter by. */
				readonly "target.commit.hash"?: string
				/** @description The reference name to filter by. */
				readonly "target.ref_name"?: string
				/** @description The type of the reference to filter by. */
				readonly "target.ref_type"?: "ANNOTATED_TAG" | "BRANCH" | "TAG"
				/** @description The pipeline pattern to filter by. */
				readonly "target.selector.pattern"?: string
				/** @description The type of pipeline to filter by. */
				readonly "target.selector.type"?:
					| "BRANCH"
					| "CUSTOM"
					| "DEFAULT"
					| "PULLREQUESTS"
					| "TAG"
				/** @description The trigger type to filter by. */
				readonly trigger_type?: "MANUAL" | "PARENT_STEP" | "PUSH" | "SCHEDULED"
			}
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The matching pipelines. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipelines"]
				}
			}
		}
	}
	readonly createPipelineForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The pipeline to initiate. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline"]
			}
		}
		readonly responses: {
			/** @description The initiated pipeline. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created pipeline. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline"]
				}
			}
			/** @description The account or repository is not enabled, the yml file does not exist in the repository for the given revision, or the request body contained invalid properties. */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description The account or repository was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineConfig: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The account. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The repository pipelines configuration. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipelines_config"]
				}
			}
		}
	}
	readonly updateRepositoryPipelineConfig: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The updated repository pipelines configuration. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipelines_config"]
			}
		}
		readonly responses: {
			/** @description The repository pipelines configuration was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipelines_config"]
				}
			}
		}
	}
	readonly updateRepositoryBuildNumber: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The build number to update. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_build_number"]
			}
		}
		readonly responses: {
			/** @description The build number has been configured. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_build_number"]
				}
			}
			/** @description The update failed because the next number was invalid (it should be higher than the current number). */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description The account or repository was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineSchedules: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The list of schedules. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_schedules"]
				}
			}
			/** @description The account or repository was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly createRepositoryPipelineSchedule: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The schedule to create. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_schedule_post_request_body"]
			}
		}
		readonly responses: {
			/** @description The created schedule. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created schedule. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline_schedule"]
				}
			}
			/** @description There were errors validating the request. */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description The maximum limit of schedules for this repository was reached. */
			readonly 401: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description The account or repository was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineSchedule: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The uuid of the schedule. */
				readonly schedule_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The requested schedule. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_schedule"]
				}
			}
			/** @description The account, repository or schedule was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updateRepositoryPipelineSchedule: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The uuid of the schedule. */
				readonly schedule_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The schedule to update. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_schedule_put_request_body"]
			}
		}
		readonly responses: {
			/** @description The schedule is updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_schedule"]
				}
			}
			/** @description The account, repository or schedule was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteRepositoryPipelineSchedule: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The uuid of the schedule. */
				readonly schedule_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The schedule was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account, repository or schedule was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineScheduleExecutions: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The uuid of the schedule. */
				readonly schedule_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The list of executions of a schedule. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_schedule_executions"]
				}
			}
			/** @description The account or repository was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineSshKeyPair: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The SSH key pair. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_ssh_key_pair"]
				}
			}
			/** @description The account, repository or SSH key pair was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updateRepositoryPipelineKeyPair: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The created or updated SSH key pair. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_ssh_key_pair"]
			}
		}
		readonly responses: {
			/** @description The SSH key pair was created or updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_ssh_key_pair"]
				}
			}
			/** @description The account, repository or SSH key pair was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteRepositoryPipelineKeyPair: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The SSH key pair was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account, repository or SSH key pair was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineKnownHosts: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The retrieved known hosts. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_known_hosts"]
				}
			}
		}
	}
	readonly createRepositoryPipelineKnownHost: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The known host to create. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_known_host"]
			}
		}
		readonly responses: {
			/** @description The known host was created. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created pipeline known host. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline_known_host"]
				}
			}
			/** @description The account or repository does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description A known host with the provided hostname already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineKnownHost: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the known host to retrieve. */
				readonly known_host_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The known host. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_known_host"]
				}
			}
			/** @description The account, repository or known host with the specified UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updateRepositoryPipelineKnownHost: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the known host to update. */
				readonly known_host_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The updated known host. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_known_host"]
			}
		}
		readonly responses: {
			/** @description The known host was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_known_host"]
				}
			}
			/** @description The account, repository or known host with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteRepositoryPipelineKnownHost: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the known host to delete. */
				readonly known_host_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The known host was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account, repository or known host with given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineVariables: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The retrieved variables. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_variables"]
				}
			}
		}
	}
	readonly createRepositoryPipelineVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The variable to create. */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_variable"]
			}
		}
		readonly responses: {
			/** @description The variable was created. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created pipeline variable. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account or repository does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description A variable with the provided key already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the variable to retrieve. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account, repository or variable with the specified UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updateRepositoryPipelineVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the variable to update. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		/** @description The updated variable */
		readonly requestBody: {
			readonly content: {
				readonly "application/json": components["schemas"]["pipeline_variable"]
			}
		}
		readonly responses: {
			/** @description The variable was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account, repository or variable with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteRepositoryPipelineVariable: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the variable to delete. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account, repository or variable with given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineCaches: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The account. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The list of caches for the given repository. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_caches"]
				}
			}
			/** @description The account or repository was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteRepositoryPipelineCaches: {
		readonly parameters: {
			readonly query: {
				/** @description The cache name. */
				readonly name: string
			}
			readonly header?: never
			readonly path: {
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The account. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The caches were deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The workspace, repository or cache name was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deleteRepositoryPipelineCache: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the cache to delete. */
				readonly cache_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The account. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The cache was deleted. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The workspace, repository or cache_uuid with given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryPipelineCacheContentURI: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the cache. */
				readonly cache_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The account. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The cache content uri. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_cache_content_uri"]
				}
			}
			/** @description The workspace, repository or cache_uuid with given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The pipeline UUID. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The pipeline. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline"]
				}
			}
			/** @description No account, repository or pipeline with the UUID provided exists. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineStepsForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The steps. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_steps"]
				}
			}
		}
	}
	readonly getPipelineStepForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the step. */
				readonly step_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The step. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_step"]
				}
			}
			/** @description No account, repository, pipeline or step with the UUID provided exists for the pipeline with the UUID provided. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineStepLogForRepository: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the step. */
				readonly step_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The raw log file for this pipeline step. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The log has the same etag as the provided If-None-Match header. */
			readonly 304: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/octet-stream": components["schemas"]["error"]
				}
			}
			/** @description After the step is completed, the log is moved to long term storage and a redirection to the log file is returned. */
			readonly 307: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description A pipeline with the given UUID does not exist, a step with the given UUID does not exist in the pipeline or a log file does not exist for the given step. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/octet-stream": components["schemas"]["error"]
				}
			}
			/** @description The requested range does not exist for requests that specified the [HTTP Range header](https://tools.ietf.org/html/rfc7233#section-3.1). */
			readonly 416: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/octet-stream": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineContainerLog: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description For the main build container specify the step UUID; for a service container specify the service container UUID */
				readonly log_uuid: string
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the step. */
				readonly step_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The raw log file for the build container or service container. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description After the step is completed, the log is moved to long term storage and a redirection to the log file is returned. */
			readonly 307: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description No account, repository, pipeline, step or log exist for the provided path. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/octet-stream": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineTestReports: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the step. */
				readonly step_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description A summary of test reports for this pipeline step. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description No account, repository, pipeline, step or test reports exist for the provided path. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineTestReportTestCases: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the step. */
				readonly step_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description Test cases for this pipeline step. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description No account, repository, pipeline, step or test reports exist for the provided path. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineTestReportTestCaseReasons: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The UUID of the step. */
				readonly step_uuid: string
				/** @description The UUID of the test case. */
				readonly test_case_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description Test case reasons (output). */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description No account, repository, pipeline, step or test case with the UUID provided exists for the pipeline with the UUID provided. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly stopPipeline: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the pipeline. */
				readonly pipeline_uuid: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The pipeline has been signaled to stop. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The specified pipeline has already completed. */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Either the account, repository or pipeline with the given UUID does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getRepositoryHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The value of the property. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["application_property"]
				}
			}
		}
	}
	readonly updateRepositoryHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["application_property"]
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly deleteRepositoryHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly getPullRequestHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The pull request ID. */
				readonly pullrequest_id: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The value of the property. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["application_property"]
				}
			}
		}
	}
	readonly updatePullRequestHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The pull request ID. */
				readonly pullrequest_id: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["application_property"]
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly deletePullRequestHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description The pull request ID. */
				readonly pullrequest_id: string
				/** @description The repository. */
				readonly repo_slug: string
				/** @description The repository container; either the workspace slug or the UUID in curly braces. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly getPipelineVariablesForTeam: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The account. */
				readonly username: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The found account level variables. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_variables"]
				}
			}
		}
	}
	readonly createPipelineVariableForTeam: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The account. */
				readonly username: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: components["requestBodies"]["pipeline_variable2"]
		readonly responses: {
			/** @description The created variable. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created pipeline variable. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description A variable with the provided key already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineVariableForTeam: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The account. */
				readonly username: string
				/** @description The UUID of the variable to retrieve. */
				readonly variable_uuid: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account or variable with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updatePipelineVariableForTeam: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The account. */
				readonly username: string
				/** @description The UUID of the variable. */
				readonly variable_uuid: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["pipeline_variable"]
		readonly responses: {
			/** @description The variable was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account or the variable was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deletePipelineVariableForTeam: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The account. */
				readonly username: string
				/** @description The UUID of the variable to delete. */
				readonly variable_uuid: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable was deleted */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account or the variable with the provided UUID does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly searchTeam: {
		readonly parameters: {
			readonly query: {
				/** @description Which page of the search results to retrieve */
				readonly page?: number
				/** @description How many search results to retrieve per page */
				readonly pagelen?: number
				/** @description The search query */
				readonly search_query: string
			}
			readonly header?: never
			readonly path: {
				/** @description The account to search in; either the username or the UUID in curly braces */
				readonly username: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description Successful search */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["search_result_page"]
				}
			}
			/** @description If the search request was invalid due to one of the
			 *     following reasons:
			 *
			 *     * the specified type of target account doesn''t match the actual
			 *     account type;
			 *
			 *     * malformed pagination properties;
			 *
			 *     * missing or malformed search query, in the latter case an error
			 *     key will be returned in `error.data.key` property.
			 *      */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Search is not enabled for the requested team, navigate to [https://bitbucket.org/search](https://bitbucket.org/search) to turn it on */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Too many requests, try again later */
			readonly 429: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineVariablesForUser: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The found user level variables. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_variables"]
				}
			}
		}
	}
	readonly createPipelineVariableForUser: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: components["requestBodies"]["pipeline_variable2"]
		readonly responses: {
			/** @description The created variable. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created pipeline variable. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description A variable with the provided key already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineVariableForUser: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
				/** @description The UUID of the variable to retrieve. */
				readonly variable_uuid: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account or variable with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updatePipelineVariableForUser: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
				/** @description The UUID of the variable. */
				readonly variable_uuid: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["pipeline_variable"]
		readonly responses: {
			/** @description The variable was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The account or the variable was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deletePipelineVariableForUser: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
				/** @description The UUID of the variable to delete. */
				readonly variable_uuid: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable was deleted */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The account or the variable with the provided UUID does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly retrieveUserHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The value of the property. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["application_property"]
				}
			}
		}
	}
	readonly updateUserHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["application_property"]
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly deleteUserHostedPropertyValue: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The key of the Connect app. */
				readonly app_key: string
				/** @description The name of the property. */
				readonly property_name: string
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description An empty response. */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
		}
	}
	readonly searchAccount: {
		readonly parameters: {
			readonly query: {
				/** @description Which page of the search results to retrieve */
				readonly page?: number
				/** @description How many search results to retrieve per page */
				readonly pagelen?: number
				/** @description The search query */
				readonly search_query: string
			}
			readonly header?: never
			readonly path: {
				/** @description Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID. */
				readonly selected_user: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description Successful search */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["search_result_page"]
				}
			}
			/** @description If the search request was invalid due to one of the
			 *     following reasons:
			 *
			 *     * the specified type of target account doesn''t match the actual
			 *     account type;
			 *
			 *     * malformed pagination properties;
			 *
			 *     * missing or malformed search query, in the latter case an error
			 *     key will be returned in `error.data.key` property.
			 *      */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Search is not enabled for the requested user, navigate to [https://bitbucket.org/search](https://bitbucket.org/search) to turn it on */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Too many requests, try again later */
			readonly 429: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getOIDCConfiguration: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The OpenID configuration */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The workspace was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getOIDCKeys: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The keys in JSON web key format */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The workspace was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineVariablesForWorkspace: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The found workspace level variables. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["paginated_pipeline_variables"]
				}
			}
		}
	}
	readonly createPipelineVariableForWorkspace: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: components["requestBodies"]["pipeline_variable2"]
		readonly responses: {
			/** @description The created variable. */
			readonly 201: {
				headers: {
					/** @description The URL of the newly created pipeline variable. */
					readonly Location?: string
					readonly [name: string]: unknown
				}
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The workspace does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description A variable with the provided key already exists. */
			readonly 409: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly getPipelineVariableForWorkspace: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the variable to retrieve. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The workspace or variable with the given UUID was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly updatePipelineVariableForWorkspace: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the variable. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody: components["requestBodies"]["pipeline_variable"]
		readonly responses: {
			/** @description The variable was updated. */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["pipeline_variable"]
				}
			}
			/** @description The workspace or the variable was not found. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly deletePipelineVariableForWorkspace: {
		readonly parameters: {
			readonly query?: never
			readonly header?: never
			readonly path: {
				/** @description The UUID of the variable to delete. */
				readonly variable_uuid: string
				/** @description This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`. */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description The variable was deleted */
			readonly 204: {
				headers: Readonly<Record<string, unknown>>
				content?: never
			}
			/** @description The workspace or the variable with the provided UUID does not exist. */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
	readonly searchWorkspace: {
		readonly parameters: {
			readonly query: {
				/** @description Which page of the search results to retrieve */
				readonly page?: number
				/** @description How many search results to retrieve per page */
				readonly pagelen?: number
				/** @description The search query */
				readonly search_query: string
			}
			readonly header?: never
			readonly path: {
				/** @description The workspace to search in; either the slug or the UUID in curly braces */
				readonly workspace: string
			}
			readonly cookie?: never
		}
		readonly requestBody?: never
		readonly responses: {
			/** @description Successful search */
			readonly 200: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["search_result_page"]
				}
			}
			/** @description If the search request was invalid due to one of the
			 *     following reasons:
			 *
			 *     * the specified type of target account doesn''t match the actual
			 *     account type;
			 *
			 *     * malformed pagination properties;
			 *
			 *     * missing or malformed search query, in the latter case an error
			 *     key will be returned in `error.data.key` property.
			 *      */
			readonly 400: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Search is not enabled for the requested workspace, navigate to [https://bitbucket.org/search](https://bitbucket.org/search) to turn it on */
			readonly 404: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
			/** @description Too many requests, try again later */
			readonly 429: {
				headers: Readonly<Record<string, unknown>>
				content: {
					readonly "application/json": components["schemas"]["error"]
				}
			}
		}
	}
}
